/* CsiLgrDate.js

   Copyright (C) 2010, 2011 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Friday 09 July 2010
   Last Change: Friday 01 April 2011
   Last Commit: $Date: 2013-02-20 08:32:12 -0700 (Wed, 20 Feb 2013) $
   Last Changed by: $Author: tmecham $

*/

////////////////////////////////////////////////////////////
// class CsiLgrDate
//
// Defines an object that is capable of storing a datalogger time stamp with a
// resolution of milli-seconds.  Internally, this  class will maintain the
// date/time as milli-seconds elapsed since midnight 1 January 1990.
//
// This class has been adapted from the original DateTime class that was written by Wayne
// Campbell and uses concepts from the following articles:
//
//  Dr. Dobb's Journal #80, June 1983 
//     True Julian dates as used by astronomers take noon, 1 January 4713 BC as their base. We
//     will use the same base but base from midnight rather than noon.
//
//  Collected Algorithms from CACM - Algorithm 199
//     1 March 1900 = Julian Day 2415080 (noon based)
//     1 January 0000 = Julian Day 1721119
//     1 January 1970 = Julian Day 2440588
//     1 January 1980 = Julian day 2444240
//     1 January 1970 fell on a Thursday
//     The difference between 1 January 1990 and 1 January 1970 is 631,152,000
//     seconds or 7,305 days
////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////
// constructor
////////////////////////////////////////////////////////////
function CsiLgrDate()
{
   if(arguments.length > 0)
   {
      var arg1 = arguments[0];
      var arg1_type = typeof arg1;
      this.milliSecs = 0;
      if(arg1_type === "string")
      {
         this.milliSecs = CsiLgrDate.fromStr(arg1).milliSecs;
      }
      else if(arg1 instanceof Date)
      {
         this.milliSecs = arg1.getTime();
         this.milliSecs -= arg1.getTimezoneOffset() * CsiLgrDate.msecPerMin;
         this.milliSecs -= CsiLgrDate.unix_to_csi_diff * CsiLgrDate.msecPerDay;
      }
      else if(arg1 instanceof CsiLgrDate)
      {
         this.milliSecs = arg1.milliSecs;
      }
      else if(arg1_type === "number" || arg1 instanceof Number)
      {
         if(arguments.length === 1)
         {
            this.milliSecs = arg1;
         }
         else
         {
            var year = arg1;
            var month = 0;
            var day = 1;
            var hours = 0;
            var minutes = 0;
            var seconds = 0;
            var millis = 0;
            if(arguments.length > 1)
            {
               month = arguments[1];
            }
            if(arguments.length > 2)
            {
               month = arguments[2];
            }
            if(arguments.length > 3)
            {
               day = arguments[3];
            }
            if(arguments.length > 4)
            {
               hours = arguments[4];
            }
            if(arguments.length > 5)
            {
               minutes = arguments[5];
            }
            if(arguments.length > 6)
            {
               seconds = arguments[6];
            }
            if(arguments.length > 7)
            {
               millis = arguments[7];
            }
            this.setDate(year, month, day);
            this.setTime(hours, minutes, seconds, millis);
         }
      }
      else
      {
         this.milliSecs = 0;
      }
   }
   else
   {
      this.milliSecs = 0;
   }
}

CsiLgrDate.nsecPerUSec = 1000;
CsiLgrDate.nsecPerMSec = CsiLgrDate.nsecPerUSec * 1000;
CsiLgrDate.nsecPerSec = CsiLgrDate.nsecPerMSec * 1000;
CsiLgrDate.msecPerSec = 1000;
CsiLgrDate.msecPerMin = CsiLgrDate.msecPerSec * 60;
CsiLgrDate.msecPerHour = CsiLgrDate.msecPerMin * 60;
CsiLgrDate.msecPerDay = CsiLgrDate.msecPerHour * 24;
CsiLgrDate.msecPerWeek = CsiLgrDate.msecPerDay * 7;
CsiLgrDate.julDay0 = 1721119;
CsiLgrDate.julDay1970 = 2440588;
CsiLgrDate.unix_to_csi_diff = 7305;
CsiLgrDate.julDay1990 = CsiLgrDate.julDay1970 + CsiLgrDate.unix_to_csi_diff;


CsiLgrDate.leap_year = function (year)
{ return ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0); };

////////////////////////////////////////////////////////////
// setDate
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.setDate = function ()
{
   // interpret the arguments.  We will perform input bounds checking while
   // doing this
   var year = 1990;
   var month = 1;
   var day = 1;
   var month_lens = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
   if(arguments.length >= 1)
   {
      year = Number(arguments[0]);
   }
   if(CsiLgrDate.leap_year(year))
   {
      month_lens[1] += 1;
   }
   if(arguments.length >= 2)
   {
      month = Number(arguments[1]);
      if(month < 1)
      {
         month = 1;
      }
      if(month > 12)
      {
         month = 12;
      }
   }
   if(arguments.length >= 3)
   {
      day = Number(arguments[2]);
      if(day < 1)
      {
         day = 1;
      }
      if(day > month_lens[month - 1])
      {
         day = month_lens[month - 1];
      }
   }

   // preserve the time information and separate the century and year
   var time = this.toTime();
   var century;
   var year_of_century;
   var y, m;
   if(month >= 3)
   {
      m = month - 3;
      y = year;
   }
   else
   {
      m = month + 9;
      y = year - 1;
   }
   century = Math.floor(y / 100);
   year_of_century = y % 100;

   // we can now calculate the number of days since 1 January 0000
   var days_cent = Math.floor((146097 * century) / 4);
   var days_ano = Math.floor((1461 * year_of_century) / 4);
   var days_mes = Math.floor((153 * m + 2) / 5);
   var days = days_cent + days_ano + days_mes + day;
   days -= CsiLgrDate.julDay1990 - CsiLgrDate.julDay0;
   this.milliSecs = days * CsiLgrDate.msecPerDay +
         time.hour * CsiLgrDate.msecPerHour +
         time.minute * CsiLgrDate.msecPerMin +
         time.second * CsiLgrDate.msecPerSec +
         time.msec;
};

////////////////////////////////////////////////////////////
// truediv
////////////////////////////////////////////////////////////
CsiLgrDate.truediv = function (numerator, denominator)
{
   var quotient = numerator / denominator;
   var remainder = numerator % denominator;
   if(remainder < 0)
   {
      --quotient;
      remainder += denominator;
   }
   return {
      "quotient": Math.floor(quotient),
      "remainder": Math.floor(remainder)
   };
};

////////////////////////////////////////////////////////////
// setTime
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.setTime = function ()
{
   // process the parameters
   var hour = 0;
   var minute = 0;
   var second = 0;
   var msec = 0;

   if(arguments.length >= 1)
   {
      hour = arguments[0];
      if(hour > 24)
      {
         hour = 24;
      }
   }
   if(arguments.length >= 2)
   {
      minute = arguments[1];
      if(minute > 59)
      {
         minute = 59;
      }
   }
   if(arguments.length >= 3)
   {
      second = arguments[2];
      if(second > 59)
      {
         second = 59;
      }
   }
   if(arguments.length >= 4)
   {
      msec = arguments[3];
      if(msec > CsiLgrDate.msecPerSec)
      {
         msec = CsiLgrDate.msecPerSec;
      }
   }

   // we now need to strip off the current time of the timestamp.  We can then add the new values
   var qr = CsiLgrDate.truediv(this.milliSecs, CsiLgrDate.msecPerDay);
   this.milliSecs -= qr.remainder;
   this.milliSecs += hour * CsiLgrDate.msecPerHour +
         minute * CsiLgrDate.msecPerMin +
         second * CsiLgrDate.msecPerSec +
         msec;
};

////////////////////////////////////////////////////////////
// setMSec
//
// Sets the milli-seconds within the seconds leaving the rest of the date
// and time alone.
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.setMSec = function (msec)
{
   var qr = CsiLgrDate.truediv(this.milliSecs, CsiLgrDate.msecPerSec);
   this.milliSecs = this.milliSecs - qr.quotient + msec;
};

////////////////////////////////////////////////////////////
// toDate
//
// Breaks the date down into the year, month, and day components.  These
// values will be returned as an object.
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.toDate = function ()
{
   // we will express the stamp in terms of days since 1990
   var qr = CsiLgrDate.truediv(this.milliSecs, CsiLgrDate.msecPerDay);

   // we can now calulate the number of days since 1 January 0000 and strip off the century
   var clk = CsiLgrDate.julDay1990 - CsiLgrDate.julDay0 + qr.quotient;
   var year = Math.floor((4 * clk - 1) / 146097);
   var month;
   var day;

   clk = 4 * clk - 1 - year * 146097;

   // we can now strip off the year into the century, month, and day
   var d = Math.floor(clk / 4);

   clk = Math.floor((4 * d + 3) / 1461);
   d = 4 * d + 3 - clk * 1461;
   d = Math.floor((d + 4) / 4);
   month = Math.floor((5 * d - 3) / 153);
   d = 5 * d - 3 - month * 153;
   day = Math.floor((d + 5) / 5);
   year = 100 * year + clk;
   if(month < 10)
   {
      month += 3;
   }
   else
   {
      month -= 9;
      ++year;
   }
   return {
      "year": year,
      "month": month,
      "day": day
   };
};

////////////////////////////////////////////////////////////
// toTime
//
// Breaks down the time portion into hours, minutes, seconds, and milli-seconds
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.toTime = function ()
{
   var qr = CsiLgrDate.truediv(this.milliSecs, CsiLgrDate.msecPerSec);
   var rtn = {
      "hour": 0,
      "minute": 0,
      "second": 0,
      "msec": qr.remainder
   };

   qr = CsiLgrDate.truediv(qr.quotient, 60);
   rtn.second = qr.remainder;
   qr = CsiLgrDate.truediv(qr.quotient, 60);
   rtn.minute = qr.remainder;
   qr = CsiLgrDate.truediv(qr.quotient, 24);
   rtn.hour = qr.remainder;
   return rtn;
};

////////////////////////////////////////////////////////////
// year
//
// Returns the year for this stamp.
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.year = function ()
{ return this.toDate().year; };

////////////////////////////////////////////////////////////
// month
//
// Returns the month of the year for this stamp.
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.month = function ()
{ return this.toDate().month; };

////////////////////////////////////////////////////////////
// day
//
// Returns the day of the month for this stamp
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.day = function ()
{ return this.toDate().day; };

////////////////////////////////////////////////////////////
// hour
//
// Returns the hour of the day for this stamp.
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.hour = function ()
{ return this.toTime().hour; };

////////////////////////////////////////////////////////////
// minute
//
// Returns the minutes into the hour for this stamp.
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.minute = function ()
{ return this.toTime().minute; };

////////////////////////////////////////////////////////////
// second
//
// Returns the seconds into the minute for this stamp.
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.second = function ()
{ return this.toTime().second; };

////////////////////////////////////////////////////////////
// msec
//
// Returns the milliseconds into the second for this stamp.
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.msec = function ()
{ return this.toTime().msec; };

////////////////////////////////////////////////////////////
// dayOfWeek
//
// Returns day of the week for this stamp such that 0 < dayOfWeek <= 7
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.dayOfWeek = function ()
{
   var days = Math.floor(
      this.milliSecs / CsiLgrDate.msecPerDay + CsiLgrDate.julDay1990 - CsiLgrDate.julDay0);
   return ((days + 2) % 7) + 1;
};

////////////////////////////////////////////////////////////
// dayOfYear
//
// Returns the day of the year for this stamp such that 0 < dayOfYear() <= 366.
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.dayOfYear = function ()
{
   var year_start = new CsiLgrDate();
   year_start.setDate(this.year());
   return Math.floor(
      ((this.milliSecs - year_start.milliSecs) / CsiLgrDate.msecPerDay) + 1);
};

////////////////////////////////////////////////////////////
// make_date
//
// Generates a Javascript Date object from this timestamp.  
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.make_date = function ()
{
   var date = this.toDate();
   var time = this.toTime();
   return new Date(
      date.year, date.month - 1, date.day,
      time.hour, time.minute, time.second, time.msec);
};

////////////////////////////////////////////////////////////
// getTime
//
// Converts our epoch into the epoch used for the JavaScript Date class.  
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.getTime = function ()
{ return this.make_date().getTime(); };

////////////////////////////////////////////////////////////
// fromStr
//
// Attempts to parse a time stamp from a string. 
////////////////////////////////////////////////////////////
CsiLgrDate.fromStr = function (s)
{
   var rtn;
   var tokens = CsiLgrDate.make_tokens(s);
   var format = CsiLgrDate.determine_format(tokens);
   switch(format)
   {
      case 1:
         rtn = CsiLgrDate.read_format1(tokens);
         break;

      case 2:
         rtn = CsiLgrDate.read_format2(tokens);
         break;

      case 3:
         rtn = CsiLgrDate.read_format3(tokens);
         break;

      case 4:
         rtn = CsiLgrDate.read_format4(tokens);
         break;

      case 5:
         rtn = CsiLgrDate.read_format5(tokens);
         break;

      case 6:
         rtn = CsiLgrDate.read_format6(tokens);
         break;

      case 7:
         rtn = CsiLgrDate.read_format7(tokens);
         break;

      default:
         rtn = new CsiLgrDate();
         rtn.milliSecs = NaN;
         break;
   }
   return rtn;
};

////////////////////////////////////////////////////////////
// gmt
//
// Constructs a new CsiLgrDate using the current system time in GMT.
////////////////////////////////////////////////////////////
CsiLgrDate.gmt = function ()
{
   var now = new Date();
   return new CsiLgrDate(now.getTime() - CsiLgrDate.unix_to_csi_diff * CsiLgrDate.msecPerDay);
};

////////////////////////////////////////////////////////////
// local
//
// Constructs a new CsiLgrDate using the current system time and local time zone
////////////////////////////////////////////////////////////
CsiLgrDate.local = function ()
{ return new CsiLgrDate(new Date()); };

////////////////////////////////////////////////////////////
// format
//
// Formats the date and time according to the strfime() type format
// string.  The following set of codes are recognised:
//
//   %a  -  abbreviated weekday name according to locale
//   %A  -  full weekday name according to locale
//   %b  -  abbreviated month name according to locale
//   %B  -  Full month name according to locale
//   %c  -  Local date and time representation (Short Version)
//   %#c -  Local date and time representation (Long Version)
//   %d  -  day of month, two spaces, rights justified, padded with zero
//   %H  -  hours into the day, two spaces right justified, padded with zero
//   %#H -  hours into the day similar to %H.  If the time is between 0:00:00
//          and 0:00:59, the hour will be formatted as 24 and the previous day
//          will be used. 
//   %I  -  Hour with 12 hour clock, two spaces right justified, padded with zero
//   %j  -  Day of year, three spaces right justified, padded with zero
//   %m  -  numeric month, two spaces right justified, padded with zero
//   %M  -  minutes into the hour, two spaces, rights justified, padded with zero
//   %p  -  local equivalent of "AM" or "PM" specifier
//   %S  -  seconds into the minute, two spaces, right justified, padded with zero
//   %U  -  week number of the year (Sunday being the first day of the week)
//   %w  -  day of week as an integer, one space
//   %W  -  week number of the year (Monday being the first day of the week)
//   %y  -  years into century, two spaces, rights justified, padded with zero
//   %Y  -  year as an integer
//   %1  -  tenths of seconds, one space
//   %2  -  hundredths of seconds, two spaces, rights justified, padded with zero
//   %3  -  thousands of seconds, three spaces, right justified, padded with zero
//   %4  -  1/10000 of second, four spaces, right justified, padded with zero
//   %5  -  1/100000 of second, five spaces, right justified, padded with zero
//   %6  -  micro-seconds, six spaces, right justified, padded with zero
//   %7  -  1/10000000 of second, seven spaces, right justified, padded with zero
//   %8  -  1/100000000 of seconds, eight spaces, right justified, padded with zero
//   %9  -  nano-seconds, nine spaces, right justified, padded with zero
//   %x  -  prints the sub-second resolution of the stamp with a preceding period with no padding
//   %X  -  local time representation
//   %n  -  local date representation (%x conflicts with previous usage)
//   %Z  -  Time zone name
//   %%  -  Prints the '%' character
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.format = function (spec)
{
   // break the date into its component parts. 
   var abbrev_days = [
      "Sun", "Mon", "Tues", "Wed", "Thur", "Fri", "Sat"];
   var full_days = [
      "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
   var abbrev_months = [
      "Jan", "Feb", "Mar", "Apr", "May", "June", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
   var full_months = [
      "January", "February", "March", "April", "May", "June",
      "July", "August", "September", "October", "November", "December"];
   var rtn = "";
   var last_char = 0;
   var len = spec.length;
   var time_zone_pos;
   var temp;
   var date = this.toDate();
   var time = this.toTime();
   var jsdate = this.make_date();
   var year_start;
   var week1_start_day;
   var this_day;
   var weeks;
   // if the hour represents midnight, we may need to adjust this date and print hours as 24.
   if(time.hour === 0 && time.minute === 0)
   {
      // search the format string for an instance of "%#H", if present, we will replace it
      // with 24 and reformat with the previous days date.
      var flagged_day_pos = spec.search(/%#H/);
      if(flagged_day_pos > 0)
      {
         var new_date = new CsiLgrDate(this.milliSecs - CsiLgrDate.msecPerDay);
         return new_date.format(spec.replace(/%#H/, "24"));
      }
   }

   var i;
   for(i = 0; i < len; ++i)
   {
      if(last_char !== '%' && spec.charAt(i) !== '%')
      {
         rtn += spec.charAt(i);
      }
      else if(last_char === '%')
      {
         var flagged = (spec.charAt(i) === '#');
         if(flagged && i + 1 < spec.length)
         {
            ++i;
         }
         switch(spec.charAt(i))
         {
            case '%':
               rtn += '%';
               if(i + 1 < len)
               {
                  ++i;
                  rtn += spec.charAt(i);
               }
               break;

            case 'a':
               rtn += abbrev_days[this.dayOfWeek() - 1];
               break;

            case 'A':
               rtn += full_days[this.dayOfWeek() - 1];
               break;

            case 'b':
               rtn += abbrev_months[date.month - 1];
               break;

            case 'B':
               rtn += full_months[date.month - 1];
               break;

            case 'c':
               if(flagged)
               {
                  temp = jsdate.toLocaleString();
                  time_zone_pos = temp.lastIndexOf(" GMT");
                  if(time_zone_pos >= 0)
                  {
                     rtn += temp.slice(0, time_zone_pos);
                  }
                  else
                  {
                     rtn += temp;
                  }
               }
               else
               {
                  temp = this.format("%Y-%m-%d ");
                  rtn += temp + jsdate.toLocaleTimeString();
               }
               break;

            case 'Z':
               temp = jsdate.toTimeString();
               time_zone_pos = temp.lastIndexOf(" GMT");
               if(time_zone_pos >= 0)
               {
                  rtn += temp.slice(time_zone_pos, temp.length);
               }
               break;

            case 'd':
               rtn += CsiLgrDate.pad_zero(date.day, 2);
               break;

            case 'H':
               rtn += CsiLgrDate.pad_zero(time.hour, 2);
               break;

            case 'I':
               temp = time.hour % 12;
               if(temp === 0)
               {
                  temp = 12;
               }
               rtn += CsiLgrDate.pad_zero(temp, 2);
               break;

            case 'j':
               rtn += CsiLgrDate.pad_zero(this.dayOfYear(), 3);
               break;

            case 'm':
               rtn += CsiLgrDate.pad_zero(date.month, 2);
               break;

            case 'M':
               rtn += CsiLgrDate.pad_zero(time.minute, 2);
               break;

            case 'n':
               rtn += jsdate.toLocaleDateString();
               break;

            case 'p':
               if(time.hour >= 12)
               {
                  rtn += "PM";
               }
               else
               {
                  rtn += "AM";
               }
               break;

            case 'S':
               rtn += CsiLgrDate.pad_zero(time.second, 2);
               break;

            case 'U':
               year_start = new CsiLgrDate(date.year, 1, 1);
               week1_start_day = year_start.dayOfWeek() - 1;
               this_day = this.dayOfYear();

               if(week1_start_day !== 0)
               {
                  week1_start_day = 7 - week1_start_day;
               }
               weeks = Math.floor((this_day - week1_start_day) / 7) + 1;
               rtn += weeks.toString();
               break;

            case 'W':
               year_start = new CsiLgrDate(date.year, 1, 1);
               week1_start_day = year_start.dayOfWeek() - 1;
               this_day = this.dayOfYear();

               if(week1_start_day !== 1)
               {
                  week1_start_day = 8 - week1_start_day;
               }
               weeks = Math.floor((this_day - week1_start_day) / 7) + 1;
               rtn += weeks.toString();
               break;

            case 'w':
               rtn += this.dayOfWeek() - 1;
               break;

            case 'X':
               rtn += jsdate.toLocaleTimeString();
               break;

            case 'y':
               rtn += CsiLgrDate.pad_zero(date.year % 100, 2);
               break;

            case 'Y':
               rtn += CsiLgrDate.pad_zero(date.year, 4);
               break;

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
               var digits = spec[i] - '0';
               var exponent = 9 - digits;
               var divisor = 1;
               var j;
               for(j = 0; j < exponent; ++j)
               {
                  divisor *= 10;
               }
               rtn += CsiLgrDate.pad_zero(
               Math.floor((time.msec * CsiLgrDate.nsecPerMSec) / divisor),
               digits);
               break;

            case 'x':
               if(time.msec > 0)
               {
                  temp = time.msec.toString();
                  rtn += ".";
                  if(temp.length === 1)
                  {
                     rtn += "00";
                  }
                  else if(temp.length === 2)
                  {
                     rtn += "0";
                  }
                  rtn += temp;
               }
               break;
         }
      }
      last_char = spec.charAt(i);
   }
   return rtn;
};

////////////////////////////////////////////////////////////
// toString
//
// Overloads the regular toString to format the date
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.toString = function ()
{ return this.format("%Y-%m-%d %H:%M:%S%x"); };

////////////////////////////////////////////////////////////
// valueOf
//
// Overrides the regular valueOf to return the internal representation.
////////////////////////////////////////////////////////////
CsiLgrDate.prototype.valueOf = function ()
{ return this.milliSecs; };

////////////////////////////////////////////////////////////
// make_tokens
//
// Implements the algorithm  that will perform the lexical scanning for parsing
// date/time strings.
////////////////////////////////////////////////////////////
CsiLgrDate.make_tokens = function (buff)
{
   var token = "";
   var rtn = [];
   var last_ch = 0;

   var i;
   for(i = 0; i < buff.length; ++i)
   {
      // skip multiple spaces
      if(buff[i] === ' ' && last_ch === ' ')
      {
         continue;
      }
      last_ch = buff.charAt(i);

      // break the token if a delimiter is found
      switch(buff.charAt(i))
      {
         case '/':
         case '-':
         case ' ':
         case ';':
         case ':':
         case '.':
         case 'T':
            rtn.push(token);
            token = "";
            break;

         case ',':
            break;

         default:
            token += buff.charAt(i);
            break;
      }
   }

   // add the final token if there is any remainder
   if(token.length > 0)
   {
      rtn.push(token);
   }
   return rtn;
};

////////////////////////////////////////////////////////////
// is_numeric
//
// Evaluates whether the string specified consists entirely of numeric
// characters.
////////////////////////////////////////////////////////////
CsiLgrDate.is_numeric = function (s)
{
   var rtn = true;
   var i;
   for(i = 0; rtn && i < s.length; ++i)
   {
      if(s[i] < '0' || s[i] > '9')
      {
         rtn = false;
      }
   }
   return rtn;
};

////////////////////////////////////////////////////////////
// which_month
//
// Resolves the english name of a month or its abbreviation to a month code such that
// 0 <= which_month() < 12,
////////////////////////////////////////////////////////////
CsiLgrDate.which_month = function (s_)
{
   var rtn = -1;
   var s = s_.toLowerCase();
   var abbrev_month_names = [
      "jan",
      "feb",
      "mar",
      "apr",
      "may",
      "jun",
      "jul",
      "aug",
      "sep",
      "oct",
      "nov",
      "dec"];
   var full_month_names = [
      "january",
      "february",
      "march",
      "april",
      "may",
      "june",
      "july",
      "august",
      "september",
      "october",
      "november",
      "december"];

   var i;
   for(i = 0; rtn < 0 && i < full_month_names.length; ++i)
   {
      if(s.localeCompare(abbrev_month_names[i]) === 0 ||
         s.localeCompare(full_month_names[i]) === 0)
      {
         rtn = i;
      }
   }
   return rtn;
};

////////////////////////////////////////////////////////////
// determine_format
//
// Based upon the tokens that were generated from make_tokens(), this method
// will determine the specific format, if any, that the date/time string is
// using.  
////////////////////////////////////////////////////////////
CsiLgrDate.determine_format = function (tokens)
{
   var rtn = 0;
   if(tokens.length >= 2 &&
      CsiLgrDate.is_numeric(tokens[0]) &&
      tokens[0].length <= 2 &&
      CsiLgrDate.is_numeric(tokens[1]) &&
      tokens[1].length <= 2)
   {
      rtn = 1;
   }
   else if(tokens.length >= 1 &&
           CsiLgrDate.is_numeric(tokens[0]) &&
           (tokens[0].length === 6 || tokens[0].length === 8))
   {
      rtn = 3;
   }
   else if(tokens.length >= 3 &&
           CsiLgrDate.is_numeric(tokens[0]) &&
           tokens[0].length === 4 &&
           CsiLgrDate.is_numeric(tokens[1]) &&
           CsiLgrDate.is_numeric(tokens[2]))
   {
      rtn = 7;
   }
   else if(tokens.length >= 2 &&
           CsiLgrDate.which_month(tokens[0]) >= 0)
   {
      rtn = 4;
   }
   else if(tokens.length >= 2 && CsiLgrDate.which_month(tokens[1]) >= 0)
   {
      rtn = 5;
   }
   else if(tokens.length >= 1 && CsiLgrDate.is_numeric(tokens[0]))
   {
      rtn = 6;
   }
   return rtn;
};

////////////////////////////////////////////////////////////
// read_time
//
// Parses the hours, minutes, seconds, and nsec from the time string. 
// //////////////////////////////////////////////////////////
CsiLgrDate.read_time = function (tokens, start)
{
   var rtn = {};
   rtn.hour = 0;
   rtn.minute = 0;
   rtn.second = 0;
   rtn.nsec = 0;
   var i, j;
   for(i = 0; i < tokens.length; ++i)
   {
      switch(i - start)
      {
         case 0:
            rtn.hour = tokens[i];
            break;

         case 1:
            rtn.minute = tokens[i];
            break;

         case 2:
            rtn.second = tokens[i];
            break;

         case 3:
            rtn.nsec = tokens[i];
            for(j = 9 - tokens[i].length; j > 0; --j)
            {
               rtn.nsec *= 10;
            }
            break;
      }
   }
   return rtn;
};

////////////////////////////////////////////////////////////
// convert_components
//
// Converts the specified components into a LgrDate
////////////////////////////////////////////////////////////
CsiLgrDate.convert_components = function (year, month, day, hour, minute, second, nsec)
{
   var rtn = new CsiLgrDate();
   if(year < 100 && year >= 50)
   {
      year += 1900;
   }
   else if(year < 100 && year < 50)
   {
      year += 2000;
   }
   rtn.setDate(year, month, day);
   rtn.setTime(hour, minute, second, Math.floor(nsec / CsiLgrDate.nsecPerMSec));
   return rtn;
};

////////////////////////////////////////////////////////////
// read_format1
////////////////////////////////////////////////////////////
CsiLgrDate.read_format1 = function (tokens)
{
   var month = tokens[0];
   var day = tokens[1];
   var year = tokens[2];
   var time = CsiLgrDate.read_time(tokens, 3);
   return CsiLgrDate.convert_components(year, month, day, time.hour, time.minute, time.second, time.nsec);
};

////////////////////////////////////////////////////////////
// read_format2
////////////////////////////////////////////////////////////
CsiLgrDate.read_format2 = function (tokens)
{
   var day = tokens[0];
   var month = tokens[1];
   var year = tokens[2];
   var time = CsiLgrDate.read_time(tokens, 3);
   return CsiLgrDate.convert_components(year, month, day, time.hour, time.minute, time.second, time.nsec);
};

////////////////////////////////////////////////////////////
// read_format3
////////////////////////////////////////////////////////////
CsiLgrDate.read_format3 = function (tokens)
{
   var code = tokens[0];
   var day = Math.floor(code % 100);
   code /= 100;
   var month = Math.floor(code % 100);
   code /= 100;
   var year = Math.floor(code);
   var time = CsiLgrDate.read_time(tokens, 1);
   return CsiLgrDate.convert_components(year, month, day, time.hour, time.minute, time.second, time.nsec);
};

////////////////////////////////////////////////////////////
// read_format4
////////////////////////////////////////////////////////////
CsiLgrDate.read_format4 = function (tokens)
{
   var month = CsiLgrDate.which_month(tokens[0]) + 1;
   var day = tokens[1];
   var year = tokens[2];
   var time = CsiLgrDate.read_time(tokens, 3);
   return CsiLgrDate.convert_components(year, month, day, time.hour, time.minute, time.second, time.nsec);
};

////////////////////////////////////////////////////////////
// read_format5
////////////////////////////////////////////////////////////
CsiLgrDate.read_format5 = function (tokens)
{
   var day = tokens[0];
   var month = CsiLgrDate.which_month(tokens[1]) + 1;
   var year = tokens[2];
   var time = CsiLgrDate.read_time(tokens, 3);
   return CsiLgrDate.convert_components(year, month, day, time.hour, time.minute, time.second, time.nsec);
};

////////////////////////////////////////////////////////////
// read_format6
////////////////////////////////////////////////////////////
CsiLgrDate.read_format6 = function (tokens)
{
   var time = CsiLgrDate.read_time(tokens, 0);
   return CsiLgrDate.convert_components(0, 0, 0, time.hour, time.minute, time.second, time.nsec);
};

////////////////////////////////////////////////////////////
// read_format7
////////////////////////////////////////////////////////////
CsiLgrDate.read_format7 = function (tokens)
{
   var year = tokens[0];
   var month = tokens[1];
   var day = tokens[2];
   var time = CsiLgrDate.read_time(tokens, 3);
   return CsiLgrDate.convert_components(year, month, day, time.hour, time.minute, time.second, time.nsec);
};

////////////////////////////////////////////////////////////
// pad_zero
//
// Right justifies a number with preceding zeroes. 
////////////////////////////////////////////////////////////
CsiLgrDate.pad_zero = function (val, places)
{
   var temp = val.toString();
   var rtn = "";
   var i;
   for(i = 0; temp.length + i < places; ++i)
   {
      rtn += "0";
   }
   rtn += temp;
   return rtn;
};


////////////////////////////////////////////////////////////
// csi_max_timestamp
//
// Evaluates two timestamps and returns the value that is greatest. 
////////////////////////////////////////////////////////////
CsiLgrDate.max = function (time1, time2)
{
   var rtn = new CsiLgrDate(time1);
   if(time2.milliSecs > time1.milliSecs)
   {
      rtn = new CsiLgrDate(time2);
   }
   return rtn;
};

/* sprintf.js

   Copyright (C) 2011, 2011 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Monday 14 February 2011
   Last Change: Tuesday 17 May 2011
   Last Commit: $Date: 2013-03-13 12:58:49 -0600 (Wed, 13 Mar 2013) $
   Last Changed by: $Author: jon $

*/


function sprintf()
{
   var state_normal = 0;
   var state_flags = 1;
   var state_width = 2;
   var state_precision = 3;
   var state_conv = 4;   
   var format_spec = arguments[0].toString();
   var current_argument = 1;
   var pad_zero = false;
   var alternate = false;
   var add_sign = false;
   var left_justify = false;
   var width = 0;
   var precision = 6;
   var i = 0;
   var j = 0;
   var format_spec_len = format_spec.length;
   var state = state_normal;
   var rtn = String();
   var do_next_char = false;
   var ch;
   var scratch = String();
   var value;
   var locale_prototype = Number(1024.25).toLocaleString();
   var thousands_sep = locale_prototype.charAt(1);
   var decimal_point = locale_prototype.charAt(5);

   if(thousands_sep.localeCompare('.') !== 0 && thousands_sep.localeCompare(',') !== 0)
   {
      thousands_sep = ',';
   }
   if(decimal_point.localeCompare('.') !== 0 && decimal_point.localeCompare(',') !== 0)
   {
      decimal_point = '.';
   }
   while(i < format_spec_len)
   {
      ch = format_spec.charAt(i);
      do_next_char = true;
      if(state === state_normal)
      {
         if(ch === '%')
         {
            pad_zero = false;
            alternate = false;
            width = 0;
            precision = 6;
            add_sign = false;
            left_justify = false;
            state = state_flags;
         }
         else
         {
            rtn += ch;
         }
      }
      else if(state === state_flags)
      {
         switch(ch)
         {
         case '%':
            state = state_normal;
            rtn += '%';
            break;
            
         case '-':
            left_justify = true;
            break;
            
         case '+':
            add_sign = true;
            break;
            
         case '#':
            alternate = true;
            break;
            
         case ' ':
            // this doesn't seem to make any difference with boost::format()
            break;
            
         case '0':
            pad_zero = true;
            break;
            
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case '*':
            state = state_width;
            do_next_char = false;
            scratch = "";
            break;

         case '.':
            state = state_precision;
            scratch = "";
            break;

         default:
            state = state_conv;
            do_next_char = false;
            break;
         }
      }
      else if(state === state_width)
      {
         switch(ch)
         {
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
            scratch += ch;
            break;

         case '*':
            width = Number(arguments[current_argument++]);
            state = state_precision;
            break;
            
         case '.':
            width = Number(scratch);
            scratch = "";
            state = state_precision;
            break;

         default:
            width = Number(scratch);
            do_next_char = false;
            state = state_conv;
            break;
         }
      }
      else if(state === state_precision)
      {
         switch(ch)
         {
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
            scratch += ch;
            break;

         case '*':
            precision = Number(arguments[current_argument++]);
            state = state_conv;
            break;

         default:
            precision = Number(scratch);
            do_next_char = false;
            state = state_conv;
            break;
         }
      }
      else if(state === state_conv)
      {
         switch(ch)
         {
         case 'd':              // integer conversion
         case 'i':
         case 'u':
            value = Number(arguments[current_argument++]);
            if(isNaN(value))
            {
               rtn += "NAN";
            }
            else if(value === Infinity)
            {
               rtn += "+INF";
            }
            else if(value === -Infinity)
            {
               rtn += "-INF";
            }
            else
            {
               if(value < 0 || add_sign)
               {
                  if(value < 0)
                  {
                     rtn += "-";
                     value = -value;
                  }
                  else
                  {
                     rtn += "+";
                  }
                  --width;
               }
               scratch = value.toFixed(0);
               if(scratch.length < width)
               {
                  if(left_justify)
                  {
                     rtn += scratch;
                     for(j = scratch.length; j < width; ++j)
                     {
                        rtn += ' ';
                     }
                  }
                  else
                  {
                     for(j = scratch.length; j < width; ++j)
                     {
                        if(pad_zero)
                        {
                           rtn += '0';
                        }
                        else
                        {
                           rtn += ' ';
                        }
                     }
                     rtn += scratch;
                  }
               }
            }
            break;

         case 'o':              // octal conversion
            value = Number(arguments[current_argument++]);
            if(isNaN(value))
            {
               rtn += "NAN";
            }
            else if(value === Infinity)
            {
               rtn += "+INF";
            }
            else if(value === -Infinity)
            {
               rtn += "-INF";
            }
            else
            {
               if(alternate)
               {
                  rtn += '0';
                  --width;
               }
               scratch = value.toString(8);
               if(scratch.length < width)
               {
                  if(left_justify)
                  {
                     rtn += scratch;
                     for(j = scratch.length; j < width; ++j)
                     {
                        rtn += ' ';
                     }
                  }
                  else
                  {
                     for(j = scratch.length; j < width; ++j)
                     {
                        if(pad_zero)
                        {
                           rtn += '0';
                        }
                        else
                        {
                           rtn += ' ';
                        }
                     }
                     rtn += scratch;
                  }
               }
               else
               {
                  rtn += scratch;
               }
            }
            break;
            
         case 'x':
         case 'X':              // hex conversion
            value = Number(arguments[current_argument++]);
            if(isNaN(value))
            {
               rtn += "NAN";
            }
            else if(value === Infinity)
            {
               rtn += "+INF";
            }
            else if(value === -Infinity)
            {
               rtn += "-INF";
            }
            else
            {
               if(alternate)
               {
                  if(ch === 'x')
                  {
                     rtn += "0x";
                  }
                  else
                  {
                     rtn += "0X";
                  }
                  width -= 2;
               }

               scratch = value.toString(16);
               if(ch === 'X')
               {
                  scratch = scratch.toUpperCase();
               }

               if(scratch.length < width)
               {
                  if(left_justify)
                  {
                     rtn += scratch;
                     for(j = scratch.length; j < width; ++j)
                     {
                        rtn += ' ';
                     }
                  }
                  else
                  {
                     for(j = scratch.length; j < width; ++j)
                     {
                        if(pad_zero)
                        {
                           rtn += '0';
                        }
                        else
                        {
                           rtn += ' ';
                        }
                     }
                     rtn += scratch;
                  }
               }
               else
               {
                  rtn += scratch;
               }
            }
            break;

         case 'c':              // convert character encoding
            value = Number(arguments[current_argument++]);
            scratch = String.fromCharCode(value);
            if(scratch.length < width)
            {
               if(left_justify)
               {
                  rtn += scratch;
                  for(j = scratch.length; j < width; ++j)
                  {
                     rtn += ' ';
                  }
               }
               else
               {
                  for(j = scratch.length; j < width; ++j)
                  {
                     rtn += ' ';
                  }
                  rtn += scratch;
               }
            }
            else
            {
               rtn += scratch;
            }
            break;

         case 's':              // convert string
            value = String(arguments[current_argument++]);
            scratch = value;
            if(scratch.length < width)
            {
               if(left_justify)
               {
                  rtn += scratch;
                  for(j = scratch.length; j < width; ++j)
                  {
                     rtn += ' ';
                  }
               }
               else
               {
                  for(j = scratch.length; j < width; ++j)
                  {
                     rtn += ' ';
                  }
                  rtn += scratch;
               }
            }
            else
            {
               rtn += scratch;
            }
            break;

         case 'e':
         case 'E':
         case 'f':
         case 'g':
         case 'G':
         case 'n':
            if(ch === 'n')
            {
               value = current_argument;
            }
            else
            {
               value = Number(arguments[current_argument++]);
            }

            if(isNaN(value))
            {
               rtn += "NAN";
            }
            else if(value === Infinity)
            {
               rtn += "+INF";
            }
            else if(value === -Infinity)
            {
               rtn = "-INF";
            }
            else
            {
               if(add_sign || value < 0)
               {
                  if(value < 0)
                  {
                     value = -value;
                     rtn += '-';
                  }
                  else
                  {
                     rtn += '+';
                  }
                  --width;
               }
               scratch = sprintf.convert_value(value, ch, precision, thousands_sep, decimal_point);
               if(scratch.length < width)
               {
                  if(left_justify)
                  {
                     rtn += scratch;
                     for(j = scratch.length; j < width; ++j)
                     {
                        rtn += ' ';
                     }
                  }
                  else
                  {
                     for(j = scratch.length; j < width; ++j)
                     {
                        if(pad_zero)
                        {
                           rtn += '0';
                        }
                        else
                        {
                           rtn += ' ';
                        }
                     }
                     rtn += scratch;
                  }
               }
               else
               {
                  rtn += scratch;
               }
            }
            break;
            
         default:
            // @todo: throw an exception for an invalid format converter
            break;
         }
      }
      if(do_next_char)
      {
         ++i;
      }
   }
   return rtn;
} // sprintf


sprintf.convert_value = function (value, format, precision, thousands_sep, decimal_point)
{
   var rtn;
   var temp = value;
   var separator_pos;
   var array;
   
   switch(format)
   {
      case 'f':
         rtn = value.toFixed(precision);
         break;

      case 'e':
      case 'E':
         rtn = value.toExponential(precision);
         if(format === 'E')
         {
            rtn = rtn.toUpperCase();
         }
         break;

      case 'g':
      case 'G':
         if(value < 1E-4)
         {
            rtn = value.toExponential(precision - 1);
         }
         else
         {
            rtn = value.toPrecision(precision);
         }
         if(format === 'G')
         {
            rtn = rtn.toUpperCase();
         }
         rtn = sprintf.trim_trailing_zeroes(rtn);
         break;
   }

   // we need to replace the decimal point with the locale decimal point character
   if(decimal_point.localeCompare('.') !== 0)
   {
      rtn = rtn.replace(".", decimal_point);
   }

   // we also need to insert thousands separators 
   if(value >= 1000)
   {
      temp = value;
      array = Csi.string_to_array(rtn);
      separator_pos = rtn.indexOf(decimal_point);
      if(separator_pos < 0)
         separator_pos = rtn.length;
      separator_pos -= 3;
      while(temp >= 1000 && separator_pos > 0)
      {
         array.splice(separator_pos, 0, thousands_sep);
         separator_pos -= 3;
         temp /= 1000;
      }
      rtn = array.join("");
   }
   return rtn;
};


sprintf.trim_trailing_zeroes = function (s)
{
   // we need to trim any zeroes trailing the decimal point but
   // preceding the exponent. 
   var array = Csi.string_to_array(s);
   var exp_pos = s.search(/[eE][+\-].\d*$/);
   var dec_point_pos = s.search(/\.\d*0*/);
   var i;

   if(exp_pos < 0)
   {
      exp_pos = array.length;
   }
   if(dec_point_pos >= 0)
   {
      for(i = exp_pos - 1; i >= dec_point_pos; --i)
      {
         if(array[i] === '0' || array[i] === '.')
         {
            array[i] = '';
         }
         else
         {
            break;
         }
      }
   }

   // trim off the exponent if it has a value of zero. 
   if(exp_pos < s.length)
   {
      var delete_exp = true;
      for(i = exp_pos; i < array.length; ++i)
      {
         if(array[i] !== 'e' && array[i] !== 'E' && array[i] !== '+' &&
            array[i] !== '-' && array[i] !== '0')
         {
            delete_exp = false;
            break;
         }
      }
      if(delete_exp)
      {
         for(i = exp_pos; i < array.length; ++i)
         {
            array[i] = '';
         }
      }
   }
   return array.join("");
};

/* CsiOperand.js

   Copyright (C) 2011, 2013 Campbell Scientific, Inc.

   Written by: 
   Date Begun: Monday 28 March 2011
   Last Change: Tuesday 05 March 2013
   Last Commit: $Date: 2013-03-05 11:50:53 -0700 (Tue, 05 Mar 2013) $
   Last Changed by: $Author: jon $

*/


////////////////////////////////////////////////////////////
// class CsiOperand
//
// Defines an operand object on an expression stack.
//////////////////////////////////////////////////////////// 
function CsiOperand()
{
   this.value = Number(0);
   this.value_type = CsiOperand.value_double;
   this.timestamp = new CsiLgrDate();
   if(arguments.length == 1)
   {
      this.value = arguments[0].value;
      this.value_type = arguments[0].value_type;
      this.timestamp = arguments[0].timestamp;
   }
   else if(arguments.length >= 2)
      this.set_val(arguments[0], arguments[1]);
}


CsiOperand.value_double = 0;
CsiOperand.value_int = 1;
CsiOperand.value_string = 2;
CsiOperand.value_date = 4;


CsiOperand.prototype.get_val = function()
{
   var rtn = 0;
   var temp;
   
   switch(this.value_type)
   {
   case CsiOperand.value_double:
   case CsiOperand.value_int:
      rtn = this.value;
      break;
      
   case CsiOperand.value_string:
      temp = this.value.toUpperCase();
      if(temp == "INF" || temp == "+INF")
         rtn = Infinity;
      else if(temp == "-INF")
         rtn = -Infinity;
      else if(temp == "NAN")
         rtn = NaN;
      else
         rtn = parseFloat(temp);
      break;
      
   case CsiOperand.value_date:
      rtn = this.value.milliSecs * CsiLgrDate.nsecPerMSec;
      break;
   }
   return rtn;
};


CsiOperand.prototype.get_val_str = function()
{
   var rtn = "";
   switch(this.value_type)
   {
   case CsiOperand.value_double:
      rtn = sprintf(this.value, "%g");
      break;
      
   case CsiOperand.value_int:
      rtn = sprintf(this.value, "%d");
      break;
      
   case CsiOperand.value_string:
      rtn = this.value;
      break;
      
   case CsiOperand.value_date:
      rtn = this.value.format("%Y-%m-%d %H:%M:%S%x");
      break;
   }
   return rtn;
};


CsiOperand.prototype.get_val_date = function()
{
   var rtn = new CsiLgrDate();
   switch(this.value_type)
   {
   case CsiOperand.value_double:
   case CsiOperand.value_int:
      rtn.milliSecs = Math.floor(this.value / CsiLgrDate.nsecPerMSec);
      break;
      
   case CsiOperand.value_string:
      rtn = CsiLgrDate.fromStr(this.value);
      break;
      
   case CsiOperand.value_date:
      rtn = this.value;
      break;
   }
   return rtn;
};


CsiOperand.prototype.get_val_int = function()
{
   var rtn = 0;
   switch(this.value_type)
   {
   case CsiOperand.value_double:
      rtn = Math.floor(this.value);
      break;
      
   case CsiOperand.value_int:
      rtn = this.value;
      break;
      
   case CsiOperand.value_string:
      // if the string consists of all hex digits, we will convert it as hex
      if(this.value.search(/[a-fA-F0-9]+^/) === 0)
      {
         rtn = parseInt(this.value, 16);
      }
      else if(this.value.search(/[0-9]+^/) >= 0)
      {
         rtn = parseInt(this.value, 10);
      }
      else
      {
         // in order to honour exponential notation, we will first convert the
         // value to floating point and then to an integer.
         rtn = Math.floor(parseFloat(this.value));
      }
      break;
      
   case CsiOperand.value_date:
      rtn = this.value.milliSecs * CsiLgrDate.nsecPerMSec;
      break;
   }
   return rtn;
};


CsiOperand.prototype.set_val = function(value, timestamp)
{
   var value_type = typeof(value);
   switch(value_type)
   {
   case "number":
      this.value = value;
      this.value_type = CsiOperand.value_double;
      break;
      
   case "string":
      this.value = value;
      this.value_type = CsiOperand.value_string;
      break;
      
   case "boolean":
      if(value)
         this.value = -1;
      else
         this.value = 0;
      this.value_type = CsiOperand.value_int;
      break;
      
   case "object":
      if(value instanceof Number)
      {
         this.value = value;
         this.value_type = CsiOperand.value_double;
      }
      else if(value instanceof String)
      {
         this.value = value;
         this.value_type = CsiOperand.value_string;
      }
      else if(value instanceof Boolean)
      {
         this.value = (value ? -1 : 0);
         this.value_type = CsiOperand.value_int;
      }
      else if(value instanceof CsiLgrDate)
      {
         this.value = new CsiLgrDate(value);
         this.value_type = CsiOperand.value_date;
      }
      else if(value instanceof CsiOperand)
      {
         this.value = value.value;
         this.value_type = value.value_type; 
      }
      else
      {
         this.value = NaN;
         this.value_type = CsiOperand.value_double;
      }
   }
   this.timestamp = timestamp; 
};


CsiOperand.prototype.set_val_int = function(value, timestamp)
{
   this.set_val(value, timestamp);
   this.value = this.get_val_int();
   this.value_type = CsiOperand.value_int;
};


CsiOperand.prototype.valueOf = function()
{
   var rtn = NaN;
   switch(this.value_type)
   {
   case CsiOperand.value_double:
   case CsiOperand.value_int:
   case CsiOperand.value_string:
      rtn = this.value;
      break;
      
   case CsiOperand.value_date:
      rtn = this.value.milliSecs;
      break;
   }
   return rtn;
};


CsiOperand.prototype.toString = function()
{ return this.get_val_str(); };

/* CsiExpression.js

   Copyright (C) 2010, 2013 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Tuesday 27 July 2010
   Last Change: Tuesday 05 March 2013
   Last Commit: $Date: 2013-03-05 11:50:53 -0700 (Tue, 05 Mar 2013) $
   Last Changed by: $Author: jon $

*/

////////////////////////////////////////////////////////////
// class CsiExpression
//
// Represents the state of an expression object
////////////////////////////////////////////////////////////
function CsiExpression(tokens)
{
   this.tokens = tokens;
   this.ownerComponent = null; //set when added to component
   this.has_table_ref = false;

   //assign variable.ParentExpression
   var len = this.tokens.length;
   for(var i = 0; i < len; i++)
   {
      var token = tokens[i];
      if(token && "set_owner_expression" in token)
      {
         token.set_owner_expression(this);
         if(!this.has_table_ref && "is_table" in token)
            this.has_table_ref = token.is_table;
      }
   }
}


CsiExpression.prototype.evaluate = function()
{
   var dataStack = [];
   var len = this.tokens.length;
   for(var i = 0; i < len; i++)
   {
      var token = this.tokens[i];
      token.evaluate(dataStack, this.tokens);
   }
   return dataStack[0];
};


CsiExpression.prototype.reset = function()
{
   var tokens_count = this.tokens.length;
   for(var i = 0; i < tokens_count; ++i)
   {
      var token = this.tokens[i];
      if(token && token.reset)
         token.reset();
   }
};

/* CsiWebQuery.js

   Copyright (C) 2010, 2013 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Monday 02 August 2010
   Last Change: Wednesday 06 March 2013
   Last Commit: $Date: 2013-04-30 09:27:07 -0600 (Tue, 30 Apr 2013) $
   Last Changed by: $Author: alex $

*/


function ExcSynchValues()
{ }


////////////////////////////////////////////////////////////
// class CsiWebQuery
//
// Defines an object that represents a data request to the web server
////////////////////////////////////////////////////////////
function CsiWebQuery(
   uri,
   mode,
   p1,
   p2,
   order,
   requestInterval,
   override_interval,
   variables,
   js_name,
   report_offset)
{
   this.uri = uri;
   this.mode = mode;
   this.p1 = p1;
   this.p2 = p2;
   this.order = order;
   this.tableDefSignature = 0;
   this.requestInterval = requestInterval; //how often should this query occur
   this.override_interval = override_interval;
   this.variables = variables; //Variables that should be updated when data comes in
   this.last_record_no = -1;
   this.last_stamp = new CsiLgrDate();
   this.js_name = js_name;
   this.report_offset = report_offset;
   var i;

   //keep list of expressions that are affected by this webQuery
   this.expressions = [];
   var len = variables.length;
   for (i = 0; i < len; i++)
   {
      //todo: This check for ownerExpression can be removed once the RTMC project is generated automatically
      if (variables[i].ownerExpression)
      {
         if($.inArray(variables[i].ownerExpression, this.expressions) === -1)
         {
            this.expressions.push(variables[i].ownerExpression);
         }
      }
   }
   this.loadingData = false;  //actively loading data?
   this.nextQueryTime = 0; //next time to request data

   this.query_satisfied = false; //date-range queries should only poll once
   this.supervisor = null;
}


//returns the command for the HTTPRequest
CsiWebQuery.prototype.getCommand = function ()
{
   if(this.supervisor && this.supervisor.on_query_begin)
   {
      this.supervisor.on_query_begin(this);
   }

   var rtn = ".?command=DataQuery" +
         "&uri=" + encodeURIComponent(this.uri) +
         "&format=json" +
         "&mode=" + this.mode +
         "&p1=" + this.p1 +
         "&p2=" + this.p2 +
         "&headsig=" + this.tableDefSignature +
         "&nextpoll=" + this.requestInterval;
   if(this.order.length > 0)
   {
      rtn = rtn + "&order=" + this.order;
   }

   if(this.override_interval >= 0)
   {
      rtn = rtn + "&refresh=" + this.override_interval;
   }
   return rtn;
};


//called when json data is received
CsiWebQuery.prototype.newData = function (json)
{
   var more_data = json.more;
   var component = null;
   var i;
   var j;
   var variable = null;
   var len;
   var len2;

   if(more_data === null)
   {
      more_data = false;
   }

   if(this.mode === "date-range" && !more_data) //Date range is always satisfied
   {
      this.query_satisfied = true;
   }

   //does the head exist?
   if(json.head)
   {
      //cache tableDefSignature for future Queries
      this.tableDefSignature = json.head.signature;

      //cache field index for variable
      if(json.head.fields)
      {
         len = this.variables.length;
         for(i = 0; i < len; i++)
         {
            variable = this.variables[i];
            variable.fieldIndex = -1;
            if(variable.is_table)
            {
               //Send the comp the table defs if it needs them
               component = variable.ownerExpression.ownerComponent;
               if(component.tableDefs)
               {
                  component.tableDefs(json.head);
               }
            }
            else
            {
               variable.fieldIndex = CsiWebQuery.getFieldIndex(json.head.fields, variable.simpleUri);
               if(variable.fieldIndex > -1)
               {
                  variable.type = json.head.fields[variable.fieldIndex].type;
               }
            }
         }
      }
   }

   // for each record
   len = json.data.length;
   var lastRecordIndex = len - 1;
   var report_data = len > 0;
   var was_bad = false;
   var was_nan = false;
   var value;

   for(i = 0; report_data && i < len; i++)
   {
      var record = json.data[i];
      var timestamp = CsiLgrDate.fromStr(record.time);
      var moreToCome = i < lastRecordIndex;

      if(this.supervisor && this.supervisor.on_new_data)
      {
         report_data = this.supervisor.on_new_data(this, record, timestamp);
      }

      // the record number and time stamp for this record should be
      // different from the last record number and time stamp
      // reported.  If they are the same, we expect that this record
      // is the same as previously reported.  
      if((this.last_record_no !== record.no ||
          this.last_stamp.milliSecs !== timestamp.milliSecs) &&
         report_data)
      {
         //update variable data
         if(report_data)
         {
            this.last_record_no = record.no;
            this.last_stamp = timestamp;
            len2 = this.variables.length;
            for(j = 0; j < len2; j++)
            {
               variable = this.variables[j];
               variable.recnum = record.no;
               variable.timestamp = new CsiLgrDate(timestamp);
               value = record.vals[variable.fieldIndex];
               if(!variable.is_table && variable.fieldIndex > -1)
               {
                  variable.set_value(value, timestamp);
               }

               variable.has_been_set = true;
               if(variable.is_table)
               {
                  component = variable.ownerExpression.ownerComponent;
                  if(component)
                  {
                     was_bad = component.bad_data;
                     if(component.newRecord)
                     {
                        component.bad_data = false;
                        component.newRecord(record, timestamp, moreToCome);
                        if(was_bad)
                        {
                           component.invalidate();
                        }
                     }
                     else
                     {
                        component.bad_data = true;
                        if(!was_bad)
                        {
                           component.invalidate();
                        }
                     }
                  }
               }
            }
         }

         // update components that want newValue(value, timestamp)
         len2 = this.expressions.length;
         value = null;
         var expression;
         for(j = 0; report_data && j < len2; j++)
         {
            expression = this.expressions[j];
            component = expression.ownerComponent;
            if(component)
            {
               was_bad = component.bad_data; //If we switch from bad to good or good to bad, we need to invalidate
               if(!expression.has_table_ref && component.newValue)
               {
                  try
                  {
                     var result = this.expressions[j].evaluate();
                     if(result)
                     {
                        component.bad_data = false;
                        was_nan = component.nan_data;
                        //Check for string types
                        if((typeof result.value === "string" || result.value instanceof String) && component.newStringValue)
                        {
                           if(component.newStringValue)
                           {
                              component.nan_data = false;
                              component.newStringValue(result.value, result.timestamp, moreToCome);
                              if(was_nan !== component.nan_data)
                              {
                                 component.invalidate();
                              }
                           }
                        }
                        else //Check numbers to see if they are finite or not
                        {
                           if(result.value === -Infinity || result.value === Infinity || isNaN(result.value))
                           {
                              component.nan_data = true;
                              if(component.newNanValue)
                              {
                                 component.newNanValue(result.value, result.timestamp, moreToCome);
                              }
                           }
                           else
                           {
                              component.nan_data = false;
                              component.newValue(result.value, result.timestamp, moreToCome);
                           }
                        }

                        if(was_bad || (was_nan !== component.nan_data))
                        {
                           component.invalidate();
                        }
                     }
                     else
                     {
                        component.bad_data = true;
                        if(!was_bad)
                        {
                           component.invalidate();
                        }
                     }
                  }
                  catch(e)
                  {
                     if(!e instanceof ExcSynchValues)
                     {
                        component.bad_data = true;
                        if(!was_bad)
                        {
                           component.invalidate();
                        }
                     }
                  }
               }
            }
         }
      }
   }

   // we need to determine what mode will be used for the next query
   if(report_data)
   {
      if(this.order !== "real-time" && this.mode !== "date-range")
      {
         this.mode = "since-record";
         this.p1 = this.last_record_no;
         this.p2 = this.last_stamp.format("%Y-%m-%dT%H:%M:%S%x");
      }
      else if(this.mode === "date-range" && more_data)
      {
         var next_stamp = new CsiLgrDate(this.last_stamp.milliSecs + 1);
         var end_stamp = CsiLgrDate.fromStr(this.p2);
         if(next_stamp < end_stamp)
         {
            this.p1 = next_stamp.format("%Y-%m-%dT%H:%M:%S%x");
         }
         else
         {
            this.query_satisfied = true;
         }
      }
   }
   return more_data && !this.query_satisfied;
};


////////////////////////////////////////////////////////////
// on_query_fail
//
// Called when an attempt to query data from the web server has failed. 
////////////////////////////////////////////////////////////
CsiWebQuery.prototype.on_query_fail = function (error)
{
   var expressions_count = this.expressions.length;
   var i;
   for(i = 0; i < expressions_count; ++i)
   {
      var expression = this.expressions[i];
      if(expression.ownerComponent)
      {
         expression.ownerComponent.bad_data = true;
         expression.ownerComponent.invalidate();
      }
   }
};


//get the FieldIndex from the json.head.fields object
CsiWebQuery.getFieldIndex = function (jsonfields, fieldName)
{
   var len = jsonfields.length;
   var lower_name = fieldName.toLowerCase();
   var lower_field;
   var i;
   for(i = 0; i < len; i++)
   {
      lower_field = jsonfields[i].name.toLowerCase();
      if(lower_name === lower_field)
      {
         return i;
      }
   }
   return -1;
};


/* $HeadURL: svn://engsoft/loggernet-4.2/coratools/javascript/CsiOneShotTimer.js $

Copyright (C) 2010 Campbell Scientific, Inc.
Started On: 8/1/2010
Started By: Kevin Westwood

$LastChangedBy: tmecham $
$LastChangedDate: 2013-02-20 08:35:21 -0700 (Wed, 20 Feb 2013) $
$LastChangedRevision: 17302 $
*/

var oneShotTimer = new CsiOneShotTimer(); //GLOBAL DECLARATION

function CsiOneShotTimer()
{
   this.timeoutID = -1;
   this.listeners = [];
   this.nextFireTime = Number.MAX_VALUE;
}


CsiOneShotTimer.prototype.setTimeout = function (listener, tag, interval)
{
   if(listener.onOneShotTimer)
   {
      var listenerHolder = new OneShotListenerHolder(listener, tag, interval);
      this.listeners.push(listenerHolder);
      if(listenerHolder.nextFireTime < this.nextFireTime)
      {
         this.stopTimer();
         this.startTimer();
      }
   }
   else
   {
      csi_log("onOneShotTimer not defined for " + listener);
   }
};


CsiOneShotTimer.prototype.clearTimeout = function(listener, tag)
{
   var listenerHolder = this.removeListener(listener, tag);
   if(listenerHolder && (listenerHolder.nextFireTime === this.nextFireTime))
   {
      this.stopTimer();
      this.startTimer();
   }
};


CsiOneShotTimer.prototype.removeListener = function(listener, tag)
{
   var i;
   var len = this.listeners.length;
   for(i = 0; i < len; i++)
   {
      var listenerHolder = this.listeners[i];
      if((listenerHolder.listener === listener) && (listenerHolder.tag === tag))
      {
         return this.listeners.splice(i, 1);
      }
   }

   return null; //not found
};


CsiOneShotTimer.prototype.stopTimer = function()
{
   //clear previous timeout
   if(this.timeoutID > -1) //timer active
   {
      clearTimeout(this.timeoutID);
      this.nextFireTime = Number.MAX_VALUE;
      this.timeoutID = -1;
   }
};


function CsiOnTimer()
{
   oneShotTimer.onTimer();
}


CsiOneShotTimer.prototype.startTimer = function()
{
   if((this.timeoutID < 0) && //not already started
       (this.listeners.length > 0)) //there are listeners
   {
      this.nextFireTime = this.listeners[0].nextFireTime;
      var currentTime = Date.now();

      var i;
      var len = this.listeners.length;
      for(i = 0; i < len; i++)
      {
         var listenerHolder = this.listeners[i];

         //nextPollTime is the earliest time that another poll should occur.
         this.nextFireTime = Math.min(this.nextFireTime, listenerHolder.nextFireTime);
      }

      //calculate the next timeout Interval
      var interval = this.nextFireTime - currentTime;
      interval = Math.max(interval, 50); //don't allow negative interval
      this.timeoutID = setTimeout(CsiOnTimer, interval);
   }
};


CsiOneShotTimer.prototype.onTimer = function ()
{
   this.timeoutID = -1;
   this.nextFireTime = Number.MAX_VALUE;

   var currentTime = Date.now();
   var listenerHolder;
   var i = this.listeners.length - 1;
   while(i >= 0)
   {
      listenerHolder = this.listeners[i];
      if(currentTime >= listenerHolder.nextFireTime)
      {
         this.listeners.splice(i, 1); //remove before calling event.
         listenerHolder.listener.onOneShotTimer(listenerHolder.tag);
      }
      i--;
   }

   this.startTimer();
};


function OneShotListenerHolder(listener, tag, interval)
{
   this.listener = listener;
   this.tag = tag;
   this.nextFireTime = Date.now() + interval;
}/* CsiUtility.js

Copyright (C) 2010, 2013 Campbell Scientific, Inc.

Written by: Jon Trauntvein
Date Begun: Thursday 12 August 2010
Last Change: Thursday 21 February 2013
Last Commit: $Date: 2013-03-04 12:49:04 -0700 (Mon, 04 Mar 2013) $
Last Changed by: $Author: tmecham $

*/


function csi_log(msg)
{
   if(typeof console === "object")
   {
      console.log(msg);
   }
}


function addToStyle (value)
{
   getStyleTextNode().nodeValue += "\n" + value;
}


function getStyleTextNode ()
{
   //get styleElement
   var styleElement;
   var styleElementSelector = $('style');
   if(styleElementSelector.length === 0)
   {
      styleElement = document.createElement("style");
      $("head").append(styleElement);
      styleElement.setAttribute("type", "text/css");
   }
   else
   {
      styleElement = styleElementSelector.get(0);
   }

   //get styleTextNode from styleElement
   var styleTextNode = null;
   if(!styleElement.childNodes || (styleElement.childNodes.length === 0)) 
   {
      styleTextNode = document.createTextNode("");
      styleElement.appendChild(styleTextNode);
   }
   else
   {
      styleTextNode = styleElement.firstChild;
   }

   return styleTextNode;
}


//floating point mod: x mod y
//25.5 mod 10 = 5.5
function fmod(x, y)
{
   //25.5 - (floor(25.5/10) * 10)
   //25.5 - (2 * 10) = 5.5
   return x - (Math.floor(x / y) * y);
}


////////////////////////////////////////////////////////////
// class Point
////////////////////////////////////////////////////////////
function Point()
{
   if(arguments.length === 2)
   {
      this.x = Number(arguments[0]); 
      this.y = Number(arguments[1]); 
   }
   else if(arguments.length === 1)
   {
      var arg = arguments[0]; 
      if(arg instanceof Point)
      {
         this.x = arg.x;
         this.y = arg.y;
      }
   }
}


Point.prototype.adjustForLines = function ()
{
   this.x = Math.floor(this.x) + 0.5;
   this.y = Math.floor(this.y) + 0.5;
};


Point.prototype.adjustForFill = function ()
{
   this.x = Math.floor(this.x);
   this.y = Math.floor(this.y);
};


Point.prototype.offset = function(dx, dy)
{
   this.x += dx;
   this.y += dy;
};


////////////////////////////////////////////////////////////
// function distance
//
// Calculates the distance between two points 
////////////////////////////////////////////////////////////
Point.distance = function(p1, p2)
{
   var dx = p1.x - p2.x;
   var dy = p1.y - p2.y;
   return Math.sqrt(dx*dx + dy*dy);
};


////////////////////////////////////////////////////////////
// class Rect
////////////////////////////////////////////////////////////
function Rect()
{
   var initialised = false;
   if(arguments.length === 4)
   {
      this.left = Number(arguments[0]); 
      this.top = Number(arguments[1]); 
      this.width = Number(arguments[2]); 
      this.height = Number(arguments[3]); 
      this.right = this.left + this.width;
      this.bottom = this.top + this.height;
      initialised = true;
   }
   else if(arguments.length === 1)
   {
      var arg0 = arguments[0]; 
      if(arg0 instanceof Rect)
      {
         this.left = arg0.left;
         this.top = arg0.top;
         this.width = arg0.width;
         this.height = arg0.height;
         this.right = arg0.right;
         this.bottom = arg0.bottom;
         initialised = true;
      }
   }
   if(!initialised)
   {
      this.left = this.top = this.width = this.height = 0;
      this.right = this.bottom = 0;
   }
}


Rect.prototype.set_top = function (top)
{
   this.top = top;
   this.bottom = this.top + this.height;
};


Rect.prototype.set_bottom = function (bottom)
{
   this.bottom = bottom;
   this.top = this.bottom - this.height;
};


Rect.prototype.set_width = function (width)
{
   this.width = width;
   this.right = this.left + width;
};


Rect.prototype.set_height = function (height)
{
   this.height = height;
   this.bottom = this.top + height;
};


Rect.prototype.set_left = function (left)
{
   this.left = left;
   this.right = left + this.width;
};


Rect.prototype.set_right = function (right)
{
   this.right = right;
   this.left = right - this.width;
};


Rect.prototype.updateRight = function ()
{
   this.right = this.left + this.width;
};


Rect.prototype.updateBottom = function ()
{
   this.bottom = this.top + this.height;
};


Rect.prototype.updateHeight = function ()
{
   this.height = this.bottom - this.top;
   if(this.height < 0)
   {
      this.height = 0;
      this.top = this.bottom;
   }
};


Rect.prototype.updateWidth = function ()
{
   this.width = this.right - this.left;
   if(this.width < 0)
   {
      this.width = 0;
      this.left = this.right;
   }
};


Rect.prototype.adjustForFill = function ()
{
   this.left = Math.floor(this.left);
   this.top = Math.floor(this.top);
   this.right = Math.floor(this.right);
   this.bottom = Math.floor(this.bottom);
   this.width = this.right - this.left;
   this.height = this.bottom - this.top;
};


Rect.prototype.adjustForLines = function ()
{
   this.left = Math.floor(this.left) + 0.5;
   this.top = Math.floor(this.top) + 0.5;
   this.right = Math.floor(this.right) + 0.5;
   this.bottom = Math.floor(this.bottom) + 0.5;
   this.width = this.right - this.left;
   this.height = this.bottom - this.top;
};


Rect.prototype.contains = function (point)
{
   var rtn = false;
   if(point.x >= this.left && point.x <= this.right && point.y >= this.top && point.y <= this.bottom)
   {
      rtn = true;
   }
   return rtn;
};


Rect.prototype.deflate = function (dx, dy)
{ this.inflate(-dx, -dy); };


Rect.prototype.inflate = function (dx, dy)
{
   if(-2 * dx > this.width)
   {
      // don't allow to deflate to eat more width than available
      this.left += this.width / 2;
      this.width = 0;
   }
   else
   {
      this.left -= dx;
      this.width += 2 * dx;
   }
   if(-2 * dy > this.height)
   {
      this.top += this.height / 2;
      this.height = 0;
   }
   else
   {
      this.top -= dy;
      this.height += 2 * dy;
   }
   this.updateRight();
   this.updateBottom();
};


Rect.prototype.intersect = function (other)
{
   var x2 = this.right;
   var y2 = this.bottom;
   if(this.left < other.left)
   {
      this.left = other.left;
   }
   if(this.top < other.top)
   {
      this.y = other.y;
   }
   if(x2 > other.right)
   {
      x2 = other.right;
   }
   if(y2 > other.bottom)
   {
      y2 = other.bottom;
   }
   this.width = x2 - this.left;
   this.height = y2 - this.top;
   if(this.width <= 0 || this.height <= 0)
   {
      this.width = this.height = 0.0;
   }
   this.updateRight();
   this.updateBottom();
   return this;
};


Rect.prototype.is_empty = function ()
{ return this.width <= 0 || this.height <= 0; };


Rect.prototype.offset = function (dx, dy)
{
   this.left += dx;
   this.top += dy;
   this.updateRight();
   this.updateBottom();
};


Rect.prototype.move = function (x, y)
{
   this.left = x;
   this.top = y;
   this.updateRight();
   this.updateBottom();
};


Rect.prototype.union = function (other)
{
   if(this.is_empty())
   {
      this.top = other.top;
      this.left = other.left;
      this.width = other.width;
      this.height = other.height;
      this.right = other.right;
      this.bottom = other.bottom;
   }
   else if(!other.is_empty())
   {
      var x1 = Math.min(this.left, other.left);
      var y1 = Math.min(this.top, other.top);
      var x2 = Math.max(this.right, other.right);
      var y2 = Math.max(this.bottom, other.bottom);

      this.left = x1;
      this.top = y1;
      this.width = x2 - x1;
      this.height = y2 - y1;
      this.right = this.left + this.width;
      this.bottom = this.top + this.height;
   }
   return this;
};


Rect.prototype.rotate = function (degrees)
{
   if(degrees === 90 || degrees === 270)
   {
      var temp = this.width;
      this.width = this.height;
      this.height = temp;
      this.updateRight();
      this.updateBottom();
   }
   else if(degrees !== 0 && degrees !== 180)
   {
      var theta = degreesToRadians(degrees);
      var old_width = this.width;
      var old_height = this.height;
      this.width = Math.abs(old_width * Math.cos(theta)) + Math.abs(old_height * Math.cos(Math.PI / 2 - theta));
      this.height = Math.abs(old_width * Math.sin(theta)) + Math.abs(old_height * Math.sin(Math.PI / 2 - theta));
      this.right = this.left + this.width;
      this.bottom = this.top + this.height;
   }
};


Rect.prototype.center = function (centre_x, centre_y)
{
   this.left = centre_x - this.width / 2;
   this.top = centre_y - this.height / 2;
   this.right = this.left + this.width;
   this.bottom = this.top + this.height;
};


Rect.prototype.center_x = function (center_x)
{
   this.left = center_x - this.width / 2;
   this.right = this.left + this.width;
};


Rect.prototype.center_y = function (center_y)
{
   this.top = center_y - this.height / 2;
   this.bottom = this.top + this.height;
};


Rect.prototype.get_center = function ()
{ return new Point(this.left + this.width / 2, this.top + this.height / 2); };


Rect.prototype.get_top_left = function ()
{ return new Point(this.left, this.top); };


Rect.prototype.get_bottom_left = function ()
{ return new Point(this.left, this.bottom); };


Rect.prototype.get_top_right = function ()
{ return new Point(this.right, this.top); };


Rect.prototype.get_bottom_right = function ()
{ return new Point(this.right, this.bottom); };


Rect.prototype.set_drag_point = function (drag_x, drag_y, org_x, org_y)
{
   if(drag_x < org_x)
   {
      this.left = drag_x;
      this.width = org_x - drag_x;
      this.right = org_x;
   }
   else
   {
      this.right = drag_x;
      this.width = drag_x - org_x;
      this.left = org_x;
   }
   if(drag_y < org_y)
   {
      this.top = drag_y;
      this.height = org_y - drag_y;
      this.bottom = org_y;
   }
   else
   {
      this.bottom = drag_y;
      this.height = drag_y - org_y;
      this.top = org_y;
   }
};


////////////////////////////////////////////////////////////
// line_intersect
//
// Calculates the points at which the line specified by the specified
// points will intersect this rectangle.  If both points lie within the
// rectangle, they will be copied in the return object.  If the line does not
// intersect, a null reference will be returned.
////////////////////////////////////////////////////////////
Rect.prototype.line_intersect = function(p1, p2)
{
   var rtn = { "p1":p1, "p2":p2 };
   if(!this.contains(p1) || !this.contains(p2))
   {
      // we need to calculate all possible intersects with this rectangle
      var intersects = [];
      if(p1.x === p2.x)
      {
         intersects.push(new Point(p1.x, this.top));
         intersects.push(new Point(p1.x, this.bottom));
      }
      else if(p1.y === p2.y)
      {
         intersects.push(new Point(this.left, p1.y));
         intersects.push(new Point(this.right, p1.y));
      }
      else
      {
         // we need to calculate the slope intercept form of the connecting line
         var m = (p1.y - p2.y) / (p1.x - p2.x);
         var b = p1.y - m*p1.x;

         // we will now apply the line equation to calculate the intercept for each side of the rectangle
         var top_intersect = new Point((this.top - b)/m, this.top);
         var bottom_intersect = new Point((this.bottom - b)/m, this.bottom);
         var left_intersect = new Point(this.left, m*this.left + b);
         var right_intersect = new Point(this.right, m*this.right + b);
         
         if(this.contains(top_intersect))
         {
            intersects.push(top_intersect);
         }
         if(this.contains(bottom_intersect))
         {
            intersects.push(bottom_intersect);
         }
         if(this.contains(left_intersect))
         {
            intersects.push(left_intersect);
         }
         if(this.contains(right_intersect))
         {
            intersects.push(right_intersect);
         }
      }

      // we will now choose the coordinates that are closest to the specified points
      if(intersects.length > 0)
      {
         var closest_distance = 1E38;
         var len = intersects.length;
         var candidate;
         var candidate_distance;
         var i;
         
         if(!this.contains(p1))
         {
            for(i = 0; i < len; ++i)
            {
               candidate = intersects[i];
               candidate_distance = Point.distance(candidate, p1);
               if(candidate_distance < closest_distance)
               {
                  rtn.p1 = candidate;
                  closest_distance = candidate_distance;
               }
            }
         }
         if(!this.contains(p2))
         {
            closest_distance = 1E38;
            for(i = 0; i < len; ++i)
            {
               candidate = intersects[i];
               candidate_distance = Point.distance(candidate, p2);
               if(candidate_distance  < closest_distance)
               {
                  rtn.p2 = candidate;
                  closest_distance = candidate_distance;
               }
            }
         }
      }
      else
      {
         rtn = null;
      }
   }
   return rtn;
};


function degreesToRadians(degrees)
{
   return degrees * Math.PI / 180;
}


function radiansToDegrees(radians)
{
   return (radians * 180) / Math.PI;
}


function getUrlVars()
{
   var vars = [], hash;
   var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
   var i;
   for(i = 0; i < hashes.length; i++)
   {
      hash = hashes[i].split('=');
      vars.push(hash[0]);
      vars[hash[0]] = hash[1];
   }
   return vars;
}


function measureText(context, text)
{
   var result = context.measureText(text);
   if(!result.height) 
   {
      result.height = context.measureText("W").width; //assume height("W") == width("W");
   }
   return result;
}


function scaleContextForEllipse(context, rect)
{
   if(rect.width > rect.height)
   {
      context.scale(rect.width / rect.height, 1);
   }
   else
   {
      context.scale(1, rect.height / rect.width);
   }
}


function draw_circle(context, rect)
{
   var radius = Math.min(rect.width / 2, rect.height / 2);
   context.beginPath();
   context.arc(0, 0, radius, 0, 2 * Math.PI, false);
}


function draw_ellipse(context, rect)
{
   context.save();
   context.translate(rect.left + rect.width / 2, rect.top + rect.height / 2);
   scaleContextForEllipse(context, rect);
   draw_circle(context, rect);
   context.restore();
}


function drawDashedLine(context, x_, y_, x2_, y2_, dashArray, previous)
{
   // we will assign our own coordinates based on the parameters.  The
   // dashing algorithm also assumes that x increases from x to x2.
   // In order to accomodate this, we may have to reverse the points.
   var x, y, x2, y2;
   if(x2_ > x_)
   {
      x = Number(x_);
      y = Number(y_);
      x2 = Number(x2_);
      y2 = Number(y2_);
   }
   else
   {
      x = Number(x2_);
      y = Number(y2_);
      x2 = Number(x_);
      y2 = Number(y_);
   }

   // we can now draw the dashes
   var dashCount = dashArray.length;
   context.moveTo(x, y);
   var dx = (x2 - x);
   var dy = (y2 - y);
   var slope = dy / dx;
   var distRemaining = Math.sqrt(dx * dx + dy * dy);
   var dashIndex = 0;
   var draw = true;

   if(slope === Infinity)
   {
      slope = 1E38;
   }
   else if(slope === -Infinity)
   {
      slope = -1E38;
   }

   if(!previous || previous.length === 0) 
   {
      previous = [0, 0];
   }
   dashIndex = previous[1];
   while(distRemaining >= 0.1)
   {
      draw = dashIndex % 2 === 0;
      var dashLength;

      if(previous[0] === 0)
      {
         dashLength = dashArray[dashIndex % dashCount];
         if(!draw)
         {
            dashLength += context.lineWidth;
         }
      }
      else
      {
         dashLength = previous[0];
      }

      if(dashLength > distRemaining)
      {
         previous[0] = dashLength - distRemaining;
         dashLength = distRemaining;
      }
      else
      {
         ++dashIndex;
         previous[0] = 0;
      }
      var xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));
      x += xStep;
      y += slope * xStep;

      context[draw ? 'lineTo' : 'moveTo'](x, y);
      distRemaining -= dashLength;
   }
   previous[1] = dashIndex;
}


//Enum
var Enum = {}; //Global Enum Array
Enum.BUTTON =
{
   LEFT: 0,
   MIDDLE: 1,
   RIGHT: 2
};
Enum.LOGICAL_OPERAND =
   {
      NONE: 0,
      AND: 1,
      OR: 2
   };
Enum.COMPARATOR =
{
   GREATER_THAN: 0,
   LESS_THAN: 1,
   GREATER_THAN_EQUAL: 2,
   LESS_THAN_EQUAL: 3,
   EQUAL: 4,
   NOT_EQUAL: 5
};


//component enumerations
Enum.BORDER_STYLE =
{
   NONE: 0,
   RAISED: 1,
   LOWERED: 2,
   SINGLE: 3
};
Enum.ORIENTATION =
{
   BOTTOM_TO_TOP: 0,
   TOP_TO_BOTTOM: 1,
   LEFT_TO_RIGHT: 2,
   RIGHT_TO_LEFT: 3
};
Enum.ALIGNMENT =
{
   LEFT: 0,
   CENTER: 1,
   RIGHT: 2
};

Enum.LINE_TYPE =
{
   SOLID: 0,
   DASH: 1,
   DOT: 2,
   DASHDOT: 3,
   DASHDOTDOT: 4,
   CLEAR: 5,
   IGNORE: 6,
   SMALLDOTS: 7
};



////////////////////////////////////////////////////////////
// Csi namespace
//
// Provides namespace on which to hang various functions
////////////////////////////////////////////////////////////
function Csi()
{ }


////////////////////////////////////////////////////////////
// string_to_array
//
// Utility function that converts a string into an array of single
// character strings.
////////////////////////////////////////////////////////////
Csi.string_to_array = function (s)
{
   var len = s.length;
   var rtn = [];
   rtn.length = len;
   var i;
   for(i = 0; i < len; ++i)
   {
      rtn[i] = s.charAt(i);
   }
   return rtn;
};


Csi.dash_pattern = [17, 5];
Csi.small_dot_pattern = [2, 2];
Csi.dot_pattern = [3, 3];
Csi.dash_dot_pattern = [8, 5, 2, 5];
Csi.dash_dot_dot_pattern = [8, 2, 2, 2, 2, 2];


Csi.draw_line = function (context, x1_, y1_, x2_, y2_, style)
{
   var x1 = Math.floor(x1_) + 0.5;
   var y1 = Math.floor(y1_) + 0.5;
   var x2 = Math.floor(x2_) + 0.5;
   var y2 = Math.floor(y2_) + 0.5;

   var pattern = null;
   context.beginPath();
   switch(style)
   {
      case Enum.LINE_TYPE.SOLID:
         pattern = null;
         context.moveTo(x1, y1);
         context.lineTo(x2, y2);
         break;

      case Enum.LINE_TYPE.DASH:
         pattern = Csi.dash_pattern;
         break;

      case Enum.LINE_TYPE.DOT:
         pattern = Csi.dot_pattern;
         break;

      case Enum.LINE_TYPE.DASHDOT:
         pattern = Csi.dash_dot_pattern;
         break;

      case Enum.LINE_TYPE.DASHDOTDOT:
         pattern = Csi.dash_dot_dot_pattern;
         break;

      case Enum.LINE_TYPE.CLEAR:
      case Enum.LINE_TYPE.IGNORE:
         pattern = null;
         break;

      //case Enum.LINE_TYPE.SMALLDOTS: 
      default:
         pattern = Csi.small_dot_pattern;
         context.lineWidth = 1;
         break;
   }
   if(pattern) 
   {
      drawDashedLine(context, x1, y1, x2, y2, pattern, [0, 0]);
   }
   context.stroke();
};
/* CsiAlarmsManager.js

   Copyright (C) 2012, 2013 Campbell Scientific, Inc.

   Written by: Jon Trauntvein 
   Date Begun: Wednesday 07 November 2012
   Last Change: Friday 15 March 2013
   Last Commit: $Date: 2013-03-15 08:42:36 -0600 (Fri, 15 Mar 2013) $
   Last Changed by: $Author: jon $

*/


////////////////////////////////////////////////////////////
// class CsiAlarmsManager
//
// Defines a singleton that will manage the alarms for an RTMC project.  Each
// alarm is expected to register itself with the global.  
////////////////////////////////////////////////////////////
var theAlarmsManager = null;
function CsiAlarmsManager(poll_interval_)
{
   this.alarms = { };
   this.alarms_count = 0;
   theAlarmsManager = this;
   if(arguments.length > 0)
   {
      theAlarmsManager = this;
      this.poll_interval = poll_interval_;
      this.loading_data = false;
   }
}


CsiAlarmsManager.prototype.add_alarm = function(alarm, alarm_id)
{
   this.alarms[alarm_id] = alarm;
   ++this.alarms_count;
};


CsiAlarmsManager.prototype.start = function()
{
   if(!this.loading_data && this.alarms_count > 0)
   {
      this.loading_data = true;
      $.ajax({
         url: "?command=ListAlarms&format=json",
         dataType: "json",
         cache: false,
         timeout: 300000,
         success: function(json, status, xhr) {
            theAlarmsManager.web_data(json, status, xhr); },
         error: function(xhr, status, error) {
            theAlarmsManager.web_failed(xhr, status, error); }
      });
   }
};


CsiAlarmsManager.prototype.web_data = function (json, status, xhr)
{
   var interval = theAlarmsManager.poll_interval;
   theAlarmsManager.loading_data = false;
   if(json)
   {
      var alarms_data = json.alarms;
      var len = alarms_data.length;
      var i;
      for(i = 0; i < len; ++i)
      {
         var alarm_data = alarms_data[i];
         var alarm = this.alarms[alarm_data.id];
         if(alarm)
         {
            if("last_error" in alarm_data && alarm_data.last_error !== "")
            {
               if("on_alarms_poll_failed" in alarm)
               {
                  alarm.on_alarms_poll_failed(status, alarm_data.last_error);
               }
            }     
            else if("on_alarm_data" in alarm)
            {
               alarm.on_alarm_data(alarm_data);
               if(alarm_data.state === "on" || alarm_data.state === "acknowledged")
               {
                  interval = 2000;
               }
            }
         }
      }
   }
   oneShotTimer.setTimeout(theAlarmsManager, theAlarmsManager, interval);
};


CsiAlarmsManager.prototype.web_failed = function (xhr, status, error)
{
   var keys;
   var alarm;
   var keys_len;
   var i;
   Object.keys(keys);
   keys_len = keys.length;
   for(i = 0; i < keys_len; ++i)
   {
      alarm = this.alarms[keys[i]];
      if(typeof alarm == "Object" && "on_alarms_poll_failed" in alarm)
      {
         alarm.on_alarms_poll_failed(status, error);
      }
   }
   this.loading_data = false;
   oneShotTimer.setTimeout(theAlarmsManager, theAlarmsManager, 10000);
};


CsiAlarmsManager.prototype.onOneShotTimer = function(context)
{
   if(!theAlarmsManager.loading_data)
   {
      theAlarmsManager.start();
   }
};

/* CsiDataManager.js

   Copyright (C) 2010, 2013 Campbell Scientific, Inc.

   Written by: Kevin Westwood
   Date Begun: Tuesday 03 August 2010
   Last Change: Friday 15 March 2013
   Last Commit: $Date: 2013-03-15 08:42:36 -0600 (Fri, 15 Mar 2013) $
   Last Changed by: $Author: jon $

*/

var dataManager = null; //GLOBAL DECLARATION
var currentWebQuery = null; //GLOBAL DECLARATION

//The CsiDataManager manages all DataRequests
function CsiDataManager(webQueries)
{
   this.webQueries = webQueries; //List of WebQueries
}


//called to begin the process of loading data via the WebQueries
CsiDataManager.prototype.start = function()
{
   var WebQuery = null;
   var len = this.webQueries.length;
   for (var i = 0; i < len; i++)
   {
      WebQuery = this.webQueries[i];
      this.loadData(WebQuery);
   }
};


CsiDataManager.prototype.loadData = function(webQuery)
{
   if(!webQuery.loadingData)
   {
      currentWebQuery = webQuery;
      webQuery.loadingData = true;
      $.ajax({
         url: webQuery.getCommand(),
         dataType: 'json',
         cache: false,
         timeout: 300000,       // five minute timeout
         beforeSend: function(xhr){
            dataManager.beforeSend(xhr);
         },
         success: function(json, status, xhr){
            dataManager.dataReceived(json, status, xhr);
         },
         error: function(xhr, status, error){
            dataManager.xhrError(xhr, status, error);
         }
      });
   }
};


//this method gets called before the xmlHTTPRequest is sent.
//Attach the currentWebQuery to the request.
CsiDataManager.prototype.beforeSend = function(xhr)
{
   xhr.webQuery = currentWebQuery;
};


//Data has been received through the xhr (XMLHttpRequest)
CsiDataManager.prototype.dataReceived = function (json, status, xhr)
{
   if(json)
   {
      xhr.webQuery.loadingData = false;
      if(!xhr.webQuery.newData(json))
      {
         if(!xhr.webQuery.query_satisfied)
            oneShotTimer.setTimeout(dataManager, xhr.webQuery, xhr.webQuery.requestInterval);
      }
      else
      {
         oneShotTimer.setTimeout(dataManager, xhr.webQuery, 100);
      }
   }
   else //request failed
   {
      oneShotTimer.setTimeout(dataManager, xhr.webQuery, 10000); //retry after 10 seconds
   }
};


//The httpRequest failed.
CsiDataManager.prototype.xhrError = function(xhr, status, error)
{
   if(xhr.webQuery)
   {
      xhr.webQuery.loadingData = false;
      oneShotTimer.setTimeout(dataManager, xhr.webQuery, 10000); //retry after 10 seconds
      xhr.webQuery.on_query_fail(error);
   }
};


CsiDataManager.prototype.onOneShotTimer = function(WebQuery)
{
   if(!WebQuery.query_satisfied)
      this.loadData(WebQuery);
};

/* CsiConstant.js

   Copyright (C) 2010, 2011 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Tuesday 27 July 2010
   Last Change: Monday 28 March 2011
   Last Commit: $Date: 2011-08-22 10:25:18 -0600 (Mon, 22 Aug 2011) $
   Last Changed by: $Author: ken $

*/

////////////////////////////////////////////////////////////
// class CsiConstant
//
// Defines a constant value in an expression
////////////////////////////////////////////////////////////
function CsiConstant(value)
{ this.set_val(value, new CsiLgrDate()); }
CsiConstant.prototype = new CsiOperand();


CsiConstant.prototype.evaluate = function(operands, token)
{ operands.push(new CsiOperand(this)); };



/* CsiVariable.js

   Copyright (C) 2010, 2011 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Friday 30 July 2010
   Last Change: Wednesday 30 March 2011
   Last Commit: $Date: 2013-02-26 12:30:08 -0700 (Tue, 26 Feb 2013) $
   Last Changed by: $Author: tmecham $

*/


////////////////////////////////////////////////////////////
// class CsiVariable
////////////////////////////////////////////////////////////
function CsiVariable(simpleUri, is_table)
{
   this.simpleUri = simpleUri;  //simple Uri is typically the FieldName
   this.is_table = is_table;
   this.ownerExpression = null; //owning expression
   this.fieldIndex = -1; //cached index into the json Fields
   this.recnum = 0;
   this.timestamp = 0;
   this.value = null; //current value of the variable
   this.type = "xsd:float";
}


CsiVariable.prototype.set_owner_expression = function(expression)
{ this.ownerExpression = expression; };


CsiVariable.prototype.evaluate = function (stack)
{
   if(this.type === "xsd:dateTime")
   {
      stack.push(new CsiOperand(CsiLgrDate.fromStr(this.value), this.timestamp));
   }
   else if(this.type === "xsd:boolean")
   {
      stack.push(new CsiOperand(this.value ? -1 : 0, this.timestamp));
   }
   else
   {
      stack.push(new CsiOperand(this.value, this.timestamp));
   }
};


CsiVariable.prototype.set_value = function (value, timestamp)
{
   this.timestamp = timestamp;
   if((this.type === "xsd:float" || this.type === "xsd:double") &&
      (typeof (value) === "string" || value instanceof String))
   {
      if(value === "NAN")
      {
         this.value = NaN;
      }
      else if(value === "+INF" || value === "INF")
      {
         this.value = Infinity;
      }
      else if(value === "-INF")
      {
         this.value = -Infinity;
      }
      else
      {
         this.value = value;
      }
   }
   else
   {
      this.value = value;
   }
};
/* CsiAddition.js

   Copyright (C) 2010, 2011 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Tuesday 27 July 2010
   Last Change: Monday 28 March 2011
   Last Commit: $Date: 2011-03-29 11:10:29 -0600 (Tue, 29 Mar 2011) $
   Last Changed by: $Author: jon $

*/


////////////////////////////////////////////////////////////
// class CsiAddition
//
// Defines the addition operator
////////////////////////////////////////////////////////////
function CsiAddition()
{ }
CsiAddition.prototype.evaluate = function(stack, tokens)
{
   var op2 = stack.pop();
   var op1 = stack.pop();
   var rtn = new CsiOperand();
   var timestamp = CsiLgrDate.max(op1.timestamp, op2.timestamp);
   switch(op1.value_type)
   {
   case CsiOperand.value_double:
   case CsiOperand.value_int:
      rtn.set_val(op1.get_val() + op2.get_val(), timestamp);
      break;

   case CsiOperand.value_string:
      rtn.set_val(op1.get_val_str() + op2.get_val_str(), timestamp);
      break;

   case CsiOperand.value_date:
      rtn.set_val(
         new CsiLgrDate(op1.get_val_date().milliSecs + op2.get_val_date().milliSecs),
         timestamp);
      break;
   }
   stack.push(rtn);
};

/* CsiExponentiation.js

   Copyright (C) 2010, 2011 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Tuesday 27 July 2010
   Last Change: Monday 28 March 2011
   Last Commit: $Date: 2011-03-29 11:10:29 -0600 (Tue, 29 Mar 2011) $
   Last Changed by: $Author: jon $

*/

////////////////////////////////////////////////////////////
// class CsiExponentiation
////////////////////////////////////////////////////////////
function CsiExponentiation()
{ }
CsiExponentiation.prototype.evaluate = function(operands, tokens)
{
   var op2 = operands.pop();
   var op1 = operands.pop();
   operands.push(
      new CsiOperand(
         Math.pow(op1.get_val(), op2.get_val()),
         CsiLgrDate.max(op1.timestamp, op2.timestamp)));
};
/* CsiMultiplication.js

   Copyright (C) 2010, 2011 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Tuesday 27 July 2010
   Last Change: Monday 28 March 2011
   Last Commit: $Date: 2011-03-29 11:10:29 -0600 (Tue, 29 Mar 2011) $
   Last Changed by: $Author: jon $

*/

////////////////////////////////////////////////////////////
// class CsiMultiplication
////////////////////////////////////////////////////////////
function CsiMultiplication(){}
CsiMultiplication.prototype.evaluate = function(operands, tokens)
{
   var op2 = operands.pop();
   var op1 = operands.pop();
   var val1 = op2.get_val();
   var val2 = op1.get_val();
   operands.push(new CsiOperand(val1 * val2, CsiLgrDate.max(op1.timestamp, op2.timestamp)));
};

/* CsiTimestamp.js

   Copyright (C) 2010, 2011 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Tuesday 27 July 2010
   Last Change: Monday 28 March 2011
   Last Commit: $Date: 2011-03-29 11:10:29 -0600 (Tue, 29 Mar 2011) $
   Last Changed by: $Author: jon $

*/

////////////////////////////////////////////////////////////
// class CsiTimestamp
////////////////////////////////////////////////////////////
function CsiTimestamp()
{ }
CsiTimestamp.prototype.evaluate = function(operands, tokens)
{
   var op1 = operands.pop();
   operands.push(new CsiOperand(op1.timestamp, op1.timestamp));
};

/* CsiSubtraction.js

   Copyright (C) 2010, 2011 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Tuesday 27 July 2010
   Last Change: Monday 28 March 2011
   Last Commit: $Date: 2011-03-29 11:10:29 -0600 (Tue, 29 Mar 2011) $
   Last Changed by: $Author: jon $

*/


////////////////////////////////////////////////////////////
// class CsiSubtraction
////////////////////////////////////////////////////////////
function CsiSubtraction()
{ }
CsiSubtraction.prototype.evaluate = function(operands, tokens)
{
   var op1 = operands.pop();
   var op2 = operands.pop();
   var val1 = op1.get_val();
   var val2 = op2.get_val();

   operands.push(
      new CsiOperand(
         val2 - val1, CsiLgrDate.max(op1.timestamp, op2.timestamp)));
};
/* CsiToInt.js

   Copyright (C) 2010, 2011 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Tuesday 27 July 2010
   Last Change: Monday 28 March 2011
   Last Commit: $Date: 2011-03-29 11:10:29 -0600 (Tue, 29 Mar 2011) $
   Last Changed by: $Author: jon $

*/

////////////////////////////////////////////////////////////
// class CsiToInt
////////////////////////////////////////////////////////////
function CsiToInt()
{ }
CsiToInt.prototype.evaluate = function(operands, tokens)
{
   var op1 = operands.pop();
   operands.push(new CsiOperand(op1.get_val_int(), op1.timestamp));
};

/* CsiToDate.js

   Copyright (C) 2010, 2011 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Tuesday 27 July 2010
   Last Change: Monday 28 March 2011
   Last Commit: $Date: 2011-03-29 11:10:29 -0600 (Tue, 29 Mar 2011) $
   Last Changed by: $Author: jon $

*/

////////////////////////////////////////////////////////////
// class CsiToDate
////////////////////////////////////////////////////////////
function CsiToDate()
{ }
CsiToDate.prototype.evaluate = function(operands, tokens)
{
   var op1 = operands.pop();
   var v1 = op1.get_val_date();
   operands.push(new CsiOperand(v1, v1)); 
};

/* CsiFormatTime.js

   Copyright (C) 2010, 2011 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Tuesday 27 July 2010
   Last Change: Monday 28 March 2011
   Last Commit: $Date: 2011-03-29 11:10:29 -0600 (Tue, 29 Mar 2011) $
   Last Changed by: $Author: jon $

*/

////////////////////////////////////////////////////////////
// class CsiFormatTime
////////////////////////////////////////////////////////////
function CsiFormatTime()
{ }
CsiFormatTime.prototype.evaluate = function(operands, tokens)
{
   var op2 = operands.pop();
   var op1 = operands.pop();
   var format = op2.get_val_str();
   var stamp = op1.get_val_date();
   operands.push(new CsiOperand(stamp.format(format), op1.timestamp));
};

/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiAlarmState.js $

Copyright (C) 2010 Campbell Scientific, Inc.
Started On: 10/5/2010 7:51:33 AM
Started By: Kevin Westwood

$LastChangedBy: tmecham $
$LastChangedDate: 2013-04-01 10:55:55 -0600 (Mon, 01 Apr 2013) $
$LastChangedRevision: 17778 $
*/

var no_sound_support_shown = false; //GLOBAL DECLARATION

function CsiAlarmState(ownerAlarm, wavFilename, mp3Filename, oggFilename)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   this.ownerAlarm = ownerAlarm;
   this.show_alarm = false;

   this.condition = 0;
   this.condition_value = 0;
   this.condition2 = 0;
   this.condition2_value = 0;
   this.logic_operand = Enum.LOGICAL_OPERAND.NONE;

   this.stop_option = Enum.STOP_CONDITION.NORMAL;
   this.deadband_condition1 = Enum.COMPARATOR.GREATER_THAN;
   this.deadband_condition1_value = 0;
   this.deadband_logic_operand = Enum.LOGICAL_OPERAND.NONE;
   this.deadband_condition2 = Enum.COMPARATOR.GREATER_THAN;
   this.deadband_condition2_value = 0;

   this.audioInterval = 5000;
   this.wavFilename = wavFilename;
   this.mp3Filename = mp3Filename;
   this.oggFilename = oggFilename;
   this.alarmAudio = null;

   this.audio_state = 0;
   this.played_audio_state = 0;

   if(typeof Audio === "undefined")
   {
      this.audio_state = Enum.AUDIO_STATE.ALL_FAILED;
      if(no_sound_support_shown === false)
      {
         var error = 'Your browser does not support alarm sounds.';

         var is_safari = navigator.userAgent.indexOf("Safari") > -1;
         if(is_safari)
         {
            error += '\r\nSafari requires QuickTime to play audio files.';
         }
         alert(error);
         no_sound_support_shown = true;
      }
   }
   else
   {
      var temp_audio = new Audio();
      var can_play_ogg = temp_audio.canPlayType("audio/ogg");
      var can_play_mp3 = temp_audio.canPlayType("audio/mpeg");
      var can_play_wav = temp_audio.canPlayType("audio/x-wav");

      if(oggFilename !== "" && (can_play_ogg.length && can_play_ogg !== "no"))
      {
         this.audio_state = Enum.AUDIO_STATE.TRYING_OGG;
         this.load_sound();
      }
      else if(mp3Filename !== "" && (can_play_mp3.length && can_play_mp3 !== "no"))
      {
         this.audio_state = Enum.AUDIO_STATE.TRYING_MP3;
         this.load_sound();
      }
      else if(this.wavFilename !== "" && (can_play_wav.length && can_play_wav !== "no"))
      {
         this.audio_state = Enum.AUDIO_STATE.TRYING_WAV;
         this.load_sound();
      }
      else
      {
         this.audio_state = Enum.AUDIO_STATE.ALL_FAILED;
      }
   }
}


CsiAlarmState.prototype.load_sound = function ()
{
   try
   {
      var msg = "load_sound() ";

      if(!this.alarmAudio) 
      {
         this.alarmAudio = new Audio();
         this.alarmAudio.loaded = false;
         this.alarmAudio.preload = "auto";
         this.alarmAudio.owner = this;
         this.alarmAudio.onerror = CsiAlarmState.prototype.alarmAudio_onerror;
         this.alarmAudio.addEventListener("loadstart", CsiAlarmState.prototype.alarmAudio_loadstart, false);
         this.alarmAudio.addEventListener("progress", CsiAlarmState.prototype.alarmAudio_progress, false);
         this.alarmAudio.addEventListener("loadedmetadata", CsiAlarmState.prototype.alarmAudio_loadedmetadata, false);
         this.alarmAudio.addEventListener("loadeddata", CsiAlarmState.prototype.alarmAudio_loadeddata, false);
         this.alarmAudio.addEventListener("canplay", CsiAlarmState.prototype.alarmAudio_canplay, false);
         this.alarmAudio.addEventListener("canplaythrough", CsiAlarmState.prototype.alarmAudio_canplaythrough, false);
         this.alarmAudio.addEventListener("suspend", CsiAlarmState.prototype.alarmAudio_suspend, false);
         this.alarmAudio.addEventListener("stalled", CsiAlarmState.prototype.alarmAudio_stalled, false);
         this.alarmAudio.addEventListener("play", CsiAlarmState.prototype.alarmAudio_play, false);
         this.alarmAudio.addEventListener("waiting", CsiAlarmState.prototype.alarmAudio_waiting, false);
         this.alarmAudio.addEventListener("playing", CsiAlarmState.prototype.alarmAudio_playing, false);
         this.alarmAudio.addEventListener("timeupdate", CsiAlarmState.prototype.alarmAudio_timeupdate, false);
         this.alarmAudio.addEventListener("pause", CsiAlarmState.prototype.alarmAudio_pause, false);
         this.alarmAudio.addEventListener("seeking", CsiAlarmState.prototype.alarmAudio_seeking, false);
         this.alarmAudio.addEventListener("seeked", CsiAlarmState.prototype.alarmAudio_seeked, false);
         this.alarmAudio.addEventListener("ended", CsiAlarmState.prototype.alarmAudio_ended, false);
         this.alarmAudio.addEventListener("durationchange", CsiAlarmState.prototype.alarmAudio_durationchange, false);
         this.alarmAudio.addEventListener("volumechange", CsiAlarmState.prototype.alarmAudio_volumechange, false);
         this.alarmAudio.addEventListener("ratechange", CsiAlarmState.prototype.alarmAudio_ratechange, false);
         this.alarmAudio.addEventListener("abort", CsiAlarmState.prototype.alarmAudio_abort, false);
         this.alarmAudio.addEventListener("error", CsiAlarmState.prototype.alarmAudio_error, false);
         this.alarmAudio.addEventListener("emptied", CsiAlarmState.prototype.alarmAudio_emptied, false);
      }

      if(this.audio_state === Enum.AUDIO_STATE.TRYING_OGG)
      {
         this.alarmAudio.loaded = false;
         this.alarmAudio.src = this.oggFilename;
      }
      else if(this.audio_state === Enum.AUDIO_STATE.TRYING_MP3)
      {
         this.alarmAudio.loaded = false;
         this.alarmAudio.src = this.mp3Filename;
      }
      else if(this.audio_state === Enum.AUDIO_STATE.TRYING_WAV)
      {
         this.alarmAudio.loaded = false;
         this.alarmAudio.src = this.wavFilename;
      }
      msg += this.alarmAudio.src;

      csi_log(msg);
   }
   catch(exception)
   {
      this.audio_state = Enum.AUDIO_STATE.ALL_FAILED;
      if(no_sound_support_shown === false)
      {
         alert('Your browser does not seem to support alarm sounds.\r\nError = ' + exception.message);
         no_sound_support_shown = true;
      }
      this.alarmAudio = null;
   }
   this.ownerAlarm.check_all_ready();
};


CsiAlarmState.prototype.stopAudio = function ()
{
   var msg = "stopAudio " + this.toString();
   csi_log(msg);

   try
   {
      if(this.alarmAudio) 
      {
         this.alarmAudio.pause();
      }
   }
   catch(exception)
   {
      msg = "stopAudio() - " + exception;
      csi_log(msg);
   }

   //clear the timer to play the audio
   oneShotTimer.clearTimeout(this, "Audio");
};


CsiAlarmState.prototype.playAudio = function ()
{
   if(this.audio_state === Enum.AUDIO_STATE.ALL_FAILED)
   {
      return;
   }

   var msg = "playAudio " + this.toString();
   csi_log(msg);

   try
   {
      //Try to load the sound
      this.load_sound();

      if(this.alarmAudio)
      {
         csi_log(msg);
         this.alarmAudio.play();
         this.played_audio_state = this.audio_state;
         if(this.audioInterval > 0)
         {
            oneShotTimer.setTimeout(this, "Audio", this.audioInterval);
         }
      }
   }
   catch(exception)
   {
      msg = "playAudio() - " + exception;
      csi_log(msg);
   }
};


CsiAlarmState.prototype.alarmAudio_onerror = function ()
{
   var msg = "alarmAudio_onerror " + this.toString();
   csi_log(msg);

   this.owner.alarmAudio = null;

   //Check to see if we have ever played a file
   if(this.owner.played_audio_state !== Enum.AUDIO_STATE.ALL_FAILED)
   {
      //Since we know we have already played a file type, just set the state
      //and try to load the file again without reporting it to the user
      this.owner.audio_state = this.owner.played_audio_state;

      //Try to play the alarm again if it is still needed
      oneShotTimer.setTimeout(this.owner, "Audio", 1000);
   }
};
CsiAlarmState.prototype.alarmAudio_loadstart = function ()
{
   var msg = "alarmAudio_loadstart " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_progress = function ()
{
   var msg = "alarmAudio_progress " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_loadedmetadata = function ()
{
   var msg = "alarmAudio_loadedmetadata " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_loadeddata = function ()
{
   var msg = "alarmAudio_loadeddata " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_canplay = function ()
{
   var msg = "alarmAudio_canplay " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_canplaythrough = function ()
{
   this.loaded = true;
   var msg = "alarmAudio_canplaythrough " + this.toString();
   csi_log(msg);
   this.owner.ownerAlarm.check_all_ready();
};
CsiAlarmState.prototype.alarmAudio_suspend = function ()
{
   var msg = "alarmAudio_suspend " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_stalled = function ()
{
   var msg = "alarmAudio_stalled " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_play = function ()
{
   var msg = "alarmAudio_play " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_waiting = function ()
{
   var msg = "alarmAudio_waiting " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_playing = function ()
{
   var msg = "alarmAudio_playing " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_timeupdate = function ()
{
   var msg = "alarmAudio_timeupdate " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_pause = function ()
{
   var msg = "alarmAudio_pause " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_seeking = function ()
{
   var msg = "alarmAudio_seeking " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_seeked = function ()
{
   var msg = "alarmAudio_seeked " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_ended = function ()
{
   var msg = "alarmAudio_ended " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_durationchange = function ()
{
   var msg = "alarmAudio_durationchange " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_volumechange = function ()
{
   var msg = "alarmAudio_volumechange " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_ratechange = function ()
{
   var msg = "alarmAudio_ratechange " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_abort = function ()
{
   var msg = "alarmAudio_abort " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_error = function ()
{
   var msg = "alarmAudio_error " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_emptied = function ()
{
   var msg = "alarmAudio_emptied " + this.toString();
   csi_log(msg);
};
CsiAlarmState.prototype.alarmAudio_PlayEnded = function ()
{
   var msg = "alarmAudio_PlayEnded " + this.toString();
   csi_log(msg);
};


CsiAlarmState.prototype.onOneShotTimer = function (tag)
{
   if(tag === "Audio")
   {
      if(this.show_alarm)
      {
         this.playAudio();
      }
      else
      {
         this.stopAudio();
      }
   }
};


CsiAlarmState.prototype.evaluate_condition = function (value, timestamp)
{
   var should_show_alarm = false;
   var condition1_met = false;
   var condition2_met = false;
   var deadband_condition1_met = false;
   var deadband_condition2_met = false;

   if(!this.show_alarm) //If not in an alarm state just check the condition to see if we should be
   {
      condition1_met = this.evaluate(value, this.condition, this.condition_value);
      if(this.logic_operand === Enum.LOGICAL_OPERAND.NONE)
      {
         should_show_alarm = condition1_met;
      }
      else
      {
         condition2_met = this.evaluate(value, this.condition2, this.condition2_value);
         if(this.logic_operand === Enum.LOGICAL_OPERAND.AND)
         {
            should_show_alarm = condition1_met && condition2_met;
         }
         else //LOGICAL_OPERAND.OR
         {
            should_show_alarm = condition1_met || condition2_met;
         }
      }
   }
   else //Check to see if we need to come out of the alarm state
   {
      if(this.stop_option === Enum.STOP_CONDITION.NORMAL ||
         ((this.stop_option === Enum.STOP_CONDITION.LATCHED) && this.ownerAlarm.alarm_acknowledged))
      {
         condition1_met = this.evaluate(value, this.condition, this.condition_value);
         if(this.logic_operand === Enum.LOGICAL_OPERAND.NONE)
         {
            should_show_alarm = condition1_met;
         }
         else
         {
            condition2_met = this.evaluate(value, this.condition2, this.condition2_value);
            if(this.logic_operand === Enum.LOGICAL_OPERAND.AND)
            {
               should_show_alarm = condition1_met && condition2_met;
            }
            else //LOGICAL_OPERAND.OR
            {
               should_show_alarm = condition1_met || condition2_met;
            }
         }
      }
      else if(this.stop_option === Enum.STOP_CONDITION.DEADBAND) //Check the deadband state to see if we can leave alarm
      {
         deadband_condition1_met = this.evaluate(value, this.deadband_condition1, this.deadband_condition1_value);
         if(this.deadband_logic_operand === Enum.LOGICAL_OPERAND.NONE)
         {
            should_show_alarm = !deadband_condition1_met;
         }
         else
         {
            deadband_condition2_met = this.evaluate(value, this.deadband_condition2, this.deadband_condition2_value);
            if(this.deadband_logic_operand === Enum.LOGICAL_OPERAND.AND)
            {
               should_show_alarm = !(deadband_condition1_met && deadband_condition2_met);
            }
            else //LOGICAL_OPERAND.OR
            {
               should_show_alarm = !(deadband_condition1_met || deadband_condition2_met);
            }
         }
      }
      else //(stop_option == STOP_CONDITION.LATCHED) && !this.ownerAlarm.alarm_acknowledged
      {
         should_show_alarm = true;
      }
   }

   if(should_show_alarm)
   {
      if(!this.show_alarm)
      {
         //entering alarm state
         this.show_alarm = true;
         this.playAudio();
      }
   }
   else
   {
      if(this.show_alarm)
      {
         this.show_alarm = false;
         this.stopAudio();
      }
   }
};


CsiAlarmState.prototype.evaluate = function (the_value, the_condition, the_condition_value)
{
   var the_condition_met = false;
   switch(the_condition)
   {
      case Enum.COMPARATOR.GREATER_THAN:
         if(the_value > the_condition_value)
         {
            the_condition_met = true;
         }
         break;
      case Enum.COMPARATOR.GREATER_THAN_EQUAL:
         if(the_value >= the_condition_value)
         {
            the_condition_met = true;
         }
         break;
      case Enum.COMPARATOR.LESS_THAN:
         if(the_value < the_condition_value)
         {
            the_condition_met = true;
         }
         break;
      case Enum.COMPARATOR.LESS_THAN_EQUAL:
         if(the_value <= the_condition_value)
         {
            the_condition_met = true;
         }
         break;
      case Enum.COMPARATOR.NOT_EQUAL:
         if(the_value !== the_condition_value)
         {
            the_condition_met = true;
         }
         break;
      //case Enum.COMPARATOR.EQUAL: 
      default:
         if(the_value === the_condition_value)
         {
            the_condition_met = true;
         }
         break;
   }
   return the_condition_met;
};


CsiAlarmState.prototype.check_still_loading = function ()
{
   var rtn = false;
   if(mobileBrowser)
   {
      rtn = false; //iOS never preloads
   }
   else
   {
      if(this.alarmAudio)
      {
         if(!this.alarmAudio.loaded)
         {
            rtn = true; //Still Loading
         }
      }
   }
   return rtn;
};


Enum.STOP_CONDITION =
{
   NORMAL: 0,
   LATCHED: 1,
   DEADBAND: 2
};


Enum.AUDIO_STATE =
{
   TRYING_OGG: 0,
   TRYING_MP3: 1,
   TRYING_WAV: 2,
   ALL_FAILED: 3
};/* CsiComponent.js

Copyright (C) 2010, 2013 Campbell Scientific, Inc.

Written by: Kevin Westwood
Date Begun: Thursday 12 August 2010
Last Change: Wednesday 02 January 2013
Last Commit: $Date: 2013-01-07 15:13:24 -0700 (Mon, 07 Jan 2013) $
Last Changed by: $Author: tmecham $

*/

////////////////////////////////////////////////////////////
// class CsiComponent
//
// Defines a base class for all visual components
////////////////////////////////////////////////////////////
function CsiComponent(left, top, width, height)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   this.ready = true;      //Is the control ready to draw?  Could be waiting for image or other resource
   this.animating = false; //Is the control animating? (if so, draw will continually be called)
   this.needs_mouse_events = false;
   this.valid = false;
   this.drawOnlyIfInvalid = false;
   this.active = false;  //is the control active (visible on the current tab)
   this.showSelectCursor = false; //should the cursor change to a select cursor when dragging
   this.bad_data = true;
   this.nan_data = false;

   //position
   this.left = left;
   this.top = top;
   this.width = width;
   this.height = height;
   this.right = left + width;
   this.bottom = top + height;

   this.border_style = Enum.BORDER_STYLE.NONE;

   this.expression = null;
}

//must be implemented by each component
//draw(context) //called to draw component

//implement to support animation
//updateAnimation(), component should update animation values (only called if animating = true)

//implement to support data
//newValue(value, timestamp, expectMore)
//newNanValue(value, timestamp, expectMore)
//newRecord(jsonRecord, timestamp, expectMore)

//Optional for mouse events - just implement in needed class and set
//needs_mouse_events = true;
//
//CsiComponent.prototype.OnLButtonDblClk = function(mouseX, mouseY)
//CsiComponent.prototype.OnLButtonDown = function(mouseX, mouseY)
//CsiComponent.prototype.OnLButtonUp = function(mouseX, mouseY)
//CsiComponent.prototype.OnRButtonDown = function(mouseX, mouseY)
//CsiComponent.prototype.OnRButtonUp = function(mouseX, mouseY)

//Implement to handle when parent tab is initially shown
//CsiComponent.prototype.deactivate = function()
//CsiComponent.prototype.activate = function()

//When invalidate is called notify the CsiGraphicsManager
CsiComponent.prototype.invalidate = function ()
{
   this.valid = false;
   graphicsManager.componentInvalidate(this);
};


CsiComponent.prototype.refresh = function ()
{
   this.valid = false;
   graphicsManager.componentRefresh(this);
};


CsiComponent.prototype.getAnimating = function ()
{
   return this.animating;
};


function drawBorder(context, rect, borderStyle)
{
   if(borderStyle !== Enum.BORDER_STYLE.NONE)
   {
      var outsideRect = new Rect(rect.left, rect.top, rect.width-1.0, rect.height-1.0);
      outsideRect.adjustForLines();
      var insideRect = new Rect(outsideRect.left + 1.0, outsideRect.top + 1.0, outsideRect.width - 2.1, outsideRect.height - 2.1);
      insideRect.adjustForLines();

      if(borderStyle === Enum.BORDER_STYLE.RAISED)
      {
         //outside border
         context.beginPath();
         context.strokeStyle = "lightgray";
         context.moveTo(outsideRect.left, outsideRect.bottom);
         context.lineTo(outsideRect.left, outsideRect.top); //left line
         context.lineTo(outsideRect.right, outsideRect.top); //top line
         context.stroke();

         context.beginPath();
         context.strokeStyle = "darkgray";
         context.moveTo(outsideRect.right, outsideRect.top);
         context.lineTo(outsideRect.right, outsideRect.bottom); //right line
         context.lineTo(outsideRect.left, outsideRect.bottom); //bottom line
         context.stroke();

         //inside border
         context.beginPath();
         context.strokeStyle = "white";
         context.moveTo(insideRect.left, insideRect.bottom);
         context.lineTo(insideRect.left, insideRect.top); //left line
         context.lineTo(insideRect.right, insideRect.top); //top line
         context.stroke();

         context.beginPath();
         context.strokeStyle = "gray";
         context.moveTo(insideRect.right, insideRect.top);
         context.lineTo(insideRect.right, insideRect.bottom); //right line
         context.lineTo(insideRect.left, insideRect.bottom); //bottom line
         context.stroke();
      }
      else if(borderStyle === Enum.BORDER_STYLE.LOWERED)
      {
         //outside border
         context.beginPath();
         context.strokeStyle = "gray";
         context.moveTo(outsideRect.left, outsideRect.bottom);
         context.lineTo(outsideRect.left, outsideRect.top); //left line
         context.lineTo(outsideRect.right, outsideRect.top); //top line
         context.stroke();

         context.beginPath();
         context.strokeStyle = "white";
         context.moveTo(outsideRect.right, outsideRect.top);
         context.lineTo(outsideRect.right, outsideRect.bottom); //right line
         context.lineTo(outsideRect.left, outsideRect.bottom); //bottom line
         context.stroke();

         //inside border
         context.beginPath();
         context.strokeStyle = "darkgray";
         context.moveTo(insideRect.left, insideRect.bottom);
         context.lineTo(insideRect.left, insideRect.top); //left line
         context.lineTo(insideRect.right, insideRect.top); //top line
         context.stroke();

         context.beginPath();
         context.strokeStyle = "lightgray";
         context.moveTo(insideRect.right, insideRect.top);
         context.lineTo(insideRect.right, insideRect.bottom); //right line
         context.lineTo(insideRect.left, insideRect.bottom); //bottom line
         context.stroke();
      }
      else //Single
      {
         context.beginPath();
         context.strokeStyle = "black";
         context.moveTo(outsideRect.left, outsideRect.bottom);
         context.lineTo(outsideRect.left, outsideRect.top); //left line
         context.lineTo(outsideRect.right, outsideRect.top); //top line
         context.lineTo(outsideRect.right, outsideRect.bottom); //right line
         context.lineTo(outsideRect.left, outsideRect.bottom); //bottom line
         context.stroke();
      }
   }
}


CsiComponent.prototype.drawBorder = function (context, rect)
{
   drawBorder(context, rect, this.border_style);
};


CsiComponent.prototype.deactivate = function ()
{
   this.active = false;
};


CsiComponent.prototype.activate = function ()
{
   this.active = true;
};


function drawImageError(rect, context)
{
   context.save();
   context.translate(rect.left, rect.top); //move to location

   context.fillStyle = "white";
   context.fillRect(0, 0, rect.width, rect.height);

   //Draw image error
   context.lineWidth = 7;
   context.lineCap = "round";
   context.strokeStyle = "red";

   context.beginPath();
   context.moveTo(0, 0);
   context.lineTo(rect.width, rect.height);
   context.moveTo(rect.width, 0);
   context.lineTo(0, rect.height);
   context.stroke();

   context.restore();
}


CsiComponent.prototype.drawImageError = function (context)
{
   drawImageError(new Rect(this.left, this.top, this.width, this.height), context);
};


function drawSingleLineBorder(context, rect, borderStyle)
{
   if(borderStyle !== Enum.BORDER_STYLE.NONE)
   {
      if(borderStyle === Enum.BORDER_STYLE.RAISED)
      {
         context.beginPath();
         context.strokeStyle = "white";
         context.moveTo(rect.left, rect.bottom);
         context.lineTo(rect.left, rect.top); //left line
         context.lineTo(rect.right, rect.top); //top line
         context.stroke();

         context.beginPath();
         context.strokeStyle = "black";
         context.moveTo(rect.right, rect.top);
         context.lineTo(rect.right, rect.bottom); //right line
         context.lineTo(rect.left + 1, rect.bottom); //bottom line
         context.stroke();
      }
      else if(borderStyle === Enum.BORDER_STYLE.LOWERED)
      {
         context.beginPath();
         context.strokeStyle = "black";
         context.moveTo(rect.left, rect.bottom);
         context.lineTo(rect.left, rect.top); //left line
         context.lineTo(rect.right, rect.top); //top line
         context.stroke();

         context.beginPath();
         context.strokeStyle = "white";
         context.moveTo(rect.right, rect.top);
         context.lineTo(rect.right, rect.bottom); //right line
         context.lineTo(rect.left, rect.bottom); //bottom line
         context.stroke();
      }
      else //Single
      {
         context.beginPath();
         context.strokeStyle = "black";
         context.moveTo(rect.left, rect.bottom);
         context.lineTo(rect.left, rect.top); //left line
         context.lineTo(rect.right, rect.top); //top line
         context.lineTo(rect.right, rect.bottom); //right line
         context.lineTo(rect.left, rect.bottom); //bottom line
         context.stroke();
      }
   }
}


function drawStyledBorder(context, rect, styleOrColor, width)
{
   var tempRect = new Rect(rect.left, rect.top, rect.width, rect.height);
   tempRect.adjustForLines();

   context.save();
   context.beginPath();
   context.strokeStyle = styleOrColor;
   context.lineWidth = width;
   context.moveTo(tempRect.left, tempRect.bottom);
   context.lineTo(tempRect.left, tempRect.top); //left line
   context.lineTo(tempRect.right, tempRect.top); //top line
   context.lineTo(tempRect.right, tempRect.bottom); //right line
   context.lineTo(tempRect.left, tempRect.bottom); //bottom line
   context.stroke();
   context.restore();
}


function drawRoundedRect(context, rect, cornerRadius)
{
   context.beginPath();
   //Top Left Corner
   context.moveTo(rect.left + cornerRadius, rect.top);
   context.quadraticCurveTo(rect.left, rect.top, rect.left, rect.top + cornerRadius);
   //Left Line
   context.lineTo(rect.left, rect.bottom - cornerRadius);
   //Bottom Left Line
   context.quadraticCurveTo(rect.left, rect.bottom, rect.left + cornerRadius, rect.bottom);
   //Bottom Line
   context.lineTo(rect.right - cornerRadius, rect.bottom);
   //Bottom Right Line
   context.quadraticCurveTo(rect.right, rect.bottom, rect.right, rect.bottom - cornerRadius);
   //Right Line
   context.lineTo(rect.right, rect.top + cornerRadius);
   //Top Right Corner
   context.quadraticCurveTo(rect.right, rect.top, rect.right - cornerRadius, rect.top);
   //Top line
   context.closePath();
}


function fillPolygon(context, points)
{
   context.beginPath();
   if(points.length > 0)
   {
      context.moveTo(points[0].x, points[0].y);
      var i = 0;
      for(i = 0; i < points.length; i++)
      {
         context.lineTo(points[i].x, points[i].y);
      }

      context.fill();
   }
}


function drawDot(context, x, y, size, borderStyle)
{
   //fill with color
   context.beginPath();
   context.arc(x, y, size, 0, 2 * Math.PI, false);
   context.fill();

   //draw border
   switch(borderStyle)
   {
      case Enum.BORDER_STYLE.RAISED:
         context.beginPath();
         context.arc(x, y, size, Math.PI * 3 / 4, Math.PI * 7 / 4, false);
         context.strokeStyle = "white";
         context.stroke();

         context.beginPath();
         context.arc(x, y, size, Math.PI * 3 / 4, Math.PI * 7 / 4, true);
         context.strokeStyle = "black";
         context.stroke();
         break;

      case Enum.BORDER_STYLE.LOWERED:
         context.beginPath();
         context.arc(x, y, size, Math.PI * 3 / 4, Math.PI * 7 / 4, false);
         context.strokeStyle = "black";
         context.stroke();

         context.beginPath();
         context.arc(x, y, size, Math.PI * 3 / 4, Math.PI * 7 / 4, true);
         context.strokeStyle = "white";
         context.stroke();
         break;
   }
}

function clipRect(context, x, y, width, height)
{
   context.beginPath();
   context.moveTo(x, y);
   context.lineTo(x + width + 0.5, y);
   context.lineTo(x + width + 0.5, y + height + 0.5);
   context.lineTo(x, y + height + 0.5);
   context.clip();
}


CsiComponent.prototype.getBadData = function ()
{
   return this.bad_data;
};


CsiComponent.prototype.getNanData = function ()
{
   return this.nan_data;
};


CsiComponent.prototype.reset_data = function ()
{
   this.bad_data = true;
   this.nan_data = false;
};


CsiComponent.prototype.on_touch_start = function (event)
{ return false; };


CsiComponent.prototype.on_touch_move = function (event)
{ return false; };


CsiComponent.prototype.on_touch_end = function (event)
{ return false; };


function drawNanData(comp, context)
{
   context.save();
   context.translate(comp.left + comp.width - 16, comp.top);

   context.fillStyle = "red";
   context.fillRect(0, 0, 16, 16);

   context.fillStyle = "yellow";
   context.beginPath();
   context.arc(8, 8, 7, 0, 2 * Math.PI, false);
   context.fill();

   context.strokeStyle = "black";
   context.lineJoin = "round";
   context.lineCap = "round";
   context.lineWidth = 3;
   context.beginPath();
   context.moveTo(5, 11);
   context.lineTo(5, 5);
   context.lineTo(11, 11);
   context.lineTo(11, 5);
   context.stroke();

   context.restore();
}


function drawBadData(comp, context)
{
   context.save();
   context.translate(comp.left + comp.width - 16, comp.top);

   context.fillStyle = "red";
   context.fillRect(0, 0, 16, 16);

   context.fillStyle = "yellow";
   context.beginPath();
   context.arc(8, 8, 7, 0, 2 * Math.PI, false);
   context.fill();

   context.fillStyle = "black";
   context.beginPath();
   context.arc(8, 13, 1.5, 0, 2 * Math.PI, false);
   context.fill();

   var tempRect = new Rect(6, 1, 3, 9);
   context.scale(1, tempRect.height / tempRect.width);
   var radius = tempRect.width / 2;
   context.beginPath();
   context.arc(8, 2, radius, 0, 2 * Math.PI, false);
   context.fill();

   context.restore();
}
/* CsiAlarm.js

   Copyright (C) 2012, 2013 Campbell Scientific, Inc.

   Written by: Kevin Westwood 
   Date Begun: 5 October 2010
   Last Change: Wednesday 12 June 2013
   Last Commit: $Date: 2013-06-12 09:51:47 -0600 (Wed, 12 Jun 2013) $
   Last Changed by: $Author: jon $

*/


function CsiAlarm(left, top, width, height, expression)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   CsiComponent.call(this, left, top, width, height);

   this.lastValue = 0.0;
   this.lastTimestamp = null;
   if(expression)
   {
      this.expression = expression;
      this.expression.ownerComponent = this;
   }
   else
   {
      this.expression = null;
   }

   this.alarmStates = [];
   this.ready = true;
   this.alarm_acknowledged = false;
   this.needs_mouse_events = true;
   this.firstData = true;
   this.identifier = null;
   this.cur_alarm_state = null;
   this.alarm_text_description = null;
   this.alarm_data = null;
   
   //make sure we are all ready (images, sounds, etc loaded by all alarm type classes)
   oneShotTimer.setTimeout(this, "CheckAllReady", 500);
}
CsiAlarm.prototype = new CsiComponent();


CsiAlarm.prototype.set_identifier = function(identifier)
{
   if(theAlarmsManager)
   {
      this.identifier = identifier;
      theAlarmsManager.add_alarm(this, this.identifier);
   }
};


CsiAlarm.prototype.hasActiveAlarm = function ()
{
   var rtn = false;
   var len = this.alarmStates.length;
   var i;
   for(i = 0; i < len && !rtn; i++)
   {
      if(this.alarmStates[i].show_alarm && !this.alarm_acknowledged)
      {
         rtn = true;
      }
   }
   return rtn;
};


CsiAlarm.prototype.newStringValue = function (value, timestamp, expect_more)
{
   this.newValue(value, timestamp, expect_more);
};


CsiAlarm.prototype.newValue = function (value, timestamp, expect_more)
{
   this.lastValue = value;
   this.lastTimestamp = timestamp;
   this.evaluateValue(value, timestamp);
};


CsiAlarm.prototype.on_alarm_data = function (alarm_data)
{
   this.alarm_data = alarm_data;

   if(this.bad_data)
   {
      this.bad_data = false;
      this.invalidate();
   }
   var prev_acked = this.alarm_acknowledged;
   this.alarm_acknowledged = (alarm_data.state === "acknowledged");

   var i;
   var len = this.alarmStates.length;
   var alarmState;
   var prev_state = null;

   //Find the current alarming state
   for(i = 0; i < len && !prev_state; i++)
   {
      alarmState = this.alarmStates[i];
      if(alarmState.show_alarm)
      {
         prev_state = alarmState;
      }
   }

   //Check to see if there is a new state
   this.cur_alarm_state = null;
   for(i = 0; i < len; i++)
   {
      //Iterate through all of the states and then just set the rest to no alarm state
      alarmState = this.alarmStates[i];

      if(alarm_data.triggered_condition_name === alarmState.stateName)
      {
         this.cur_alarm_state = alarmState;
         alarmState.show_alarm = true;
      }
      else
      {
         alarmState.show_alarm = false;
      }
   }

   if(prev_state !== this.cur_alarm_state || prev_acked !== this.alarm_acknowledged)
   {
      if(this.cur_alarm_state)
      {
         if(this.alarm_acknowledged)
         {
            this.cur_alarm_state.stopAudio();
         }
         else
         {
            this.cur_alarm_state.playAudio();
         }
      }
      graphicsManager.update_alarm_tabs();
      this.invalidate();
   }
};


CsiAlarm.prototype.on_alarms_poll_failed = function(status, error)
{
   this.bad_data = true;
   this.invalidate();
};


CsiAlarm.prototype.evaluateValue = function (value, timestamp)
{
   var i;
   var len = this.alarmStates.length;
   var alarmState;
   var prev_state = null;
   
   //Find the current alarming state
   for(i = 0; i < len && !prev_state; i++) 
   {
      alarmState = this.alarmStates[i];
      if(alarmState.show_alarm)
      {
         prev_state = alarmState;
      }
   }

   //Check to see if there is a new state
   var cur_state = null;
   for(i = 0; i < len; i++)
   {
      //Iterate through all of the states and then just set the rest to no alarm state
      alarmState = this.alarmStates[i];

      if(cur_state) 
      {
         alarmState.show_alarm = false;
      }
      else
      {
         alarmState.evaluate_condition(value, timestamp);
         if(alarmState.show_alarm)
         {
            cur_state = alarmState;
         }
         else
         {
            alarmState.show_alarm = false;
         }
      }
   }

   if(prev_state !== cur_state)
   {
      graphicsManager.update_alarm_tabs();
      this.alarm_acknowledged = false;
      this.invalidate();
   }
};


CsiAlarm.prototype.newRecord = function (jsonRecord, timestamp, expect_more)
{
   this.lastValue = 0.0;
   this.lastTimestamp = timestamp;

   var requiresInvalidate = this.firstData;
   this.firstData = false;

   var i;
   var len = this.alarmStates.length;
   for(i = 0; i < len; i++)
   {
      var alarmState = this.alarmStates[i];
      var prevShowAlarm = alarmState.show_alarm;

      alarmState.evaluate_condition(this.lastValue, timestamp);

      if(alarmState.show_alarm !== prevShowAlarm)
      {
         requiresInvalidate = true;
      }
   }

   if(requiresInvalidate)
   {
      this.alarm_acknowledged = false;
      this.invalidate();
   }
};


CsiAlarm.prototype.getShowAlarm = function ()
{
   var i;
   var len = this.alarmStates.length;
   for(i = 0; i < len; i++)
   {
      if(this.alarmStates[i].show_alarm)
      {
         return true;
      }
   }

   return false;
};


CsiAlarm.prototype.deactivate = function ()
{
   CsiComponent.prototype.deactivate.call(this);
   csiMouseEvents.hideMenu();
};


//left mouse button click.  We want to show the acknowledge alarm menu item with a left button click because
//the handheld touch screens do not distinguish between a left and right button click
CsiAlarm.prototype.OnLButtonClick = function (mouseX, mouseY)
{
   this.OnRButtonClick(mouseX, mouseY);
};


//right mouse button click.  Show popup "Acknowledge Alarm" menu item
CsiAlarm.prototype.OnRButtonClick = function (mouseX, mouseY)
{
   if((this.getShowAlarm()) && (!this.alarm_acknowledged))
   {
      var component = this;
      csiMouseEvents.hideMenu();

      $("<div id='context'></div>").html("<ul class='context_menu'><li id='acknowledge' class='menu_item'>Acknowledge Alarm</li></ul>")
      .css({
         position: 'absolute',
         zIndex: '9999',
         left: mouseX + $('#rtmc_canvas').offset().left,
         top: mouseY + $('#rtmc_canvas').offset().top
      }).show().appendTo('body');

      $('ul.context_menu').css({
         listStyle: 'none',
         padding: '1px',
         margin: '0px',
         backgroundColor: '#fff',
         border: '1px solid #999',
         width: 'auto'
      });

      $('li.menu_item').mouseover(function ()
      {
         $(this).css({
            backgroundColor: '#E9EFF8'
         });
      }).mouseout(function ()
      {
         $(this).css({
            backgroundColor: 'transparent'
         });
      }).css({
         width: 'auto',
         margin: '0px',
         color: '#000',
         display: 'block',
         cursor: 'default',
         padding: '3px',
         border: '1px solid #fff',
         backgroundColor: 'transparent'
      }).click(function ()
      {
         csiMouseEvents.hideMenu();
      });

      $('#acknowledge').click(function ()
      {
         component.do_acknowledge();
      });
   }
};


CsiAlarm.prototype.do_acknowledge = function()
{
   var comments = null;
   if(this.alarm_text_description)
   {
      // format the HTML for the dialog
      var comment_html = "<form id='alarm_comment_form'>" + this.alarm_text_description +
            " <input type='text' id='alarm_comment_input' /></form>";

      // we need to make sure that the dialog div has not already been created
      var dialog_div;
      var component = this;
      $("#dialog_div").remove();
      dialog_div = $("<div id='dialog_div'></div>").html(comment_html);
      dialog_div.dialog({
         autoOpen: false,
         title: "Acknowledge Alarm",
         open: function() {
            $(document).keypress(function (e) {
               if((e.which && e.which === 13) || e.keyCode && e.keyCode === 13)
               {
                  if(dialog_div.dialog('isOpen'))
                  {
                     e.preventDefault();
                     $('.ui-dialog-buttonset > button:first').trigger('click');
                  }
               }
            });
         },
         close: function() { $(document).unbind('keypress'); },
         buttons: {
            "Ok": function() {
               var input = $("#alarm_comment_input")[0];
               $(this).dialog("close");
               if(input)
               {
                  component.acknowledgeAlarm(input.value);
               }
            },
            "Cancel": function() {
               $(this).dialog("close");
            }
         },
         closeOnEscape: true,
         draggable: true,
         modal: true,
         resizable: false,
         position: [0, 0]
      });
      dialog_div.dialog("open");
   }
   else
   {
      this.acknowledgeAlarm(comments);
   }
};


CsiAlarm.prototype.acknowledgeAlarm = function (comments)
{
   if(this.identifier)
   {
      var component = this;
      var ack_url = "?command=CheckAlarm&format=json&name=" + encodeURIComponent(component.identifier) + "&acknowledge=true";
      if(comments && comments.length)
      {
         ack_url = ack_url + "&acknowledge_comments=" + encodeURIComponent(comments);
      }
      $.ajax({
         url: ack_url,
         dataType: "json",
         cache: false,
         success: function (json, status, xhr)
         {
            var alarmState;
            component.alarm_acknowledged = (json.state === "acknowledged");
            component.cur_alarm_state = null;
            var len = component.alarmStates.length;
            var i;
            for(i = 0; i < len; i++)
            {
               //Iterate through all of the states and then just set the rest to no alarm state
               alarmState = component.alarmStates[i];

               if(json.triggered_condition_name === alarmState.stateName)
               {
                  component.cur_alarm_state = alarmState;
                  alarmState.show_alarm = true;
               }
               else
               {
                  alarmState.show_alarm = false;
               }
            }
         },
         error: function (xhr, status, error)
         {
            component.alarm_acknowledged = false;
         }
      });
      this.stopAudio();
      this.invalidate();
      graphicsManager.update_alarm_tabs();
   }
   else
   {
      this.alarm_acknowledged = true;
      this.stopAudio();
      this.evaluateValue(this.lastValue, this.lastTimestamp); //we must evaluate the last value if it was latched
      graphicsManager.update_alarm_tabs();
      this.invalidate();
   }
};


CsiAlarm.prototype.stopAudio = function ()
{
   //stop all audio alarms
   var i;
   var len = this.alarmStates.length;
   for(i = 0; i < len; i++)
   {
      if(this.alarmStates[i].show_alarm)
      {
         this.alarmStates[i].stopAudio();
      }
   }
};


CsiAlarm.prototype.drawAlarmAcknowledged = function (context)
{
   if(this.alarm_acknowledged)
   {
      context.lineWidth = 2.5;
      context.lineCap = "round";
      context.strokeStyle = "black";
      context.beginPath();

      //The context should already be translated to the top-left corner of the alarm
      context.moveTo(0, 0);
      context.lineTo(this.width, this.height);
      context.moveTo(this.width, 0);
      context.lineTo(0, this.height);
      context.stroke();
   }
};


CsiAlarm.prototype.reset_data = function ()
{
   this.bad_data = true;
   var len = this.alarmStates.length;
   var i;
   for(i = 0; i < len; i++)
   {
      this.alarmStates[i].show_alarm = false;
      this.alarmStates[i].stopAudio();
   }
};


CsiAlarm.prototype.check_all_ready = function ()
{
   if(this.ready) //Don't do anything if we are already ready
   {
      return;
   }

   var still_loading = false;
   var len = this.alarmStates.length;
   var i;
   for(i = 0; i < len && !still_loading; i++)
   {
      if(this.alarmStates[i].check_still_loading())
      {
         still_loading = true;
      }
   }

   if(!still_loading)
   {
      this.ready = true;
   }

   if(this.ready)
   {
      this.invalidate();
   }
};


CsiAlarm.prototype.onOneShotTimer = function (tag)
{
   if(tag === "CheckAllReady")
   {
      if(!this.ready)
      {
         //Check to see if we are ready yet
         this.check_all_ready();

         if(!this.ready)
         {
            //Still not ready, so check again in a second
            oneShotTimer.setTimeout(this, "CheckAllReady", 500);
         }
      }
   }
};
/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiImageAlarmState.js $

Copyright (C) 2010 Campbell Scientific, Inc.
Started On: 10/5/2010 7:51:33 AM
Started By: Kevin Westwood

$LastChangedBy: jon $
$LastChangedDate: 2013-04-29 13:33:06 -0600 (Mon, 29 Apr 2013) $
$LastChangedRevision: 18017 $
*/

/* global CsiAlarmState: true */


function CsiImageAlarmState(ownerAlarm, imageFilename, wavFilename, mp3Filename, oggFilename)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   CsiAlarmState.call(this, ownerAlarm, wavFilename, mp3Filename, oggFilename);

   this.alarmImg = new Image();
   this.alarmImg.owner = this;
   this.alarmImg.loaded = false;
   this.alarmImg.onload = CsiImageAlarmState.prototype.alarmImg_onload;
   this.alarmImg.onerror = CsiImageAlarmState.prototype.alarmImg_onerror;
   this.alarmImg.onabort = CsiImageAlarmState.prototype.alarmImg_onerror;
   this.alarmImg.src = imageFilename;
}
CsiImageAlarmState.prototype = new CsiAlarmState();


CsiImageAlarmState.prototype.alarmImg_onload = function ()
{
   this.loaded = true;
   this.owner.ownerAlarm.check_all_ready();
};


CsiImageAlarmState.prototype.alarmImg_onerror = function ()
{
   var owner = this.owner;
   owner.alarmImg = null;
   owner.ownerAlarm.check_all_ready();
};


CsiImageAlarmState.prototype.check_still_loading = function ()
{
   var still_loading = CsiAlarmState.prototype.check_still_loading.call(this);

   if(!still_loading && this.alarmImg)
   {
      if(!this.alarmImg.loaded)
      {
         still_loading = true;
      }
   }

   return still_loading;
};
/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiNoDataAlarmState.js $

Copyright (C) 2010 Campbell Scientific, Inc.
Started On: 10/5/2010 7:51:33 AM
Started By: Kevin Westwood

$LastChangedBy: jon $
$LastChangedDate: 2013-04-29 13:33:06 -0600 (Mon, 29 Apr 2013) $
$LastChangedRevision: 18017 $
*/

/* global CsiImageAlarmState */



function CsiNoDataAlarmState(ownerAlarm, imageFilename, wavFilename, mp3Filename, oggFilename, alarmTime)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   CsiImageAlarmState.call(this, ownerAlarm, imageFilename, wavFilename, mp3Filename, oggFilename);

   this.AlarmTime = alarmTime;
   this.lastValue = null;
   this.lastTimestamp = null;
   this.lastTimeReceivedData = null;
   this.inAlarmCondition = false;

   oneShotTimer.setTimeout(this, "NoData", this.AlarmTime);
}
CsiNoDataAlarmState.prototype = new CsiImageAlarmState();


CsiNoDataAlarmState.prototype.evaluate_condition = function (value, timestamp)
{
   var prev_show_alarm = this.show_alarm;

   //received new data?
   if(timestamp !== this.lastTimestamp)
   {
      //new data
      this.lastTimestamp = timestamp;
      this.lastTimeReceivedData = new Date().getTime();

      if(!this.show_alarm)
      {
         //clear previous timeout.  It will be restarted.
         oneShotTimer.clearTimeout(this, "NoData");
      }
      else //check if no longer alarm condition
      {
         if(this.stop_option === Enum.STOP_CONDITION.NORMAL)
         {
            this.show_alarm = false;
         }
         else //Enum.STOP_CONDITION.LATCHED
         {
            this.show_alarm = !this.ownerAlarm.alarm_acknowledged;
         }
      }

      //start timer.  If timer fires before data comes in, alarmCondition = true
      if(!this.show_alarm)
      {
         oneShotTimer.setTimeout(this, "NoData", this.AlarmTime);
      }
   }
   else
   {
      //not new data.  Exceeded the Alarm Time? Turn off Alarm?
      if(new Date().getTime() - this.lastTimeReceivedData >= this.AlarmTime)
      {
         this.show_alarm = true; //exceeded alarm time
      }
      else if((this.stop_option === Enum.STOP_CONDITION.LATCHED) && (this.show_alarm) && (this.ownerAlarm.alarm_acknowledged))
      {
         this.show_alarm = false; //alarm has been acknowledged and received data within AlarmTime
      }
   }

   //alarm state changing?
   if(prev_show_alarm !== this.show_alarm)
   {
      if(this.show_alarm)
      {
         //entering alarm state
         this.ownerAlarm.invalidate();
         this.playAudio();
      }
      else
      {
         this.stopAudio();
         this.ownerAlarm.alarm_acknowledged = false;
      }
   }
};


CsiNoDataAlarmState.prototype.onOneShotTimer = function (tag)
{
   if(tag === "NoData")
   {
      this.evaluate_condition(this.lastValue, this.lastTimestamp);
   }
   else
   {
      CsiImageAlarmState.prototype.onOneShotTimer.call(this, tag);
   }
};
/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiRateChangeAlarmState.js $

Copyright (C) 2010 Campbell Scientific, Inc.
Started On: 10/5/2010 7:51:33 AM
Started By: Kevin Westwood

$LastChangedBy: jon $
$LastChangedDate: 2013-04-29 13:33:06 -0600 (Mon, 29 Apr 2013) $
$LastChangedRevision: 18017 $
*/

/* global CsiImageAlarmState: true */
/* global CsiAlarmState: true */


function CsiRateChangeAlarmState(ownerAlarm, imageFilename, wavFilename, mp3Filename, oggFilename)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   CsiImageAlarmState.call(this, ownerAlarm, imageFilename, wavFilename, mp3Filename, oggFilename);

   //second to most recent value
   this.lastValue2 = null;
   this.lastTimestamp2 = null;

   //most recent last value
   this.lastValue1 = null;
   this.lastTimestamp1 = null;
}
CsiRateChangeAlarmState.prototype = new CsiImageAlarmState();


CsiRateChangeAlarmState.prototype.evaluate_condition = function (value, timestamp)
{
   var rateOfChange;

   if(timestamp !== this.lastTimestamp1)
   {
      //move most recent value to second to most recent value
      this.lastValue2 = this.lastValue1;
      this.lastTimestamp2 = this.lastTimestamp1;

      //save new value
      this.lastValue1 = value;
      this.lastTimestamp1 = timestamp;
   }

   //check rate of change only after receiving two values
   if(this.lastValue1 && this.lastValue2) 
   {
      rateOfChange = this.lastValue1 - this.lastValue2;
      CsiAlarmState.prototype.evaluate_condition.call(this, rateOfChange);
   }
};
/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiImageAlarm.js $

Copyright (C) 2010 Campbell Scientific, Inc.
Started On: 10/5/2010 7:51:33 AM
Started By: Kevin Westwood

$LastChangedBy: jon $
$LastChangedDate: 2013-04-29 13:33:06 -0600 (Mon, 29 Apr 2013) $
$LastChangedRevision: 18017 $
*/

/* global CsiAlarm: true */
/* global CsiImageAlarmState: true */
/* global CsiRateChangeAlarmState: true */
/* global CsiNoDataAlarmState: true */


function CsiImageAlarm(left, top, width, height, off_image_filename, expression)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   CsiAlarm.call(this, left, top, width, height, expression);

   this.ready = false;

   if(off_image_filename !== "")
   {
      this.off_img = new Image();
      this.off_img.loaded = false;
      this.off_img.owner = this;
      this.off_img.onload = CsiImageAlarm.prototype.off_img_onload;
      this.off_img.onerror = CsiImageAlarm.prototype.off_img_onerror;
      this.off_img.onabort = CsiImageAlarm.prototype.off_img_onerror;
      this.off_img.src = off_image_filename;
   }
   else
   {
      this.off_img = null;
   }
   this.check_all_ready();
}
CsiImageAlarm.prototype = new CsiAlarm();


CsiImageAlarm.prototype.createImageAlarmState = function (imageFilename, wavFilename, mp3Filename, oggFilename)
{
   var state = new CsiImageAlarmState(this, imageFilename, wavFilename, mp3Filename, oggFilename);
   this.alarmStates.push(state);
   return state;
};


CsiImageAlarm.prototype.createRateChangeAlarmState = function (imageFilename, wavFilename, mp3Filename, oggFilename)
{
   var state = new CsiRateChangeAlarmState(this, imageFilename, wavFilename, mp3Filename, oggFilename);
   this.alarmStates.push(state);
   return state;
};


CsiImageAlarm.prototype.createNoDataAlarmState = function (imageFilename, wavFilename, mp3Filename, oggFilename, alarmTime)
{
   var state = new CsiNoDataAlarmState(this, imageFilename, wavFilename, mp3Filename, oggFilename, alarmTime);
   this.alarmStates.push(state);
   return state;
};


CsiImageAlarm.prototype.off_img_onload = function ()
{
   this.loaded = true;
   this.owner.check_all_ready();
};


CsiImageAlarm.prototype.off_img_onerror = function ()
{
   var owner = this.owner; //Make local copy since we are nulling ourselves
   owner.off_img = null;
   owner.check_all_ready();
};


CsiImageAlarm.prototype.draw = function (context)
{
   var imageToDraw = this.off_img;
   var len = this.alarmStates.length;
   var alarmState;
   var i;
   for(i = 0; i < len; i++)
   {
      alarmState = this.alarmStates[i];
      if(alarmState.show_alarm)
      {
         imageToDraw = alarmState.alarmImg;
         break;
      }
   }

   context.translate(this.left, this.top); //move to location

   if(imageToDraw) 
   {
      context.drawImage(imageToDraw, 0, 0, this.width, this.height);
   }
   else
   {
      this.drawImageError(context);
   }

   this.drawAlarmAcknowledged(context);
};


CsiImageAlarm.prototype.check_all_ready = function ()
{
   if(this.ready) //Don't do anything if we are already ready
   {
      return;
   }

   var still_loading = false;

   if(this.off_img && this.off_img.loaded === false)
   {
      still_loading = true;
   }

   if(!still_loading) //Only check each state if we need to
   {
      var len = this.alarmStates.length;
      var i;
      for(i = 0; i < len && !still_loading; i++)
      {
         if(this.alarmStates[i].check_still_loading())
         {
            still_loading = true;
         }
      }
   }

   if(!still_loading)
   {
      this.ready = true;
   }

   if(this.ready)
   {
      this.invalidate();
   }
};
/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiGraphSeries.js $

Copyright (C) 2011 Campbell Scientific, 2011 Campbell Scientific, Inc.
Started On: 4/15/2011 12:52:20 PM
Started By: Tyler Mecham

$LastChangedBy: jon $
$LastChangedDate: 2013-04-29 13:33:06 -0600 (Mon, 29 Apr 2013) $
$LastChangedRevision: 18017 $
*/


/* global CsiGraphAxis: true */

function CsiGraphSeries(expression, owner, axis)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   this.ownerGraph = owner;

   if(expression)
   {
      this.expression = expression;
      this.expression.ownerComponent = this;
   }
   else
   {
      this.expression = null;
   }

   this.label = "Series";
   this.series_type = Enum.SERIES_TYPE.LINE;
   this.axis = axis;
   this.line_type = 0;
   this.line_color = "#FF0000";
   this.line_width = 1;
   this.use_stairs = false;
   this.point_type = 1;
   this.point_color = "#FF0000";
   this.point_size = 2;
   this.timeOffset = 0;
   this.marks_enabled = false;
   this.marks_show_on_click = true;
   this.marks_transparent = 0;
   this.marks_color = "#FFFFFF";
   this.marks_rounded = false;
   this.marks_draw_every = 1;
   this.marks_format = 2;
   this.bar_border_line_type = 0;
   this.bar_border_color = "#000000";
   this.bar_border_width = 1;
   this.bar_type = 0;
   this.bar_color = "#FFFF00";
   this.bar_width_percentage = 0.70;
   this.bar_position = 0;
   this.data = [];
   this.mark_cache = [];
   this.current_mark = null;
   this.mark_font = "10pt Arial";

   this.bad_data = true;
   this.nan_data = false;

   this.domain_axis = this.ownerGraph.bottomAxis;
   this.domain_axis.add_series(this);
   if(this.axis === 0)
   {
      this.range_axis = this.ownerGraph.leftAxis;
   }
   else
   {
      this.range_axis = this.ownerGraph.rightAxis;
   }
   this.range_axis.add_series(this);
}


CsiGraphSeries.prototype.invalidate = function ()
{
   this.ownerGraph.valid = false;
   graphicsManager.componentInvalidate(this.ownerGraph);
};


CsiGraphSeries.prototype.newNanValue = function (value, timestamp, expect_more)
{
   //NAN points are assumed to be NOPLOT
   this.newValue(Number.NaN, timestamp, expect_more);
};


function binarySearch(values, target, start, end)
{
   if(start > end) 
   { return -1; } //does not exist

   var middle = Math.floor((start + end) / 2);
   var value = values[middle][0].milliSecs;

   if(value > target)
   {
      return binarySearch(values, target, start, middle - 1); 
   }
   else if(value < target)
   {
      return binarySearch(values, target, middle + 1, end); 
   }
   
   return middle; //found!
}


function findIndex(values, target)
{
   return binarySearch(values, target.milliSecs, 0, values.length - 1);
}


CsiGraphSeries.prototype.newValue = function (value, timestamp, expect_more)
{
   //We need to make sure values are in the right order.
   //Splice into the array if the timestamp is older than the last value in our data array.
   //Use a binary search to find the index at which to slice into the array.
   this.bad_data = false;
   var newTS = new CsiLgrDate(timestamp.milliSecs + this.timeOffset);
   var value_pair = this.data[this.data.length - 1];
   if(value_pair && newTS.milliSecs < value_pair[0].milliSecs) //Timestamps are out of order
   {
      //Find where to insert the new record using a binary search
      var index = findIndex(this.data, newTS);
      if(index >= 0)
      {
         this.data.splice(index, 0, [newTS, value]); //Insert the new value at the proper index
      }
   }
   else //Timestamps in order, so just put it on the end
   {
      this.data.push([newTS, value]);
   }

   if(!expect_more)
   {
      //update the newesttimestamp
      var newest_value_pair = this.data[this.data.length - 1];
      if(newest_value_pair && newest_value_pair[0].milliSecs > this.ownerGraph.newestTimeStamp)
      {
         this.ownerGraph.newestTimeStamp = newest_value_pair[0].milliSecs;
      }

      if(!this.ownerGraph.show_restore_btn) //Don't remove data if we are zoomed or panned
      {
         //find old data
         var i = 0;
         var len = this.data.length;
         var cutoff = this.ownerGraph.newestTimeStamp - this.ownerGraph.graphWidth;
         while((i < len) && (this.data[i][0].milliSecs < cutoff))
         {
            i++;
         }

         //remove old data
         if(i > 0)
         {
            this.data.splice(0, i);
         }
      }

      if(!this.ownerGraph.zooming)
      {
         if(this.current_mark)
         {
            if(CsiLgrDate.local().milliSecs - this.current_mark.start_time.milliSecs > 2000)
            {
               this.current_mark.start_time = null;
               this.current_mark = null;
            }
         }
         this.ownerGraph.positionsInvalid = true;
         this.ownerGraph.invalidate();
      }
   }
};


CsiGraphSeries.prototype.get_bounds = function (axis_type)
{
   // we will extract the max and min values from the data
   var rtn = { max: -Number.MAX_VALUE, min: Number.MAX_VALUE };
   var cnt = this.data.length;
   var i;
   for(i = 0; i < cnt; ++i)
   {
      var datum = this.data[i];
      if(axis_type === CsiGraphAxis.axis_bottom)
      {
         rtn.min = Math.min(rtn.min, datum[0]);
         rtn.max = Math.max(rtn.max, datum[0]);
      }
      else
      {
         if(isFinite(datum[1])) //Ignore NOPLOT since they are NANs
         {
            rtn.min = Math.min(rtn.min, datum[1]);
            rtn.max = Math.max(rtn.max, datum[1]);
         }
      }
   }

   if(this.series_type === Enum.SERIES_TYPE.BAR && axis_type !== CsiGraphAxis.axis_bottom)
   {
      //Bars must be oriented around 0, so make sure zero is always present
      if(rtn.max < 0)
      {
         //If the max is below zero, make the max zero
         rtn.max = 0;
      }

      if(rtn.min > 0)
      {
         //If the min is greater than zero, put the min back down to zero
         rtn.min = 0;
      }
   }

   return rtn;
};


CsiGraphSeries.prototype.reset_data = function ()
{
   this.bad_data = true;
   this.ownerGraph.displayWidth = Number.MAX_VALUE;
   this.ownerGraph.graphWidth = Number.MAX_VALUE;
   this.ownerGraph.bottomAxis.auto_max = true;
   this.ownerGraph.bottomAxis.auto_min = true;
   this.ownerGraph.newestTimeStamp = 0;
   this.ownerGraph.positionsInvalid = true;
   this.data = [];
   this.current_mark = null;
   if(this.ownerGraph.show_restore_btn)
   {
      this.ownerGraph.RestoreState();
   }
   this.invalidate();
};


CsiGraphSeries.prototype.draw = function (context)
{
   this.mark_cache = []; //clear out the old mark positions

   switch(this.series_type)
   {
      case Enum.SERIES_TYPE.BAR:
         this.draw_bars(context);
         break;
      case Enum.SERIES_TYPE.POINT:
         if(this.point_type !== Enum.POINT_TYPE.NOTHING)
         {
            this.draw_points(context);
         }
         break;
      //case Enum.SERIES_TYPE.LINE: 
      default:
         if(this.line_type !== Enum.LINE_TYPE.CLEAR)
         {
            this.draw_lines(context);
         }
         if(this.point_type !== Enum.POINT_TYPE.NOTHING)
         {
            this.draw_points(context);
         }
         break;
   }
};


CsiGraphSeries.prototype.draw_lines = function (context)
{
   var prev_x = 0;
   var prev_y = 0;
   context.strokeStyle = this.line_color;
   context.lineWidth = this.line_width;

   context.lineJoin = "round";
   context.lineCap = "round";
   var len = this.data.length;
   context.beginPath();
   var i;
   for(i = 0; i < len; i++)
   {
      var ts = this.data[i][0].milliSecs;
      var val = this.data[i][1];

      var x = this.domain_axis.value_to_pos(ts);
      var y = this.range_axis.value_to_pos(val);

      if(x >= this.ownerGraph.plotRect.left && x <= this.ownerGraph.plotRect.right &&
         y >= this.ownerGraph.plotRect.top && y <= this.ownerGraph.plotRect.bottom)
      {
         if(this.marks_enabled)
         {
            if(this.marks_show_on_click || (i % this.marks_draw_every === 0))
            {
               //Store off the point so it can be drawn if needed
               this.mark_cache.push(new CsiGraphMark(ts, val, x, y));
            }
         }
      }

      if(i === 0) //Move to the first position
      {
         context.moveTo(x, y);
      }
      else //Draw the line
      {
         //Only draw visible lines
         if(x >= this.ownerGraph.plotRect.left || prev_x >= this.ownerGraph.plotRect.left /*Catch the duplicate data line if there is one*/)
         {
            if(x <= this.ownerGraph.plotRect.right || prev_x <= this.ownerGraph.plotRect.right) //Draw the last line outside plotRect
            {
               if(this.use_stairs)
               {
                  Csi.draw_line(context, prev_x, prev_y, x, prev_y, this.line_type);
                  Csi.draw_line(context, x, prev_y, x, y, this.line_type);
               }
               else
               {
                  var plot_pos = this.ownerGraph.plotRect.line_intersect(
                     new Point(prev_x, prev_y), new Point(x, y));
                  if(plot_pos)
                  {
                     Csi.draw_line(context, plot_pos.p1.x, plot_pos.p1.y, plot_pos.p2.x, plot_pos.p2.y, this.line_type);
                  }
               }
            }
         }
         else
         {
            //If the line starts outside the plotRect, just move to that point and don't draw the line
            //That way the first drawn line will be from the last point off the plotRect.
            context.moveTo(x, y);
         }
      }

      prev_x = x;
      prev_y = y;
   }
   context.stroke();
};


CsiGraphSeries.prototype.draw_points = function (context)
{
   context.lineWidth = 2;
   context.fillStyle = this.point_color;
   context.strokeStyle = this.point_color;
   var len = this.data.length;
   var i;
   for(i = 0; i < len; i++)
   {
      var x_val = this.data[i][0];
      if(x_val instanceof CsiLgrDate)
      {
         x_val = x_val.milliSecs;
      }

      var y_val = this.data[i][1];

      var x = this.domain_axis.value_to_pos(x_val);
      var y = this.range_axis.value_to_pos(y_val);

      if(x >= this.ownerGraph.plotRect.left && x <= this.ownerGraph.plotRect.right &&
         y >= this.ownerGraph.plotRect.top && y <= this.ownerGraph.plotRect.bottom)
      {
         if(this.marks_enabled && this.line_type === Enum.LINE_TYPE.CLEAR) //Only add them if the line didn't
         {
            if(this.marks_show_on_click || (i % this.marks_draw_every === 0))
            {
               //Store off the point so it can be drawn if needed
               this.mark_cache.push(new CsiGraphMark(x_val, y_val, x, y));
            }
         }
      }

      //Only draw visible points
      if(x >= this.ownerGraph.plotRect.left && x <= this.ownerGraph.plotRect.right)
      {
         this.draw_point_type(context, this.point_type, x, y, this.point_size, false);
      }
   }
};


CsiGraphSeries.prototype.draw_bars = function (context)
{
   var ts = 0;
   var val = 0;
   var x = 0;
   var y = 0;
   var i = 0;
   var len = this.data.length;
   if(len > 0)
   {
      var zero_pos = this.range_axis.value_to_pos(0);
      context.fillStyle = this.bar_color;
      context.strokeStyle = this.bar_border_color;
      context.lineWidth = this.bar_border_width;

      //Calculate all of the point positions so we can figure out the max bar width allowed
      //The max bar width is the smallest distance between points.
      var points = [];
      var complete_bar_width = this.ownerGraph.plotRect.width; //Space available for all the bars
      var prev_x = 0;
      for(i = 0; i < len; i++)
      {
         ts = this.data[i][0].milliSecs;
         val = this.data[i][1];

         x = this.domain_axis.value_to_pos(ts);
         y = this.range_axis.value_to_pos(val);
         points[i] = [x, y];

         if(i > 0 && x > prev_x)
         {
            //See if the space between the 2 points is the smallest available.
            var space_between = x - prev_x;
            if(space_between < complete_bar_width)
            {
               complete_bar_width = space_between;
            }
         }

         prev_x = x;
      }

      //The bar width % affects the complete bar area
      complete_bar_width *= this.bar_width_percentage;

      //If we have more than one bar, we have divide up the complete space
      var bar_step_size = complete_bar_width / this.ownerGraph.bar_count;
      var bar_offset = bar_step_size * this.bar_position; //Offset into the side by side bars
      var single_bar_width = bar_step_size; //Max space for each bar

      //Draw each bar
      len = points.length;
      for(i = 0; i < len; i++)
      {
         y = points[i][1];
         x = points[i][0] + bar_offset;

         var bar_rect = new Rect(x - complete_bar_width / 2, y, single_bar_width, zero_pos - y);

         if(x >= this.ownerGraph.plotRect.left && x <= this.ownerGraph.plotRect.right &&
            y >= this.ownerGraph.plotRect.top && y <= this.ownerGraph.plotRect.bottom)
         {
            if(this.marks_enabled)
            {
               if(this.marks_show_on_click || (i % this.marks_draw_every === 0))
               {
                  ts = this.data[i][0].milliSecs;
                  val = this.data[i][1];
                  //Store off the point so it can be drawn if needed
                  this.mark_cache.push(new CsiGraphMark(ts, val, bar_rect.get_center().x, y));
               }
            }
         }


         //Only draw visible points
         if(bar_rect.right >= this.ownerGraph.plotRect.left && bar_rect.left <= this.ownerGraph.plotRect.right)
         {
            this.draw_bar_type(context, this.bar_type, bar_rect);
         }
      }
   }
};


CsiGraphSeries.prototype.draw_marks = function (context)
{
   if(this.current_mark)
   {
      this.draw_mark(context, this.current_mark.x_val, this.current_mark.y_val, this.current_mark.pt_x, this.current_mark.pt_y);
   }
   else if(this.marks_enabled && !this.marks_show_on_click)
   {
      var len = this.mark_cache.length;
      var i;
      for(i = 0; i < len; i++)
      {
         this.draw_mark(context, this.mark_cache[i].x_val, this.mark_cache[i].y_val, this.mark_cache[i].pt_x, this.mark_cache[i].pt_y);
      }
   }
};


CsiGraphSeries.prototype.draw_mark = function (context, x_value, y_value, x, y)
{
   context.save();
   context.font = this.mark_font;
   var mark_text = "";
   if(this.marks_format === Enum.MARKS_TYPE.TIMESTAMP)
   {
      mark_text += (new CsiLgrDate(x_value).format(this.ownerGraph.bottomAxis.time_format));
   }
   else if(this.marks_format === Enum.MARKS_TYPE.BOTH)
   {
      mark_text = String(sprintf("%.5g", y_value) + " @ " + (new CsiLgrDate(x_value).format(this.ownerGraph.bottomAxis.time_format)));
   }
   else //Enum.MARKS_TYPE.VALUE)
   {
      mark_text += sprintf("%.5g", y_value);
   }

   var size = measureText(context, mark_text);
   var tip_x = x;
   var tip_y = y - size.height;
   if(tip_x + size.width / 2 + 10> this.ownerGraph.width)
   {
      tip_x -= size.width / 2;
   }
   else if((tip_x - (size.width / 2 + 5)) < 0)
   {
      tip_x += size.width / 2;
   }
   if(tip_y - 25 - size.height < 0)
   {
      tip_y = 25 + size.height;
   }
   var mark_rect = new Rect(
      tip_x - 5 - size.width / 2,
      tip_y - 5 - size.height - 20,
      size.width + 10,
      size.height + 10);

   context.lineWidth = 1;
   context.strokeStyle = "#FFFFFF";
   context.beginPath();
   context.moveTo(tip_x, tip_y - 5 - size.height);
   context.lineTo(x, y);
   context.stroke();

   context.strokeStyle = "#000000";
   context.fillStyle = this.marks_color;
   if(!this.marks_transparent)
   {
      if(this.marks_rounded)
      {
         drawRoundedRect(context, mark_rect, 4);
         context.fill();
         context.stroke();
      }
      else
      {
         context.fillRect(mark_rect.left, mark_rect.top, mark_rect.width, mark_rect.height);
         context.strokeRect(mark_rect.left, mark_rect.top, mark_rect.width, mark_rect.height);
      }
   }

   context.textAlign = "center";
   context.textBaseline = "middle";
   context.fillStyle = "#000000";

   context.fillText(mark_text, mark_rect.left + mark_rect.width/2, mark_rect.top + mark_rect.height/2);
   context.restore();
};


CsiGraphSeries.prototype.drawLegendGraphic = function (context, rect)
{
   if(this.series_type === Enum.SERIES_TYPE.BAR)
   {
      context.fillStyle = this.bar_color;
      context.fillRect(rect.left, rect.top, rect.width, rect.height);
      context.strokeStyle = this.bar_border_color;
      context.lineWidth = this.bar_border_width;
      if(this.bar_border_line_type !== Enum.LINE_TYPE.CLEAR)
      {
         context.strokeRect(rect.left, rect.top, rect.width, rect.height);
      }
   }
   else if(this.series_type === Enum.SERIES_TYPE.POINT)
   {
      var pt_y = Math.floor(rect.top + rect.height / 2) + 0.5;
      context.lineWidth = 2;
      context.fillStyle = this.point_color;
      context.strokeStyle = this.point_color;
      this.draw_point_type(context, this.point_type, rect.left + rect.width / 2, pt_y, this.point_size, false);
   }
   else //Enum.SERIES_TYPE.LINE
   {
      var y = Math.floor(rect.top + rect.height / 2) + 0.5;
      if(this.line_type !== Enum.LINE_TYPE.CLEAR && this.line_type !== Enum.LINE_TYPE.IGNORE)
      {
         var previous = [0, 0];
         context.strokeStyle = this.line_color;
         context.lineWidth = this.line_width;
         context.beginPath();
         switch(this.line_type)
         {
            case Enum.LINE_TYPE.SOLID:
               context.moveTo(rect.left, y);
               context.lineTo(rect.right, y);
               break;
            case Enum.LINE_TYPE.DASH:
               drawDashedLine(context, rect.left, y, rect.right, y, Csi.dash_pattern, previous);
               break;
            case Enum.LINE_TYPE.DOT:
               drawDashedLine(context, rect.left, y, rect.right, y, Csi.dot_pattern, previous);
               break;
            case Enum.LINE_TYPE.DASHDOT:
               drawDashedLine(context, rect.left, y, rect.right, y, Csi.dash_dot_pattern, previous);
               break;
            case Enum.LINE_TYPE.DASHDOTDOT:
               drawDashedLine(context, rect.left, y, rect.right, y, Csi.dash_dot_dot_pattern, previous);
               break;
            //case Enum.LINE_TYPE.SMALLDOTS:  
            default:
               context.lineWidth = 1;
               drawDashedLine(context, rect.left, y, rect.right, y, Csi.small_dot_pattern, previous);
               break;
         }
         context.stroke();
      }

      context.lineWidth = 2;
      context.fillStyle = this.point_color;
      context.strokeStyle = this.point_color;
      this.draw_point_type(context, this.point_type, rect.left + rect.width / 2, y, this.point_size, false);
   }
};


CsiGraphSeries.prototype.draw_point_type = function (context, point_type, x, y, radius, do_stroke)
{
   context.beginPath();
   var size;
   var height;
   switch(point_type)
   {
      case Enum.POINT_TYPE.RECTANGLE:
         // pi * r^2 = (2s)^2  =>  s = r * sqrt(pi)/2
         size = radius * Math.sqrt(Math.PI) / 2;
         context.rect(x - size, y - size, size + size, size + size);
         context.fill();
         if(do_stroke)
         {
            context.stroke();
         }
         break;
      case Enum.POINT_TYPE.CIRCLE:
         context.arc(x, y, this.point_size, 0, Math.PI * 2, false);
         context.fill();
         if(do_stroke)
         {
            context.stroke();
         }
         break;
      case Enum.POINT_TYPE.DIAMOND:
         // pi * r^2 = 2s^2  =>  s = r * sqrt(pi/2)
         size = radius * Math.sqrt(Math.PI / 2);
         context.moveTo(x - size, y);
         context.lineTo(x, y - size);
         context.lineTo(x + size, y);
         context.lineTo(x, y + size);
         context.lineTo(x - size, y);
         context.fill();
         if(do_stroke)
         {
            context.stroke();
         }
         break;
      case Enum.POINT_TYPE.TRIANGLE:
         // pi * r^2 = 1/2 * s^2 * sin (pi / 3)  =>  s = r * sqrt(2 * pi / sin(pi / 3))
         size = radius * Math.sqrt(2 * Math.PI / Math.sin(Math.PI / 3));
         height = size * Math.sin(Math.PI / 3);
         context.moveTo(x - size / 2, y + height / 2);
         context.lineTo(x + size / 2, y + height / 2);
         context.lineTo(x, y - height / 2);
         context.lineTo(x - size / 2, y + height / 2);
         context.fill();
         if(do_stroke)
         {
            context.stroke();
         }
         break;
      case Enum.POINT_TYPE.CROSS:
         size = radius * Math.sqrt(Math.PI) / 2;
         context.moveTo(x - size, y);
         context.lineTo(x + size, y);
         context.moveTo(x, y - size);
         context.lineTo(x, y + size);
         if(do_stroke)
         {
            context.strokeStyle = context.fillStyle;
            context.lineWidth = 2;
         }
         context.stroke();
         break;
      case Enum.POINT_TYPE.DOWNTRIANGLE:
         context.lineWidth = 0.1;
         size = radius * Math.sqrt(2 * Math.PI / Math.sin(Math.PI / 3));
         height = size * Math.sin(Math.PI / 3);
         context.moveTo(x - size / 2, y - height / 2);
         context.lineTo(x + size / 2, y - height / 2);
         context.lineTo(x, y + height / 2);
         context.lineTo(x - size / 2, y - height / 2);
         context.fill();
         if(do_stroke)
         {
            context.stroke();
         }
         break;
      case Enum.POINT_TYPE.DIAGCROSS:
         size = radius * Math.sqrt(Math.PI) / 2;
         context.moveTo(x - size, y - size);
         context.lineTo(x + size, y + size);
         context.moveTo(x - size, y + size);
         context.lineTo(x + size, y - size);
         if(do_stroke)
         {
            context.strokeStyle = context.fillStyle;
            context.lineWidth = 2;
         }
         context.stroke();
         break;
      case Enum.POINT_TYPE.STAR:
         size = radius * Math.sqrt(Math.PI) / 2;
         context.moveTo(x - size, y);
         context.lineTo(x + size, y);
         context.moveTo(x, y - size);
         context.lineTo(x, y + size);
         context.moveTo(x - size, y - size);
         context.lineTo(x + size, y + size);
         context.moveTo(x - size, y + size);
         context.lineTo(x + size, y - size);
         if(do_stroke)
         {
            context.strokeStyle = context.fillStyle;
            context.lineWidth = 2;
         }
         context.stroke();
         break;
      case Enum.POINT_TYPE.SMALLDOT:
         context.lineWidth = 0.1;
         context.arc(x, y, radius / 4, 0, Math.PI * 2, false);
         context.fill();
         if(do_stroke)
         {
            context.stroke();
         }
         break;
      case Enum.POINT_TYPE.LEFTTRIANGLE:
         context.lineWidth = 0.1;
         size = radius * Math.sqrt(2 * Math.PI / Math.sin(Math.PI / 3));
         height = size * Math.sin(Math.PI / 3);
         context.moveTo(x + size / 2, y - height / 2);
         context.lineTo(x + size / 2, y + height / 2);
         context.lineTo(x - size / 2, y);
         context.lineTo(x + size / 2, y - height / 2);
         context.fill();
         if(do_stroke)
         {
            context.stroke();
         }
         break;
      case Enum.POINT_TYPE.RIGHTTRIANGLE:
         context.lineWidth = 0.1;
         size = radius * Math.sqrt(2 * Math.PI / Math.sin(Math.PI / 3));
         height = size * Math.sin(Math.PI / 3);
         context.moveTo(x - size / 2, y - height / 2);
         context.lineTo(x - size / 2, y + height / 2);
         context.lineTo(x + size / 2, y);
         context.lineTo(x - size / 2, y - height / 2);
         context.fill();
         if(do_stroke)
         {
            context.stroke();
         }
         break;
   }
};


CsiGraphSeries.prototype.draw_bar_type = function (context, bar_type, bar_rect)
{
   var draw_border = bar_rect.height > 0 && this.bar_border_line_type !== Enum.LINE_TYPE.CLEAR;
   if(draw_border)
   {
      bar_rect.set_left(bar_rect.left + this.bar_border_width / 2);
      bar_rect.set_width(bar_rect.width - this.bar_border_width);
   }

   if(bar_rect.height === 0)
   {
      bar_rect.set_height(1);
      bar_rect.set_top(bar_rect.top - 0.5);
   }

   switch(bar_type)
   {
      case Enum.BAR_TYPE.PYRAMID:
         context.beginPath();
         context.moveTo(bar_rect.left + (bar_rect.width / 2), bar_rect.top);
         context.lineTo(bar_rect.right, bar_rect.bottom);
         context.lineTo(bar_rect.left, bar_rect.bottom);
         context.closePath();

         if(draw_border)
         {
            context.stroke();
         }
         context.fill();
         break;
      case Enum.BAR_TYPE.INVPYRAMID:
         context.beginPath();
         context.moveTo(bar_rect.left, bar_rect.top);
         context.lineTo(bar_rect.right, bar_rect.top);
         context.lineTo(bar_rect.left + bar_rect.width / 2, bar_rect.bottom);
         context.closePath();

         if(draw_border)
         {
            context.stroke();
         }
         context.fill();
         break;
      case Enum.BAR_TYPE.ELLIPSE:
         draw_ellipse(context, bar_rect);

         if(draw_border)
         {
            context.stroke();
         }
         context.fill();
         break;
      case Enum.BAR_TYPE.ARROW:
         var arrow_edge = bar_rect.width / 4;
         context.beginPath();
         context.moveTo(bar_rect.left + arrow_edge, bar_rect.bottom); //Bottom Left
         context.lineTo(bar_rect.right - arrow_edge, bar_rect.bottom); //Bottom Right
         context.lineTo(bar_rect.right - arrow_edge, bar_rect.top + 2 * arrow_edge); //Arrow base right
         context.lineTo(bar_rect.right, bar_rect.top + 2 * arrow_edge); //Arrow head right
         context.lineTo(bar_rect.right - bar_rect.width / 2, bar_rect.top); //Arrow tip
         context.lineTo(bar_rect.left, bar_rect.top + 2 * arrow_edge); //Arrow head left
         context.lineTo(bar_rect.left + arrow_edge, bar_rect.top + 2 * arrow_edge); //Arrow base left
         context.closePath();

         if(draw_border)
         {
            context.stroke();
         }
         context.fill();
         break;
      case Enum.BAR_TYPE.RECTGRADIENT:
         var bar_gradient = context.createLinearGradient(bar_rect.left, bar_rect.top, bar_rect.right, bar_rect.bottom);
         bar_gradient.addColorStop(0, this.bar_color);
         bar_gradient.addColorStop(1, "#FFFFFF");
         context.fillStyle = bar_gradient;

         if(draw_border)
         {
            context.strokeRect(bar_rect.left, bar_rect.top, bar_rect.width, bar_rect.height);
            context.fillRect(bar_rect.left, bar_rect.top, bar_rect.width, bar_rect.height);
         }
         else
         {
            //If we have no line border, we will frame the gradient bar with the bar color
            context.fillRect(bar_rect.left, bar_rect.top, bar_rect.width, bar_rect.height);

            context.lineWidth = 1;
            context.strokeStyle = this.bar_color;
            context.strokeRect(bar_rect.left, bar_rect.top, bar_rect.width, bar_rect.height);
         }
         break;
      //case Enum.BAR_TYPE.CILINDER: 
      //case Enum.BAR_TYPE.RECTANGLE: 
      default:
         //Build up the rectangle
         if(draw_border)
         {
            context.strokeRect(bar_rect.left, bar_rect.top, bar_rect.width, bar_rect.height);
         }
         context.fillRect(bar_rect.left, bar_rect.top, bar_rect.width, bar_rect.height);
         break;
   }
};


CsiGraphSeries.prototype.hit_test = function (pt, hit_space)
{
   if(this.point_size > hit_space)
   {
      hit_space = this.point_size;
   }

   var rtn = false;
   var len = this.mark_cache.length;
   var i;
   for(i = 0; i < len; i++)
   {
      var point_rect = new Rect(this.mark_cache[i].pt_x - hit_space, this.mark_cache[i].pt_y - hit_space, 2 * hit_space, 2 * hit_space);
      if(point_rect.contains(pt))
      {
         this.current_mark = this.mark_cache[i];
         this.current_mark.start_time = CsiLgrDate.local();
         rtn = true;
         break;
      }
   }

   if(!rtn)
   {
      this.current_mark = null;
   }

   return rtn;
};


function CsiGraphMark(x_val, y_val, pt_x, pt_y)
{
   this.x_val = x_val;
   this.y_val = y_val;
   this.pt_x = pt_x;
   this.pt_y = pt_y;
   this.start_time = null;
}


Enum.SERIES_TYPE =
{
   LINE: 0,
   BAR: 1,
   POINT: 2
};


Enum.POINT_TYPE =
{
   RECTANGLE: 0,
   CIRCLE: 1,
   TRIANGLE: 2,
   DOWNTRIANGLE: 3,
   CROSS: 4,
   DIAGCROSS: 5,
   STAR: 6,
   DIAMOND: 7,
   SMALLDOT: 8,
   NOTHING: 9,
   LEFTTRIANGLE: 10,
   RIGHTTRIANGLE: 11
};


Enum.BAR_TYPE =
{
   RECTANGLE: 0,
   PYRAMID: 1,
   INVPYRAMID: 2,
   CILINDER: 3,
   ELLIPSE: 4,
   ARROW: 5,
   RECTGRADIENT: 6
};


Enum.MARKS_TYPE =
{
   VALUE: 0,
   TIMESTAMP: 1,
   BOTH: 2
};
/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiGraphXYSeries.js $

Copyright (C) 2010 Campbell Scientific, Inc.
Started On: 12/7/2010 7:05:16 AM
Started By: Tyler Mecham

$LastChangedBy: jon $
$LastChangedDate: 2013-04-29 13:33:06 -0600 (Mon, 29 Apr 2013) $
$LastChangedRevision: 18017 $
*/

/* global CsiGraphSeries: true */


function CsiGraphXYSeries(y_expression, x_expression, owner, axis)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   CsiGraphSeries.call(this, y_expression, owner, axis);

   this.xvalue = new CsiXValue(this, x_expression);

   this.x_data = [];
   this.y_data = [];

   this.x_expression = x_expression;
   this.max_points = 100;
   this.series_type = Enum.SERIES_TYPE.POINT;
   this.timeOffsetX = 0;
   this.use_history_gradient = false;
   this.history_gradient = [];
   this.point_gradient_color = "#000000";

   this.data_changed = false;
}
CsiGraphXYSeries.prototype = new CsiGraphSeries();


function CsiXValue(owner, expression)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   if(expression)
   {
      this.expression = expression;
      this.expression.ownerComponent = this;
   }
   else
   {
      this.expression = null;
   }

   this.ownerComponent = owner;
   this.bad_data = true;
   this.nan_data = false;
}
CsiXValue.prototype = new CsiXValue();


CsiXValue.prototype.invalidate = function ()
{
   this.ownerComponent.valid = false;
   graphicsManager.componentInvalidate(this.ownerComponent);
};


CsiXValue.prototype.newValue = function (value, timestamp, expectMore)
{
   this.ownerComponent.newXValue(value, timestamp, expectMore);
};


CsiGraphXYSeries.prototype.newXValue = function (value, timestamp, expect_more)
{
   var found_match = false;
   var ts_with_offset = timestamp.milliSecs + this.timeOffsetX;

   var y_count = this.y_data.length;
   var y;
   for(y = 0; y < y_count && !found_match; ++y)
   {
      if(this.y_data[y][0].milliSecs === ts_with_offset)
      {
         //Found a match, so add the match pair
         this.addPoint(ts_with_offset, value, this.y_data[y][1], expect_more);
         this.y_data.splice(0, y); //Remove everything older than this since we found a match
         found_match = true;
      }
   }

   if(!found_match)
   {
      if(this.timeOffsetX === 0)
      {
         this.x_data.push([timestamp, value]);
      }
      else
      {
         this.x_data.push([new CsiLgrDate(ts_with_offset), value]);
      }
   }

   if(!found_match && !expect_more && this.data_changed)
   {
      this.data_changed = false;
      this.ownerGraph.positionsInvalid = true;
      this.ownerGraph.invalidate();
   }
};


CsiGraphXYSeries.prototype.newValue = function (value, timestamp, expect_more)
{
   var found_match = false;
   var ts_with_offset = timestamp.milliSecs + this.timeOffset;

   var x_count = this.x_data.length;
   var x;
   for(x = 0; x < x_count && !found_match; ++x)
   {
      if(this.x_data[x][0].milliSecs === ts_with_offset)
      {
         //Found a match, so add the match pair
         this.addPoint(ts_with_offset, value, this.x_data[x][1], expect_more);
         this.x_data.splice(0, x); //Remove everything older than this since we found a match
         found_match = true;
      }
   }

   if(!found_match)
   {
      if(this.timeOffset === 0)
      {
         this.y_data.push([timestamp, value]);
      }
      else
      {
         this.y_data.push([new CsiLgrDate(ts_with_offset), value]);
      }
   }

   if(!found_match && !expect_more && this.data_changed)
   {
      this.data_changed = false;
      this.ownerGraph.positionsInvalid = true;
      this.ownerGraph.invalidate();
   }
};


CsiGraphXYSeries.prototype.addPoint = function (timestamp, x_value, y_value, expect_more)
{
   this.data_changed = true;
   this.data.push([x_value, y_value]);
   if(!expect_more)
   {
      //remove oldest data outside max points
      var remove_count = this.data.length - this.max_points;
      if(remove_count > 0)
      {
         this.data.splice(0, remove_count);
      }

      this.data_changed = false;
      this.ownerGraph.positionsInvalid = true;
      this.ownerGraph.invalidate();
   }
};


function break_down_color(html_color)
{
   var ret = [];
   var color = (html_color.charAt(0) === "#") ? html_color.substring(1, 7) : html_color;
   ret[0] = Number(parseInt(color.substring(0, 2), 16)); //Red
   ret[1] = Number(parseInt(color.substring(2, 4), 16)); //Green
   ret[2] = Number(parseInt(color.substring(4, 6), 16)); //Blue
   return ret;
}


CsiGraphXYSeries.prototype.draw_points = function (context)
{
   var r = 0;
   var g = 0;
   var b = 0;
   var i = 0;
   context.lineWidth = 1;
   context.strokeStyle = this.point_color;
   context.fillStyle = this.point_color;
   var len = this.data.length;
   //Figure out the gradient colors if we have a new data count
   if(this.use_history_gradient && this.history_gradient.length !== len)
   {
      this.history_gradient = [];
      // Get the intensity values for the new data color
      var c1 = break_down_color(this.point_color_gradient);

      // Get the intensity values for the old data color
      var c2 = break_down_color(this.point_color);

      var ratio_count = Number(len);
      for(i = 0; i < len; i++)
      {
         var ratio = Number((ratio_count - (ratio_count - i)) / ratio_count);

         if(c1[0] > c2[0])
         {
            r = c1[0] - (c1[0] - c2[0]) * ratio;
         }
         else
         {
            r = c1[0] + (c2[0] - c1[0]) * ratio;
         }

         if(c1[1] > c2[1])
         {
            g = c1[1] - (c1[1] - c2[1]) * ratio;
         }
         else
         {
            g = c1[1] + (c2[1] - c1[1]) * ratio;
         }

         if(c1[2] > c2[2])
         {
            b = c1[2] - (c1[2] - c2[2]) * ratio;
         }
         else
         {
            b = c1[2] + (c2[2] - c1[2]) * ratio;
         }

         this.history_gradient[i] = 'RGB(' + Math.floor(r) + ',' + Math.floor(g) + ',' + Math.floor(b) + ')';
      }
   }


   for(i = 0; i < len; i++)
   {
      if(this.use_history_gradient)
      {
         context.fillStyle = this.history_gradient[i];
      }

      var x_val = this.data[i][0];
      if(x_val instanceof CsiLgrDate)
      {
         x_val = x_val.milliSecs;
      }
      var y_val = this.data[i][1];
      var x_pos = this.domain_axis.value_to_pos(x_val);
      var y_pos = this.range_axis.value_to_pos(y_val);
      this.draw_point_type(context, this.point_type, x_pos, y_pos, this.point_size, true);
   }
};


CsiGraphXYSeries.prototype.reset_data = function ()
{
   this.bad_data = true;
   this.data = [];
   this.x_data = [];
   this.y_data = [];
   this.max_points = Number.MAX_VALUE;
   this.data_changed = true;
   this.ownerGraph.positionsInvalid = true;
   this.invalidate();
};
/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiGraphScopeSeries.js $

Copyright (C) 2010 Campbell Scientific, Inc.
Started On: 12/7/2010 7:05:16 AM
Started By: Tyler Mecham

$LastChangedBy: jon $
$LastChangedDate: 2013-04-29 13:33:06 -0600 (Mon, 29 Apr 2013) $
$LastChangedRevision: 18017 $
*/

/* global CsiGraphSeries: true */


function CsiGraphScopeSeries(expression, owner, axis)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   CsiGraphSeries.call(this, expression, owner, axis);
   this.first_data = true;
}
CsiGraphScopeSeries.prototype = new CsiGraphSeries();


CsiGraphScopeSeries.prototype.newValue = function (value, timestamp, expect_more)
{
   //Init the scope fill and clear
   if(this.first_data && this.ownerGraph.fill_and_clear)
   {
      this.first_data = false;
      this.ownerGraph.newestTimeStamp = timestamp.milliSecs;
      this.ownerGraph.clear_data(this);
   }

   this.bad_data = false;
   if(this.ownerGraph.real_time)
   {
      //In real time mode, only the newest record in the table should be retrieved
      if(!expect_more)
      {
         this.data.push([timestamp, value]);
      }
   }
   else
   {
      this.data.push([timestamp, value]);
   }

   if(!expect_more)
   {
      //update the newesttimestamp
      if(timestamp.milliSecs > this.ownerGraph.newestTimeStamp)
      {
         this.ownerGraph.newestTimeStamp = timestamp.milliSecs;
      }

      //find old data
      var i = 0;
      var len = this.data.length;
      var cutoff = this.ownerGraph.newestTimeStamp - this.ownerGraph.graphWidth;
      while((i < len) && (this.data[i][0].milliSecs < cutoff))
      {
         i++;
         if(this.ownerGraph.fill_and_clear)
         {
            break;
         }
      }

      //remove old data
      if(i > 0)
      {
         if(this.ownerGraph.fill_and_clear)
         {
            this.ownerGraph.clear_data(this);
         }
         else
         {
            this.data.splice(0, i);
         }
      }

      this.ownerGraph.positionsInvalid = true;
      this.ownerGraph.invalidate();
   }
};
/* CsiScale.js

Copyright (C) 2011, 2013 Campbell Scientific, Inc.

Written by: Jon Trauntvein
Date Begun: Thursday 21 April 2011
Last Change: Tuesday 28 May 2013
Last Commit: $Date: 2013-05-28 15:52:38 -0600 (Tue, 28 May 2013) $
Last Changed by: $Author: jon $

*/


////////////////////////////////////////////////////////////
// class CsiScale
//
// Defines a component that implements an algorithm that calculates the
// interval and generates the labels for a linear or logarithmic scale.  This
// can be used for various components including graph axes, status bars, tanks,
// and etc. 
////////////////////////////////////////////////////////////
function CsiScale()
{
   this.scale = 1.0;
   this.labels = [];
   this.size = 100;
   this.rotation = 0;
   this.inverted = false;
   this.max_value = 100;
   this.min_value = 0;
   this.vertical = false;
   this.time_domain = false;
   this.time_format = "%c";
   this.logarithmic = false;
   this.log_base = 10;
   this.fixed_decimals = false;
   this.decimal_places = 2;
   this.one_tick_only = false;
}


////////////////////////////////////////////////////////////
// format_label
////////////////////////////////////////////////////////////
CsiScale.prototype.format_label = function (value)
{
   var rtn;
   if(!this.time_domain)
   {
      var format = "%.10g";
      if(this.fixed_decimals)
      {
         format = "%." + this.decimal_places + "f";
      }

      if(this.logarithmic)
      {
         rtn = sprintf(format, Math.pow(this.log_base, value));
      }
      else
      {
         rtn = sprintf(format, value);
      }
   }
   else
   {
      if(!(value instanceof CsiLgrDate))
      {
         value = new CsiLgrDate(value);
      }
      rtn = value.format(this.time_format);
   }
   return rtn;
};


////////////////////////////////////////////////////////////
// calculate_scale
//
// Calculates the scale factor and label interval given the min, max, and context.
////////////////////////////////////////////////////////////
CsiScale.prototype.calculate_scale = function (min_value, max_value, context)
{
   // if the max and min values are the same (or very close), we will
   // need to fudge the range somewhat
   var range = Math.abs(max_value - min_value);
   this.one_tick_only = false;
   if(range <= 1e-38)
   {
      max_value = min_value + 0.5;
      min_value = max_value - 1;
      range = 1;
      this.one_tick_only = true;
   }

   // if this scale is logarithmic, we will need to evaluate the log
   // of the max and min.
   if(this.logarithmic)
   {
      if(min_value <= 0)
      {
         min_value = 1;
      }

      if(max_value < min_value)
      {
         max_value = min_value + 1;
      }
      max_value = Math.log(max_value) / Math.log(this.log_base);
      min_value = Math.log(min_value) / Math.log(this.log_base);
      range = Math.abs(max_value - min_value);
      if(range < 1)
      {
         min_value = max_value - 1;
         range = 1;
      }
   }

   // we can now calculate the scale and interval
   var format_min = this.format_label(min_value);
   var format_max = this.format_label(max_value);
   var min_rect = this.measure_label(format_min, context);
   var max_rect = this.measure_label(format_max, context);
   var label_req = Math.max(min_rect.get_width(), max_rect.get_width());

   if(this.vertical)
   {
      label_req = Math.max(min_rect.get_height(), max_rect.get_height());
   }
   this.scale = this.size / range;
   this.max_value = max_value;
   this.min_value = min_value;
   if(this.logarithmic)
   {
      // we will produce a label for each power of the log base within the range
      this.label_interval = 1;
   }
   else if(this.label_interval <= 0)
   {
      // we need to determine the optimal interval to use.  The
      // algorithm used will depend upon whether this is a time domain
      // axis.
      if(!this.time_domain)
      {
         this.label_interval = CsiScale.scalar_optimum_step_size(
            range, this.size, label_req);
      }
      else
      {
         this.label_interval = CsiScale.time_optimum_step_size(
            range, this.size, label_req);
      }
   }
   else
   {
      // the properties have set up a fixed interval for the labels.
      // Even if this is the case, we may need to revert to
      // auto-labels if the count specified results in labels that are
      // too close together.
      if(this.label_interval * this.scale < label_req)
      {
         if(!this.time_domain)
         {
            this.label_interval = CsiScale.scalar_optimum_step_size(
               range, this.size, label_req);
         }
         else
         {
            this.label_interval = CsiScale.time_optimum_step_size(
               range, this.size, label_req);
         }
      }
   }
   return { scale: this.scale, interval: this.label_interval };
};


////////////////////////////////////////////////////////////
// generate_labels
//
// Calculates the scale factor for this scale as well as the label interval.
// Uses these to generate the set of labels for this scale along with the
// location and value for those labels.
////////////////////////////////////////////////////////////
CsiScale.prototype.generate_labels = function (min_value, max_value, context)
{
   // We can now calculate the value of the first tick.
   var first_tick = 0;
   this.calculate_scale(min_value, max_value, context);
   if(!this.one_tick_only)
   {
      if(this.min_value <= 0.0)
      {
         first_tick = this.min_value + (Math.abs(this.min_value) % this.label_interval);
      }
      else
      {
         first_tick = this.min_value - (Math.abs(this.min_value) % this.label_interval);
      }
   }
   else
   {
      first_tick = (this.max_value - this.min_value) / 2 + this.min_value;
   }

   // finally, we can generate the labels and their positions and values
   var tick_count = 0;
   var tick = first_tick;
   var max_places = 0;
   this.labels.splice(0);
   while(tick <= this.max_value)
   {
      if(tick >= this.min_value)
      {
         var tick_value = (this.logarithmic ? Math.pow(this.log_base, tick) : tick);
         var formatted_label = this.format_label(tick);
         var label = {
            "label": formatted_label,
            "value": tick_value,
            "position": this.value_to_pos(tick_value),
            "rect": this.measure_label(formatted_label, context)
         };
         if(!this.fixed_decimal && !this.time_domain)
         {
            max_places = Math.max(CsiScale.count_decimals(formatted_label), max_places);
         }

         if(this.vertical)
         {
            label.rect.center_y(label.position);
         }
         else
         {
            label.rect.center_x(label.position);
         }
         this.labels.push(label);
         if(this.one_tick_only)
         {
            break;
         }
      }
      tick = this.next_tick(first_tick, ++tick_count, this.label_interval);
   }

   // We need to adjust the formatting of automatically generated
   // labels so that the number of places following the decimal point
   // is consistent for all labels.  This should keep the decimal
   // points aligned on the left axis.
   var i = 0;
   var cnt = this.labels.length;
   if(max_places > 0 && !this.time_domain)
   {
      for(i = 0; i < cnt; ++i)
      {
         var adj_label = this.labels[i];
         adj_label.label = CsiScale.append_decimals(adj_label.label, max_places);
      }
   }

   // the final thing to do is to eliminate any labels that are duplicates.
   var last_valid = '';
   for(i = 1; i < cnt; ++i)
   {
      var cur_label = this.labels[i];
      var prev_label = this.labels[i - 1];
      if(cur_label.label === prev_label.label)
      {
         last_valid = cur_label.label;
         cur_label.label = '';
      }
      else if(cur_label.label === last_valid)
      {
         cur_label.label = '';
      }
      else
      {
         last_valid = '';
      }
   }
   return this.labels;
};


////////////////////////////////////////////////////////////
// generate_minor_ticks
//
// Generates an array of the values of minor ticks based upon the
// label interval calculated by generate_labels().  
////////////////////////////////////////////////////////////
CsiScale.prototype.generate_minor_ticks = function (min_width, count)
{
   var rtn = [];
   if(this.labels.length > 0 && !this.one_tick_only)
   {
      // we may have to calculate the best minor tick interval
      var tick_interval = this.label_interval / (count + 1);
      var tick_width = tick_interval * this.scale;
      var space = this.label_interval * this.scale;
      if(tick_width < min_width || isNaN(tick_interval))
      {
         var intervals_count = space / min_width;
         if(intervals_count > 9)
         {
            min_width = space / 9;
         }

         if(this.time_domain)
         {
            tick_interval = CsiScale.time_optimum_step_size(
               this.label_interval, space, min_width);
         }
         else
         {
            tick_interval = CsiScale.scalar_optimum_step_size(
               this.label_interval, space, min_width);
            if(this.label_interval % tick_interval > 1e-38)
            {
               var formatted_tick = sprintf("%g", tick_interval);
               var least_digit_pos = formatted_tick.search(/[^0]([eE][+-]?\d)?$/);
               var formatted_tick_array = Csi.string_to_array(formatted_tick);
               if(least_digit_pos < 0)
               {
                  least_digit_pos = formatted_tick.length - 1;
               }

               if(formatted_tick_array[least_digit_pos] === '2')
               {
                  formatted_tick_array[least_digit_pos] = '5';
               }
               formatted_tick = formatted_tick_array.join('');
               tick_interval = Number(formatted_tick);
            }
         }
      }

      // we will generate minor ticks for each label interval
      var labels_count = this.labels.length;
      var scale_min = this.min_value;
      var scale_max = this.max_value;

      if(this.logarithmic)
      {
         scale_max = Math.pow(this.log_base, scale_max);
         scale_min = Math.pow(this.log_base, scale_min);
      }

      var i;
      for(i = 0; i <= labels_count; ++i)
      {
         var label_min;
         var label_max;
         var first_tick = 0;
         var tick = 0;
         var ticks_count = 0;

         var label;
         if(i < labels_count)
         {
            label = this.labels[i];
            label_max = label.value;
            if(!this.logarithmic)
            {
               label_min = label.value - this.label_interval;
            }
            else
            {
               label_min = Math.pow(
                  this.log_base,
                  (Math.log(label_max) / Math.log(this.log_base)) - 1);
            }
         }
         else
         {
            label = this.labels[i - 1];
            label_min = label.value;
            if(!this.logarithmic)
            {
               label_max = label.value + this.label_interval;
            }
            else
            {
               label_max = Math.pow(
                  this.log_base,
                  (Math.log(label_min) / Math.log(this.log_base)) + 1);
            }
         }
         if(this.logarithmic)
         {
            if(count > this.log_base)
            {
               count = this.log_base;
            }
            tick_interval = Math.abs(label_max - label_min) / count;
         }
         if(label_min <= 0)
         {
            first_tick = label_min + Math.abs(label_min % tick_interval);
         }
         else
         {
            first_tick = label_min - Math.abs(label_min % tick_interval);
         }
         tick = first_tick;
         while(tick < label_max && tick < scale_max)
         {
            if(tick > scale_min && tick > label_min)
            {
               rtn.push(tick);
            }
            tick = this.next_tick(first_tick, ++ticks_count, tick_interval);
         }
      }
   }
   return rtn;
};


////////////////////////////////////////////////////////////
// value_to_pos
//
// Calculates the position in the scale of the specified value.
// generate_labels() should have been called before this method. 
////////////////////////////////////////////////////////////
CsiScale.prototype.value_to_pos = function (value)
{
   var rtn;
   if(this.logarithmic)
   {
      value = Math.log(value) / Math.log(this.log_base);
   }
   if(this.vertical)
   {
      if(this.inverted)
      {
         rtn = this.scale * (value - this.min_value);
      }
      else
      {
         rtn = this.scale * (this.max_value - value);
      }
   }
   else
   {
      if(this.inverted)
      {
         rtn = this.scale * (this.max_value - value);
      }
      else
      {
         rtn = this.scale * (value - this.min_value);
      }
   }
   return rtn;
};


////////////////////////////////////////////////////////////
// offset_value
//
// Calculates the position of a pixel offset from the specified value
////////////////////////////////////////////////////////////
CsiScale.prototype.value_offset_weight = function (value, offset)
{
   var value_pos = this.value_to_pos(value);
   var rtn;
   if(this.vertical)
   {
      if(this.inverted)
      {
         rtn = Math.abs(this.pos_to_value(value_pos + offset) - value);
      }
      else
      {
         rtn = Math.abs(this.pos_to_value(value_pos - offset) - value);
      }
   }
   else
   {
      if(this.inverted)
      {
         rtn = Math.abs(this.pos_to_value(value_pos - offset) - value);
      }
      else
      {
         rtn = Math.abs(this.pos_to_value(value_pos + offset) - value);
      }
   }
   return rtn;
};


////////////////////////////////////////////////////////////
// pos_to_value
////////////////////////////////////////////////////////////
CsiScale.prototype.pos_to_value = function (pos)
{
   var rtn;
   if(this.vertical)
   {
      if(this.inverted)
      {
         rtn = pos / this.scale + this.min_value;
      }
      else
      {
         rtn = this.max_value - pos / this.scale;
      }
   }
   else
   {
      if(this.inverted)
      {
         rtn = this.max_value - pos / this.scale;
      }
      else
      {
         rtn = pos / this.scale + this.min_value;
      }
   }
   if(this.logarithmic)
   {
      rtn = Math.pow(this.log_base, rtn);
   }
   return rtn;
};


////////////////////////////////////////////////////////////
// measure_label
//
// Measures the dimensions of the specified label while applying the
// rotation and vertical properties.
////////////////////////////////////////////////////////////
CsiScale.prototype.measure_label = function (label, context)
{
   var rtn = CsiScale.measure_text(label, context);
   if(this.rotation !== 0)
   {
      rtn.rotate(this.rotation);
   }
   return rtn;
};


///////////////////////////////////////////////////////////
// get_max_value
///////////////////////////////////////////////////////////
CsiScale.prototype.get_max_value = function ()
{
   var rtn = this.max_value;
   if(this.logarithmic)
   {
      rtn = Math.pow(this.log_base, rtn);
   }
   return rtn;
};


///////////////////////////////////////////////////////////
// get_min_value
///////////////////////////////////////////////////////////
CsiScale.prototype.get_min_value = function ()
{
   var rtn = this.min_value;
   if(this.logarithmic)
   {
      rtn = Math.pow(this.log_base, rtn);
   }
   return rtn;
};


////////////////////////////////////////////////////////////
// next_tick
//
// Calculates the value of the next tick given the starting position,
// number of ticks previously generated, and the tick interval. 
////////////////////////////////////////////////////////////
CsiScale.prototype.next_tick = function (first_tick, ticks_count, tick_interval)
{
   var rtn = first_tick + ticks_count * tick_interval;
   if(this.time_domain && tick_interval >= CsiScale.month_interval)
   {
      var temp = new CsiLgrDate(first_tick);
      var date = temp.toDate();
      date.day = 1;
      if(tick_interval >= CsiScale.month_interval &&
         tick_interval < CsiScale.quarter_interval)
      {
         date.month += ticks_count % 12;
         date.year += Math.floor(ticks_count / 12);
      }
      else if(tick_interval >= CsiScale.quarter_interval &&
              tick_interval < CsiScale.half_year_interval)
      {

         date.month += (ticks_count * 3) % 12;
         date.year += Math.floor((ticks_count * 3) / 12);
      }
      else if(tick_interval >= CsiScale.half_year_interval &&
              tick_interval < CsiScale.year_interval)
      {
         date.month += (ticks_count * 6) % 12;
         date.year += Math.floor((ticks_count * 6) / 12);
      }
      else
      {
         date.month = 1;
         date.year += ticks_count;
      }
      if(date.month > 12)
      {
         date.month = date.month - 12;
         date.year += 1;
      }
      temp.setDate(date.year, date.month, date.day);
      rtn = temp.milliSecs;
   }
   return rtn;
};


////////////////////////////////////////////////////////////
// scalar_optimum_step_size
//
// Utility function that calculates the optimum step size for a scalar axis
// based upon a given range, label requirement, and the amount of space
// available for displaying labels.
////////////////////////////////////////////////////////////
CsiScale.scalar_optimum_step_size = function (
   range, space, label_req)
{
   // we will make an initial estimate based upon the space available and the
   // range to fit.  We can then format that value as a fixed decimal string.
   var max_steps = space / label_req;
   var step_size = range / max_steps;
   var step_str = step_size.toFixed(7);

   // we now need to adjust this formatted step so that the scale is formatted
   // with convenient (to the user) labels.  
   var regex = /[^0\.](0|\.)*$/;
   var last_pos = step_str.search(regex);

   while(last_pos >= 0)
   {
      // we need to find the digit preceding this one.
      var temp = step_str.slice(0, last_pos);
      var previous_pos = temp.search(regex);
      if(previous_pos >= 0)
      {
         step_str = CsiScale.clear_with_carry(step_str, last_pos);
         last_pos = step_str.search(regex);
      }
      else
      {
         // we have reduced the step to its most significant digit.  This needs
         // to be rounded to the closest "convenient" digit.
         var array = Csi.string_to_array(step_str);
         switch(array[last_pos])
         {
            case '1':
            case '2':
            case '5':
               // these are digits that we want in the most significant place
               break;

            case '3':
            case '4':
               array[last_pos] = '5';
               break;

            case '6':
            case '7':
            case '8':
            case '9':
               temp = CsiScale.clear_with_carry(array.join(""), last_pos);
               array = Csi.string_to_array(temp);
               break;

            case '0':
               array[last_pos] = '1';
               break;
         }
         last_pos = -1;
         step_size = parseFloat(array.join(""));
      }
   }

   // as a final check, we need to make sure that there is at least one step.
   if(step_size <= 0)
   {
      step_size = 1;
   }
   return step_size;
};


////////////////////////////////////////////////////////////
// clear_with_carry
//
// A utility function that will clear the specified position of a numeric string
// (replace the character with '0' and increment the previous digit.
////////////////////////////////////////////////////////////
CsiScale.clear_with_carry = function (buff, pos)
{
   // we need to find the digit before the specified position
   var array = Csi.string_to_array(buff);
   var previous_pos = pos - 1;
   if(previous_pos >= 0 && array[previous_pos] === '.')
   {
      --previous_pos;
   }
   array[pos] = '0';
   if(previous_pos >= 0)
   {
      if(array[previous_pos] !== '9')
      {
         array[previous_pos] = String.fromCharCode(array[previous_pos].charCodeAt(0) + 1);
      }
      else
      {
         return CsiScale.clear_with_carry(array.join(""), previous_pos);
      }
   }
   else
   {
      array.unshift('1');
   }
   return array.join("");
};


////////////////////////////////////////////////////////////
// measure_text
//
// Calculates the width and height of the specified text using the specified
// context.  
////////////////////////////////////////////////////////////
CsiScale.measure_text = function (text, context)
{
   var metrics = context.measureText(text);
   if(!("height" in metrics)) 
   {
      metrics.height = context.measureText("W").width;
   }
   return new CsiNestedRect(0, 0, metrics.width, metrics.height * 1.1);
};


CsiScale.month_interval = 4 * CsiLgrDate.msecPerWeek;
CsiScale.quarter_interval = 12 * CsiLgrDate.msecPerWeek;
CsiScale.half_year_interval = 26 * CsiLgrDate.msecPerWeek;
CsiScale.year_interval = 52 * CsiLgrDate.msecPerWeek;
CsiScale.time_intervals = [
   1,
   2,
   5,
   10,
   20,
   50,
   100,
   200,
   500,
   1 * CsiLgrDate.msecPerSec,
   5 * CsiLgrDate.msecPerSec,
   15 * CsiLgrDate.msecPerSec,
   30 * CsiLgrDate.msecPerSec,
   1 * CsiLgrDate.msecPerMin,
   5 * CsiLgrDate.msecPerMin,
   15 * CsiLgrDate.msecPerMin,
   30 * CsiLgrDate.msecPerMin,
   1 * CsiLgrDate.msecPerHour,
   2 * CsiLgrDate.msecPerHour,
   6 * CsiLgrDate.msecPerHour,
   12 * CsiLgrDate.msecPerHour,
   1 * CsiLgrDate.msecPerDay,
   2 * CsiLgrDate.msecPerDay,
   5 * CsiLgrDate.msecPerDay,
   1 * CsiLgrDate.msecPerWeek,
   2 * CsiLgrDate.msecPerWeek,
   4 * CsiScale.month_interval,
   12 * CsiScale.quarter_interval,
   26 * CsiScale.half_year_interval,
   52 * CsiScale.year_interval
];


////////////////////////////////////////////////////////////
// time_optimum_step_size
//
// Given the range, space, and label requirement, this function will
// calculate the step size that gives the most convenient label.
////////////////////////////////////////////////////////////
CsiScale.time_optimum_step_size = function (
   range, space, label_req)
{
   var step_size;
   if(range !== Infinity)
   {
      // we will make an initial estimate based upon the parameters
      var max_steps = space / label_req;
      var len = CsiScale.time_intervals.length;
      var i = 0;
      step_size = range / max_steps;
      while(i < len && step_size > CsiScale.time_intervals[i])
      {
         ++i;
      }

      if(i < len)
      {
         step_size = CsiScale.time_intervals[i];
      }
      else
      {
         step_size = CsiScale.scalar_optimum_step_size(range, space, label_req);
      }
   }
   else
   {
      step_size = 100;
   }
   return step_size;
};


CsiScale.count_decimals = function (value)
{
   var decimal_pos = value.indexOf(".");
   var rtn = 0;
   if(decimal_pos >= 0)
   {
      var exp_pos = value.search(/[eE]/);
      if(exp_pos < 0)
      {
         exp_pos = value.length;
      }
      rtn = exp_pos - decimal_pos - 1;
   }
   return rtn;
};


CsiScale.append_decimals = function (value, decimals)
{
   var decimal_pos = value.indexOf(".");
   var needed = decimals - CsiScale.count_decimals(value);
   var array = Csi.string_to_array(value);
   var exp_pos = value.search(/[eE]/);

   if(exp_pos < 0)
   {
      exp_pos = value.length;
   }
   if(decimal_pos < 0)
   {
      array.splice(exp_pos, 0, '.');
      ++exp_pos;
   }
   while(needed > 0)
   {
      array.splice(exp_pos, 0, '0');
      --needed;
   }
   return array.join('');
};
/* CsiNestedRect.js

Copyright (C) 2011, 2011 Campbell Scientific, Inc.

Written by: Jon Trauntvein
Date Begun: Wednesday 04 May 2011
Last Change: Friday 28 October 2011
Last Commit: $Date: 2013-02-20 09:45:24 -0700 (Wed, 20 Feb 2013) $
Last Changed by: $Author: tmecham $

*/


////////////////////////////////////////////////////////////
// class CsiNestedRect
//
// Defines a component that is responsible for computing the layout of
// a hierarchy of other sizers and component rectangles.  
////////////////////////////////////////////////////////////
function CsiNestedRect()
{
   this.children = [];
   this.is_stale = false;
   this.parent = null;
   if(arguments.length === 1)
   {
      var arg0 = arguments[0]; 
      if(arg0 instanceof Rect)
      {
         Rect.call(this, arg0.left, arg0.top, arg0.width, arg0.height);
      }
      else if(arg0 instanceof CsiNestedRect)
      {
         Rect.call(this, arg0.left, arg0.top, arg0.width, arg0.height);
      }
   }
   else if(arguments.length === 4)
   {
      Rect.call(this, arguments[0], arguments[1], arguments[2], arguments[3]); 
   }
   else
   {
      Rect.call(this);
   }
}
CsiNestedRect.prototype = new Rect();


CsiNestedRect.prototype.add = function ()
{
   if(arguments.length === 1)
   {
      var arg0 = arguments[0]; 
      if(arg0 instanceof CsiNestedRect)
      {
         this.children.push(arg0);
         arg0.parent = this;
         this.mark_stale();
      }
      else if(arg0 instanceof Rect)
      {
         this.add(new CsiNestedRect(arg0));
         this.mark_stale();
      }
   }
   if(arguments.length === 4)
   {
      this.add(
         new CsiNestedRect(
            arguments[0], arguments[1], arguments[2], arguments[3])); 
      this.mark_stale();
   }
};


CsiNestedRect.prototype.get_width = function ()
{ return this.get_rect(false).width; };


CsiNestedRect.prototype.get_height = function ()
{ return this.get_rect(false).height; };


CsiNestedRect.prototype.get_left = function (use_parent_coords)
{ return this.get_rect(use_parent_coords).left; };


CsiNestedRect.prototype.get_top = function (use_parent_coords)
{ return this.get_rect(use_parent_coords).top; };


CsiNestedRect.prototype.get_right = function (use_parent_coords)
{ return this.get_rect(use_parent_coords).right; };


CsiNestedRect.prototype.get_bottom = function (use_parent_coords)
{ return this.get_rect(use_parent_coords).bottom; };


CsiNestedRect.prototype.get_rect = function (use_parent_coords)
{
   // if children have been added, we will need to recalculate our own width
   // and height.
   if(this.is_stale)
   {
      this.layout();
   }

   // we must now determine whether to return our own coordinate system or to
   // translate ours into the parent's coordinate system
   var rtn = new Rect(this.left, this.top, this.width, this.height);
   var parent = this.parent;
   if(jQuery.type(use_parent_coords) === "undefined") 
   {
      use_parent_coords = true;
   }

   while(use_parent_coords && parent) 
   {
      rtn.offset(parent.left, parent.top);
      parent = parent.parent;
   }
   return rtn;
};


CsiNestedRect.prototype.layout = function ()
{
   // we will need to set the width and height of this rectangle
   // to match our own bounds as well as the bounds of our children
   var cnt = this.children.length;
   if(cnt > 0)
   {
      var child_rect = new Rect();
      var i;
      for(i = 0; i < cnt; ++i)
      {
         child_rect.union(this.children[i].get_rect(false));
      }

      if(this.width < child_rect.width)
      {
         this.set_width(child_rect.width);
      }

      if(this.height < child_rect.height)
      {
         this.set_height(child_rect.height);
      }
   }
   this.is_stale = false;
};


CsiNestedRect.prototype.mark_stale = function ()
{
   var pai = this;
   while(pai) 
   {
      pai.is_stale = true;
      pai = pai.parent;
   }
};


CsiNestedRect.prototype.move = function (top, left)
{
   Rect.prototype.move.call(this, top, left);
   this.mark_stale();
};


CsiNestedRect.prototype.rotate = function (degrees)
{
   Rect.prototype.rotate.call(this, degrees);
   this.mark_stale();
};


CsiNestedRect.prototype.offset = function (dx, dy)
{
   Rect.prototype.offset.call(this, dx, dy);
   this.mark_stale();
};


CsiNestedRect.prototype.center = function (cx, cy)
{
   Rect.prototype.center.call(this, cx, cy);
   this.mark_stale();
};


CsiNestedRect.prototype.get_center = function ()
{ return this.translate_point(this.width / 2, this.height / 2); };


CsiNestedRect.prototype.translate_point = function (x, y)
{
   var rtn = new Point(x, y);
   var pai = this;
   while(pai) 
   {
      rtn.x += pai.left;
      rtn.y += pai.top;
      pai = pai.parent;
   }
   return rtn;
};


CsiNestedRect.prototype.translate_from_point = function (x, y)
{
   var rtn = new Point(x, y);
   var pai = this;
   while(pai) 
   {
      rtn.x -= pai.left;
      rtn.y -= pai.top;
      pai = pai.parent;
   }
   return rtn;
};


CsiNestedRect.prototype.stack_vertical = function ()
{
   var cnt = this.children.length;
   var offset = 0;
   var i;
   for(i = 0; i < cnt; ++i)
   {
      var child = this.children[i];
      child.set_top(offset);
      offset += child.get_height();
   }
   this.layout();
};


CsiNestedRect.prototype.stack_horizontal = function ()
{
   var cnt = this.children.length;
   var offset = 0;
   var i;
   for(i = 0; i < cnt; ++i)
   {
      var child = this.children[i];
      child.set_left(offset);
      offset += child.get_width();
   }
   this.layout();
};


CsiNestedRect.prototype.shift_children = function (dx, dy)
{
   var cnt = this.children.length;
   var i;
   for(i = 0; i < cnt; ++i)
   {
      var child = this.children[i];
      child.offset(dx, dy);
   }
};



/* CsiGraphAxis.js

Copyright (C) 2011, 2013 Campbell Scientific, Inc.

Written by: Jon Trauntvein
Date Begun: Tuesday 19 April 2011
Last Change: Tuesday 05 March 2013
Last Commit: $Date: 2013-04-29 13:33:06 -0600 (Mon, 29 Apr 2013) $
Last Changed by: $Author: jon $

*/


/* global CsiGraphXYSeries: true */
/* global CsiNestedRect: true */
/* global CsiScale: true */


////////////////////////////////////////////////////////////
// class CsiGraphAxis
////////////////////////////////////////////////////////////
function CsiGraphAxis(owner, axis_type)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   this.owner = owner;
   this.series = [];
   this.scale = null;
   this.axis_type = axis_type;
   this.time_format = "%c";
   this.title_caption = "";
   this.title_font = "12pt Arial";
   this.title_color = "#000000";
   this.title_angle = 0;
   this.auto_min = true;
   this.min = -1E38;
   this.min_offset = 0;
   this.auto_max = true;
   this.max = 1E38;
   this.max_offset = 0;
   this.auto_time = true;
   this.inverted = false;
   this.logarithmic = false;
   this.log_base = 10;
   this.labels_visible = true;
   this.labels_font = this.title_font;
   this.labels_color = "#000000";
   this.label_angle = 0;
   this.label_size = 0;
   this.auto_label = true;
   this.decimal_places = 0;
   this.fixed_decimals = false;
   this.increment = 0;
   this.minor_tick_count = 3;
   this.major_grid_pen_visible = 1;
   this.major_grid_pen_style = 2;
   this.major_grid_pen_color = "#000000";
   this.major_grid_pen_width = 1;
   this.major_grid_pen_end_style = 0;
   this.major_grid_pen_small_space = 0;
   this.minor_grid_pen_visible = 0;
   this.minor_grid_pen_style = 0;
   this.minor_grid_pen_color = "#000000";
   this.minor_grid_pen_width = 1;
   this.minor_grid_pen_end_style = 0;
   this.minor_grid_pen_small_space = 0;
   this.major_ticks_pen_visible = 1;
   this.major_ticks_pen_style = 0;
   this.major_ticks_pen_color = "#000000";
   this.major_ticks_pen_width = 1;
   this.major_ticks_pen_end_style = 0;
   this.major_ticks_pen_small_space = 0;
   this.minor_ticks_pen_visible = 1;
   this.minor_ticks_pen_style = 0;
   this.minor_ticks_pen_color = "#000000";
   this.minor_ticks_pen_width = 1;
   this.minor_ticks_pen_end_style = 0;
   this.minor_ticks_pen_small_space = 0;
   this.axis_pen_visible = 1;
   this.axis_pen_style = 0;
   this.axis_pen_color = "#000000";
   this.axis_pen_width = 2;
   this.axis_pen_end_style = 0;
   this.axis_pen_small_space = 0;
}


CsiGraphAxis.axis_bottom = 0;
CsiGraphAxis.axis_left = 1;
CsiGraphAxis.axis_right = 2;


CsiGraphAxis.prototype.add_series = function (series)
{
   this.series.push(series);
   if(this.axis_type === CsiGraphAxis.axis_bottom)
   {
      if(series instanceof CsiGraphXYSeries)
      {
         this.time_domain = false;
      }
      else
      {
         this.time_domain = true;
      }
   }
};


CsiGraphAxis.prototype.generate_axis_rect = function (context, space)
{
   // if there are no series associated with this axis, we will return an empty area.
   this.axis_rect = new CsiNestedRect();
   if(this.series.length > 0)
   {
      // we need to initialise the scale if it has not already been created
      if(!this.scale)
      {
         this.scale = new CsiScale();
         if(this.axis_type !== CsiGraphAxis.axis_bottom)
         {
            this.scale.vertical = true;
         }
         this.scale.inverted = this.inverted;
         this.scale.time_domain = this.time_domain;
         this.scale.time_format = this.time_format;
         this.scale.rotation = this.label_angle;
         this.scale.logarithmic = this.logarithmic;
         this.scale.log_base = this.log_base;
         this.scale.fixed_decimals = this.fixed_decimals;
         this.scale.decimal_places = this.decimal_places;
      }
      this.scale.size = space;
      this.scale.time_format = this.time_format;

      // if this axis has a title, we will need to calculate the
      // rectangle associated with the title text.
      this.title_rect = null;
      if(this.title_caption.length > 0)
      {
         context.font = this.title_font;
         this.title_rect = CsiScale.measure_text(this.title_caption, context);
         this.title_rect.rotate(this.title_angle);
      }

      // we now need to evaluate the min and max values for this scale.
      var max_value = -Number.MIN_VALUE, min_value = Number.MAX_VALUE;
      var cnt = this.series.length;
      var i;

      if(!this.auto_min)
      {
         if(this.time_domain && this.auto_time)
         {
            min_value = this.owner.newestTimeStamp - this.owner.displayWidth;
         }
         else
         {
            min_value = this.min;
         }
      }
      if(!this.auto_max)
      {
         if(this.time_domain && this.auto_time)
         {
            max_value = this.owner.newestTimeStamp;
         }
         else
         {
            max_value = this.max;
         }
      }
      for(i = 0; (this.auto_min || this.auto_max) && i < cnt; ++i)
      {
         var series = this.series[i];
         var series_maxima = series.get_bounds(this.axis_type);
         if(this.auto_max)
         {
            max_value = Math.max(series_maxima.max, max_value);
         }

         if(this.auto_min)
         {
            min_value = Math.min(series_maxima.min, min_value);
         }
      }
      if(max_value < min_value)
      {
         min_value = -0.5;
         max_value = 0.5;
      }
      if(this.time_domain && Math.abs(max_value - min_value) < 10)
         max_value = min_value + 10;
      if(!this.time_domain && Math.abs(max_value - min_value) < 0.01 && max_value !== min_value)
         max_value = min_value + 0.01;

      // generate the rectangle for the scale itself
      if(this.scale.vertical)
      {
         var scale_rect_width = 1;
         if(this.axis_pen_visible)
         {
            scale_rect_width += this.axis_pen_width;
         }

         if(this.major_ticks_pen_visible)
         {
            scale_rect_width += 4;
         }
         else if(this.minor_ticks_pen_visible)
         {
            scale_rect_width += 2;
         }
         this.scale_rect = new CsiNestedRect(0, 0, scale_rect_width, space);
      }
      else
      {
         var scale_rect_height = 1;
         if(this.axis_pen_visible)
         {
            scale_rect_height += this.axis_pen_width;
         }

         if(this.major_ticks_pen_visible)
         {
            scale_rect_height += 4;
         }
         else if(this.minor_ticks_pen_visible)
         {
            scale_rect_height += 2;
         }
         this.scale_rect = new CsiNestedRect(0, 0, space, scale_rect_height);
      }

      // for the iphone app, we will automatically adjust the labels based upon the min and max
      if(this.scale.time_domain && this.scale.time_format.length === 0)
      {
         var range = max_value - min_value;
         if(range > CsiLgrDate.msecPerDay)
         {
            this.scale.time_format = "%m-%d %H:%M";
         }
         else if(range > CsiLgrDate.msecPerHour)
         {
            this.scale.time_format = "%H:%M";
         }
         else
         {
            this.scale.time_format = "%H:%M:%S%x";
         }
      }
      
      // if the label interval is specified manually, we will need to
      // calculate the number of labels
      if(this.auto_label)
      {
         this.scale.label_interval = 0;
      }
      else
      {
         this.scale.label_interval = this.increment;
      }

      // we need to adjust the min and max values by the offset properties.
      this.scale.calculate_scale(min_value, max_value, context);
      if(this.min_offset !== 0)
      {
         min_value -= this.scale.value_offset_weight(min_value, this.min_offset);
      }
      if(this.max_offset !== 0)
      {
         max_value += this.scale.value_offset_weight(max_value, this.max_offset);
      }

      // we can now generate the labels
      var labels;
      this.labels_rect = new CsiNestedRect();
      context.font = this.labels_font;
      labels = this.scale.generate_labels(min_value, max_value, context);
      cnt = labels.length;
      for(i = 0; i < cnt; ++i)
      {
         this.labels_rect.add(labels[i].rect);
      }
      if(this.minor_tick_count > 0 &&
         (this.minor_grid_pen_visible || this.minor_ticks_pen_visible) &&
         this.scale.label_interval > 0.001)
      {
         var minor_tick_width = 0;
         if(this.minor_ticks_pen_visible)
         {
            minor_tick_width = this.minor_ticks_pen_width;
         }

         if(this.minor_grid_pen_visible && this.minor_grid_pen_width > minor_tick_width)
         {
            minor_tick_width = this.minor_grid_pen_width;
         }

         if(minor_tick_width > 0)
         {
            var tick_count = this.minor_tick_count;
            if(this.auto_label)
            {
               tick_count = 1e38;
            }
            this.minor_ticks = this.scale.generate_minor_ticks(minor_tick_width * 2, tick_count);
         }
      }
      else
      {
         this.minor_ticks = [];
      }

      // the final thing that we can do is to position the component rectangles within our axis rect
      switch(this.axis_type)
      {
         case CsiGraphAxis.axis_bottom:
            this.axis_rect.add(this.scale_rect);
            if(this.labels_visible)
            {
               this.axis_rect.add(this.labels_rect);
               if(this.labels_rect.get_height() < this.label_size)
               {
                  this.axis_rect.add(
                     new CsiNestedRect(
                        this.labels_rect.left,
                        this.labels_rect.top,
                        this.labels_rect.width,
                        this.label_size - this.labels_rect.height));
               }
            }
            if(this.title_rect)
            {
               this.title_rect.center(space / 2, 0);
               this.axis_rect.add(this.title_rect);
            }
            this.axis_rect.stack_vertical();
            break;

         case CsiGraphAxis.axis_left:
            if(this.title_rect)
            {
               this.title_rect.center(0, space / 2);
               this.axis_rect.add(this.title_rect);
            }

            if(this.labels_visible)
            {
               if(this.labels_rect.get_width() < this.label_size)
               {
                  this.axis_rect.add(
                     new CsiNestedRect(
                        this.labels_rect.left,
                        this.labels_rect.top,
                        this.label_size - this.labels_rect.width,
                        this.labels_rect.height));
               }
               this.axis_rect.add(this.labels_rect);
            }
            this.axis_rect.add(this.scale_rect);
            this.axis_rect.stack_horizontal();
            break;

         case CsiGraphAxis.axis_right:
            this.axis_rect.add(this.scale_rect);
            if(this.labels_visible)
            {
               this.axis_rect.add(this.labels_rect);
               if(this.labels_rect.get_width() < this.label_size)
               {
                  this.axis_rect.add(
                     new CsiNestedRect(
                        this.labels_rect.left,
                        this.labels_rect.top,
                        this.label_size - this.labels_rect.width,
                        this.labels_rect.height));
               }
            }
            if(this.title_rect)
            {
               this.title_rect.center(0, space / 2);
               this.axis_rect.add(this.title_rect);
            }
            this.axis_rect.stack_horizontal();
            break;
      }
   }
   return this.axis_rect;
};


CsiGraphAxis.prototype.get_labels = function ()
{ return this.scale.labels; };


CsiGraphAxis.prototype.draw_title = function (context)
{
   if(this.title_rect)
   {
      var centre = this.title_rect.get_center();
      context.save();
      context.fillStyle = this.title_color;
      context.font = this.title_font;
      context.textAlign = "center";
      context.textBaseline = "middle";
      context.translate(centre.x, centre.y);
      context.rotate(degreesToRadians(this.title_angle));
      context.fillText(this.title_caption, 0, 0);
      context.restore();
   }
};


CsiGraphAxis.prototype.draw_axis = function (context)
{
   if(this.axis_pen_visible)
   {
      // we will get the rectangle for this axis in parent coords
      var rect = this.owner.plotRect;
      var x1, y1;
      var x2, y2;

      switch(this.axis_type)
      {
         case CsiGraphAxis.axis_bottom:
            x1 = rect.left;
            y1 = rect.bottom;
            x2 = rect.right;
            y2 = rect.bottom;
            break;

         case CsiGraphAxis.axis_left:
            x1 = rect.left;
            y1 = rect.top;
            x2 = rect.left;
            y2 = rect.bottom;
            break;

         case CsiGraphAxis.axis_right:
            x1 = rect.right;
            y1 = rect.top;
            x2 = rect.right;
            y2 = rect.bottom;
            break;
      }
      context.lineWidth = this.axis_pen_width;
      context.strokeStyle = this.axis_pen_color;
      Csi.draw_line(context, x1, y1, x2, y2, this.axis_pen_style, [0, 0]);
   }
};


CsiGraphAxis.prototype.draw_labels = function (context)
{
   if(this.labels_visible)
   {
      var labels = this.scale.labels;
      var cnt = labels.length;
      context.fillStyle = this.labels_color;
      context.font = this.labels_font;
      if((this.label_angle % 360) === 0)
      {
         switch(this.axis_type)
         {
            case CsiGraphAxis.axis_bottom:
               context.textAlign = "center";
               context.textBaseline = "top";
               break;

            case CsiGraphAxis.axis_left:
               context.textAlign = "right";
               context.textBaseline = "middle";
               break;

            case CsiGraphAxis.axis_right:
               context.textAlign = "left";
               context.textBaseline = "middle";
               break;
         }
      }
      else
      {
         context.textAlign = "center";
         context.textBaseline = "middle";
      }

      var i;
      for(i = 0; i < cnt; ++i)
      {
         var label = labels[i];
         var rect = label.rect;
         var location = rect.get_center();

         if((this.label_angle % 360) === 0)
         {
            switch(this.axis_type)
            {
               case CsiGraphAxis.axis_bottom:
                  location.y = this.labels_rect.get_top();
                  break;

               case CsiGraphAxis.axis_left:
                  location.x = this.labels_rect.get_right();
                  break;

               case CsiGraphAxis.axis_right:
                  location.x = this.labels_rect.get_left();
                  break;
            }
            context.fillText(label.label, location.x, location.y);
         }
         else
         {
            context.save();
            context.translate(location.x, location.y);
            context.rotate(degreesToRadians(this.label_angle));
            context.fillText(label.label, 0, 0);
            context.restore();
         }
      }
   }
};


CsiGraphAxis.prototype.draw_major_ticks = function (context)
{
   if(this.major_ticks_pen_visible)
   {
      var labels = this.scale.labels;
      var cnt = labels.length;
      context.lineWidth = this.major_ticks_pen_width;
      context.lineCap = "butt";
      context.strokeStyle = this.major_ticks_pen_color;
      var i;
      for(i = 0; i < cnt; ++i)
      {
         var label = labels[i];
         var pos = this.value_to_pos(label.value);
         var x1, y1, x2, y2;
         switch(this.axis_type)
         {
            case CsiGraphAxis.axis_bottom:
               x1 = x2 = pos;
               y1 = this.scale_rect.get_top();
               y2 = this.scale_rect.get_bottom();
               break;

            case CsiGraphAxis.axis_left:
            case CsiGraphAxis.axis_right:
               y1 = y2 = pos;
               x1 = this.scale_rect.get_left();
               x2 = this.scale_rect.get_right();
               break;
         }
         context.beginPath();
         context.moveTo(Math.floor(x1) + 0.5, Math.floor(y1) + 0.5);
         context.lineTo(Math.floor(x2) + 0.5, Math.floor(y2) + 0.5);
         context.stroke();
      }
   }
};


CsiGraphAxis.prototype.draw_minor_ticks = function (context)
{
   var cnt = this.minor_ticks.length;
   if(cnt > 0 && this.minor_ticks_pen_visible)
   {
      context.lineWidth = this.minor_ticks_pen_width;
      context.lineCap = "butt";
      context.strokeStyle = this.minor_ticks_pen_color;
      var i;
      for(i = 0; i < cnt; ++i)
      {
         var tick = this.minor_ticks[i];
         var pos = this.value_to_pos(tick);
         var x1, y1, x2, y2;
         switch(this.axis_type)
         {
            case CsiGraphAxis.axis_bottom:
               x1 = x2 = pos;
               y1 = this.scale_rect.get_top();
               y2 = this.scale_rect.get_top() + 3;
               break;

            case CsiGraphAxis.axis_left:
               y1 = y2 = pos;
               x1 = this.scale_rect.get_right();
               x2 = this.scale_rect.get_right() - 3;
               break;

            case CsiGraphAxis.axis_right:
               y1 = y2 = pos;
               x1 = this.scale_rect.get_left();
               x2 = this.scale_rect.get_left() + 3;
               break;
         }
         context.beginPath();
         context.moveTo(Math.floor(x1) + 0.5, Math.floor(y1) + 0.5);
         context.lineTo(Math.floor(x2) + 0.5, Math.floor(y2) + 0.5);
         context.stroke();
      }
   }
};


CsiGraphAxis.prototype.draw_minor_grid = function (context)
{
   var cnt = this.minor_ticks.length;
   if(cnt > 0 && this.minor_grid_pen_visible)
   {
      var rect = this.owner.plotRect;
      context.lineWidth = this.minor_grid_pen_width;
      context.lineCap = "butt";
      context.strokeStyle = this.minor_grid_pen_color;
      var i;
      for(i = 0; i < cnt; ++i)
      {
         var tick = this.minor_ticks[i];
         var pos = this.value_to_pos(tick);
         var x1, y1, x2, y2;
         switch(this.axis_type)
         {
            case CsiGraphAxis.axis_bottom:
               x1 = x2 = pos;
               y1 = rect.top;
               y2 = rect.bottom;
               break;

            case CsiGraphAxis.axis_left:
            case CsiGraphAxis.axis_right:
               y1 = y2 = pos;
               x1 = rect.left;
               x2 = rect.right;
               break;
         }
         Csi.draw_line(context, x1, y1, x2, y2, this.minor_grid_pen_style);
      }
   }
};


CsiGraphAxis.prototype.draw_grid = function (context)
{
   if(this.major_grid_pen_visible)
   {
      var labels = this.scale.labels;
      var cnt = labels.length;
      var plot_rect = this.owner.plotRect;

      context.lineWidth = this.major_grid_pen_width;
      context.lineCap = "butt";
      context.strokeStyle = this.major_grid_pen_color;
      var i;
      for(i = 0; i < cnt; ++i)
      {
         var label = labels[i];
         var pos = this.value_to_pos(label.value);
         var x1, y1, x2, y2;
         switch(this.axis_type)
         {
            case CsiGraphAxis.axis_bottom:
               x1 = pos;
               y1 = plot_rect.top;
               x2 = pos;
               y2 = plot_rect.bottom;
               break;

            case CsiGraphAxis.axis_left:
            case CsiGraphAxis.axis_right:
               x1 = plot_rect.left;
               y1 = pos;
               x2 = plot_rect.right;
               y2 = pos;
               break;
         }
         Csi.draw_line(context, x1, y1, x2, y2, this.major_grid_pen_style);
      }
   }
};


CsiGraphAxis.prototype.draw = function (context)
{
   if(this.scale)
   {
      this.draw_title(context);
      this.draw_axis(context);
      this.draw_labels(context);
      this.draw_minor_ticks(context);
      this.draw_major_ticks(context);
      this.draw_grid(context);
      this.draw_minor_grid(context);
   }
};


CsiGraphAxis.prototype.value_to_pos = function (value)
{
   var rtn = 0;
   if(this.scale)
   {
      var pos = this.scale.value_to_pos(value);
      switch(this.axis_type)
      {
         case CsiGraphAxis.axis_bottom:
            rtn = this.scale_rect.translate_point(pos, 0).x;
            break;

         case CsiGraphAxis.axis_left:
         case CsiGraphAxis.axis_right:
            rtn = this.scale_rect.translate_point(0, pos).y;
            break;
      }
   }
   return rtn;
};


CsiGraphAxis.prototype.pos_to_value = function (pos)
{
   var rtn = 0;
   if(this.scale)
   {
      var point = 0;
      switch(this.axis_type)
      {
         case CsiGraphAxis.axis_bottom:
            point = this.scale_rect.translate_from_point(pos, 0).x;
            break;

         case CsiGraphAxis.axis_left:
         case CsiGraphAxis.axis_right:
            point = this.scale_rect.translate_from_point(0, pos).y;
            break;
      }
      rtn = this.scale.pos_to_value(point);
   }
   return rtn;
};


CsiGraphAxis.prototype.save_state = function ()
{
   this.saved_min = this.min;
   this.saved_max = this.max;
   this.saved_auto_min = this.auto_min;
   this.saved_auto_max = this.auto_max;
   this.saved_auto_time = this.auto_time;
   this.saved_auto_label = this.auto_label;
   this.saved_increment = this.increment;
   if(this.time_domain)
   {
      this.saved_time_format = this.time_format;
      this.time_format = "";
   }
};


CsiGraphAxis.prototype.restore_state = function ()
{
   this.min = this.saved_min;
   this.max = this.saved_max;
   this.auto_min = this.saved_auto_min;
   this.auto_max = this.saved_auto_max;
   this.auto_time = this.saved_auto_time;
   this.auto_label = this.saved_auto_label;
   this.increment = this.saved_increment;
   if(this.time_domain)
   {
      this.time_format = this.saved_time_format;
   }
};

/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiGradient.js $

Copyright (C) 2010 Campbell Scientific, Inc.
Started On: 10/5/2010 7:51:33 AM
Started By: Kevin Westwood

$LastChangedBy: tmecham $
$LastChangedDate: 2013-03-05 13:06:09 -0700 (Tue, 05 Mar 2013) $
$LastChangedRevision: 17505 $
*/

function CsiGradient(rect)
{
   this.direction = Enum.GRADIENT_DIRECTION.TopBottom;
   this.startColor = "green";
   this.midColor = null;
   this.endColor = "black";
   this.radialOffset = new Point(0, 0);
   this.leftGradient = null;
   this.rightGradient = null;
   this.topGradient = null;
   this.bottomGradient = null;
   this.gradient = null;

   this.reset(rect);
}


CsiGradient.prototype.reset = function (rect)
{
   this.rect = rect;
   this.leftGradient = null;
   this.rightGradient = null;
   this.topGradient = null;
   this.bottomGradient = null;
   this.gradient = null;
};


CsiGradient.prototype.draw = function (context)
{
   var color1;
   var color2;
   var color3;
   var distance;
   var center;

   switch(this.direction)
   {
      case Enum.GRADIENT_DIRECTION.BottomTop:
      case Enum.GRADIENT_DIRECTION.RightLeft:
      case Enum.GRADIENT_DIRECTION.BottomRightTopLeft:
      case Enum.GRADIENT_DIRECTION.TopRightBottomLeft:
      case Enum.GRADIENT_DIRECTION.RectangleIn:
      case Enum.GRADIENT_DIRECTION.CircleIn:
         //swap color so drawing is the same
         color1 = this.endColor;
         color3 = this.startColor;
         break;
      default:
         color1 = this.startColor;
         color3 = this.endColor;
         break;
   }
   color2 = this.midColor;

   if((this.direction === Enum.GRADIENT_DIRECTION.RectangleOut) ||
       (this.direction === Enum.GRADIENT_DIRECTION.RectangleIn))
   {
      //draw from the center out (color1 is center, color3 is sides)
      center = new Point(this.rect.left + this.rect.width / 2, this.rect.top + this.rect.height / 2);

      //overlap gradients so there is not a blank line
      var overlap = 1;

      //left wall
      if(!this.leftGradient) 
      {
         this.leftGradient = context.createLinearGradient(center.x, this.rect.top, this.rect.left, this.rect.top);
         this.leftGradient.addColorStop(0, color1);
         if(color2) 
         {
            this.leftGradient.addColorStop(0.5, color2);
         }
         this.leftGradient.addColorStop(1, color3);
      }
      context.fillStyle = this.leftGradient;
      context.beginPath();
      context.moveTo(center.x + overlap, center.y);
      context.lineTo(this.rect.left, this.rect.top - overlap);
      context.lineTo(this.rect.left, this.rect.bottom + overlap);
      context.fill();

      //right wall
      if(!this.rightGradient) 
      {
         this.rightGradient = context.createLinearGradient(center.x, this.rect.top, this.rect.right, this.rect.top);
         this.rightGradient.addColorStop(0, color1);
         if(color2) 
         {
            this.rightGradient.addColorStop(0.5, color2);
         }
         this.rightGradient.addColorStop(1, color3);
      }
      context.fillStyle = this.rightGradient;
      context.beginPath();
      context.moveTo(center.x - overlap, center.y);
      context.lineTo(this.rect.right, this.rect.top - overlap);
      context.lineTo(this.rect.right, this.rect.bottom + overlap);
      context.fill();

      //top wall
      if(!this.topGradient) 
      {
         this.topGradient = context.createLinearGradient(this.rect.left, center.y, this.rect.left, this.rect.top);
         this.topGradient.addColorStop(0, color1);
         if(color2) 
         {
            this.topGradient.addColorStop(0.5, color2);
         }
         this.topGradient.addColorStop(1, color3);
      }
      context.fillStyle = this.topGradient;
      context.beginPath();
      context.moveTo(center.x, center.y + overlap);
      context.lineTo(this.rect.left - overlap, this.rect.top);
      context.lineTo(this.rect.right + overlap, this.rect.top);
      context.fill();

      //bottom wall
      if(!this.bottomGradient) 
      {
         this.bottomGradient = context.createLinearGradient(this.rect.left, center.y, this.rect.left, this.rect.bottom);
         this.bottomGradient.addColorStop(0, color1);
         if(color2) 
         {
            this.bottomGradient.addColorStop(0.5, color2);
         }
         this.bottomGradient.addColorStop(1, color3);
      }
      context.fillStyle = this.bottomGradient;
      context.beginPath();
      context.moveTo(center.x, center.y - overlap);
      context.lineTo(this.rect.left - overlap, this.rect.bottom);
      context.lineTo(this.rect.right + overlap, this.rect.bottom);
      context.fill();
   }
   else
   {
      if(!this.gradient) 
      {
         switch(this.direction)
         {
            case Enum.GRADIENT_DIRECTION.TopBottom:
            case Enum.GRADIENT_DIRECTION.BottomTop:
               this.gradient = context.createLinearGradient(this.rect.left, this.rect.top, this.rect.left, this.rect.bottom);
               break;
            case Enum.GRADIENT_DIRECTION.LeftRight:
            case Enum.GRADIENT_DIRECTION.RightLeft:
               this.gradient = context.createLinearGradient(this.rect.left, this.rect.top, this.rect.right, this.rect.top);
               break;
            case Enum.GRADIENT_DIRECTION.TopLeftBottomRight:
            case Enum.GRADIENT_DIRECTION.BottomRightTopLeft:
               //The diagonal gradient is not supported in current browsers so we use a radial gradient.
               distance = Math.sqrt(Math.pow(this.rect.right - this.rect.left, 2) + Math.pow(this.rect.bottom - this.rect.top, 2));
               this.gradient = context.createRadialGradient(this.rect.left, this.rect.top, 1, this.rect.left, this.rect.top, distance);
               break;
            case Enum.GRADIENT_DIRECTION.BottomLeftTopRight:
            case Enum.GRADIENT_DIRECTION.TopRightBottomLeft:
               //The diagonal gradient is not supported in current browsers so we use a radial gradient.
               distance = Math.sqrt(Math.pow(this.rect.right - this.rect.left, 2) + Math.pow(this.rect.bottom - this.rect.top, 2));
               this.gradient = context.createRadialGradient(this.rect.left, this.rect.bottom, 1, this.rect.left, this.rect.bottom, distance);
               break;
            case Enum.GRADIENT_DIRECTION.CircleOut:
            case Enum.GRADIENT_DIRECTION.CircleIn:
               center = new Point(this.rect.left + this.rect.width / 2 + this.radialOffset.x, this.rect.top + this.rect.height / 2 + this.radialOffset.y);
               distance = Math.sqrt(Math.pow(center.x - this.rect.left, 2) + Math.pow(center.y - this.rect.bottom, 2));
               this.gradient = context.createRadialGradient(center.x, center.y, 1, center.x, center.y, distance);
               break;
            default:
               break;
         }

         this.gradient.addColorStop(0, color1);
         if(color2) 
         {
            this.gradient.addColorStop(0.5, color2);
         }
         this.gradient.addColorStop(1, color3);
      }

      context.fillStyle = this.gradient;
      context.fillRect(this.rect.left, this.rect.top, this.rect.width, this.rect.height);
   }
};


Enum.GRADIENT_DIRECTION =
{
   TopBottom: 0,
   BottomTop: 1,
   LeftRight: 2,
   RightLeft: 3,
   TopLeftBottomRight: 4,
   BottomRightTopLeft: 5,
   BottomLeftTopRight: 6,
   TopRightBottomLeft: 7,
   RectangleOut: 8,
   RectangleIn: 9,
   CircleOut: 10,
   CircleIn: 11
};/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiImage.js $

Copyright (C) 2010 Campbell Scientific, Inc.
Started On: 10/5/2010 7:51:33 AM
Started By: Kevin Westwood

$LastChangedBy: tmecham $
$LastChangedDate: 2013-03-06 10:52:06 -0700 (Wed, 06 Mar 2013) $
$LastChangedRevision: 17516 $
*/

function CsiImage(owner, filename, rotation, drawStyle, showImageError, refreshInterval)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   this.owner = owner;
   this.filename = filename;
   this.rotation = rotation;
   this.drawStyle = drawStyle;
   this.showImageError = showImageError;
   this.refresh_interval = refreshInterval;

   this.img = null;
   this.cur_loading_idx = 0;
   this.preload_images = new Array(2); //Use 2 images so we always have an image to draw
   this.reload_image();
}


CsiImage.prototype.reload_image = function ()
{
   if(this.filename) 
   {
      this.preload_images[this.cur_loading_idx] = new Image();
      this.preload_images[this.cur_loading_idx].csiImage = this;
      this.preload_images[this.cur_loading_idx].onload = CsiImage.prototype.onload;
      this.preload_images[this.cur_loading_idx].onerror = CsiImage.prototype.onerror;
      this.preload_images[this.cur_loading_idx].onabort = CsiImage.prototype.onerror;
      //Only use nocache option if we will need to refresh the image on an interval
      if(this.refresh_interval === 0)
      {
         this.preload_images[this.cur_loading_idx].src = this.filename;
      }
      else
      {
         this.preload_images[this.cur_loading_idx].src = this.filename + ((this.filename.search('\\?') === -1) ? '?' : '&') + 'nocache=' + ((new Date()).getTime());
      }
   }
};


CsiImage.prototype.onOneShotTimer = function (tag)
{
   if(tag === "ImageUpdate")
   {
      this.reload_image();
   }
};


CsiImage.prototype.onload = function ()
{
   //in this context:
   //this = img
   //this.csiImage.owner = CsiImageComponent or some other object that owns the CsiImage
   this.csiImage.img = this.csiImage.preload_images[this.csiImage.cur_loading_idx];
   this.csiImage.owner.csiImageOnLoad();
   this.csiImage.cur_loading_idx = (this.csiImage.cur_loading_idx + 1) % 2; //Increment the load idx
   this.csiImage.preload_images[this.csiImage.cur_loading_idx] = null; //Clear out the old image

   if(this.csiImage.refresh_interval > 0)
   {
      oneShotTimer.setTimeout(this.csiImage, "ImageUpdate", this.csiImage.refresh_interval);
   }
};


CsiImage.prototype.onerror = function ()
{
   //in this context:
   //this = img
   //this.csiImage.owner = CsiImageComponent or some other object that owns the CsiImage
   this.csiImage.img = null;
   this.csiImage.owner.csiImageOnError();

   if(this.csiImage.refresh_interval > 0)
   {
      oneShotTimer.setTimeout(this.csiImage, "ImageUpdate", this.csiImage.refresh_interval);
   }
};


CsiImage.prototype.draw = function (context, rect)
{
   if(this.img) 
   {
      context.save();
      context.translate(rect.left, rect.top); //move to location
      clipRect(context, 0, 0, rect.width, rect.height);

      if((this.rotation % 360) !== 0)
      {
         var center = new Point(rect.width / 2.0, rect.height / 2.0);
         context.translate(center.x, center.y);
         context.rotate(degreesToRadians(this.rotation));
         context.translate(-center.x, -center.y);
      }

      if(this.drawStyle === Enum.DrawStyleType.stretch)
      {
         context.drawImage(this.img, 0, 0, rect.width, rect.height);
      }
      else if(this.drawStyle === Enum.DrawStyleType.tile)
      {
         var currLeft = 0;
         while(currLeft <= rect.width)
         {
            var currTop = 0;
            while(currTop <= rect.height)
            {
               context.drawImage(this.img, currLeft, currTop);
               currTop += this.img.height;
            }
            currLeft += this.img.width;
         }
      }
      else if(this.drawStyle === Enum.DrawStyleType.center)
      {
         context.drawImage(this.img, (rect.width - this.img.width) / 2.0,
            (rect.height - this.img.height) / 2.0);
      }
      else //Enum.DrawStyleType.best_fit
      {
         var im_w = this.img.width;
         var im_h = this.img.height;
         var comp_w = rect.width;
         var comp_h = rect.height;
         var image_aspect_ratio = 0;
         //Scale the image
         if(im_w < im_h)
         {
            image_aspect_ratio = im_w / im_h;
            im_h = comp_h;
            im_w = im_h * image_aspect_ratio;

            if(im_w > comp_w) //Keep the image inside the comp bounds
            {
               im_w = comp_w;
               im_h = im_w / image_aspect_ratio;
            }
         }
         else
         {
            image_aspect_ratio = im_h / im_w;
            im_w = comp_w;
            im_h = im_w * image_aspect_ratio;

            if(im_h > comp_h) //Keep the image inside the comp bounds
            {
               im_h = comp_h;
               im_w = im_h / image_aspect_ratio;
            }
         }
         var im_x = (rect.width / 2) - (im_w / 2);
         var im_y = (rect.height / 2) - (im_h / 2);
         context.drawImage(this.img, im_x, im_y, im_w, im_h);
      }
      context.restore();
   }
   else if(this.showImageError)
   {
      drawImageError(rect, context);
   }
};
/* CsiGestureTap.js

   Copyright (C) 2013, 2013 Campbell Scientific, Inc.

   Written by: Jon Trauntvein 
   Date Begun: Tuesday 08 January 2013
   Last Change: Friday 11 January 2013
   Last Commit: $Date: 2013-03-05 13:06:09 -0700 (Tue, 05 Mar 2013) $
   Last Changed by: $Author: tmecham $

*/


////////////////////////////////////////////////////////////
// class CsiGestureTap
//
// Defines a class that will recognise a single tap gesture from
// a stream of multitouch events.  
////////////////////////////////////////////////////////////
function CsiGestureTap()
{
   // the page coordinates over which we will respond to touch events
   this.area = new Rect(0, 0, 100, 100);

   // the radius around the first coordinates.  If the touch moves outside this
   // radius, 
   this.tolerance = 50;

   // the object that will receive touch events
   this.client = null;

   // the maximum amount of time between the touch start and the touch end.
   this.interval = 500;

   // controls whether the component should prevent defaults for touch events
   this.prevent_defaults = false;
   
   // records the state of this recognizer
   this.state = CsiGestureTap.state_standby;
   this.first_touch = null;
   this.timer_tag = 0;
   this.move_rect = null;
   if(arguments.length >= 1)
   {
      this.client = arguments[0];
      if(arguments.length >= 2)
      {
         var arg1 = arguments[1]; 
         if(arg1 instanceof Rect)
         {
            this.area = new Rect(arg1);
         }
         if(arguments.length >= 3)
         {
            this.interval = Number(arguments[2]);
         }
      }
   }
}
CsiGestureTap.state_standby = 0;
CsiGestureTap.state_touched = 1;
CsiGestureTap.state_after_end = 2;


CsiGestureTap.prototype.on_touch_start = function(event)
{
   var rtn = (this.state !== CsiGestureTap.state_standby);
   if(this.state === CsiGestureTap.state_standby)
   {
      if(event.touches.length === 1)
      {
         var touch = event.touches[0];
         var touch_point = new Point(touch.pageX, touch.pageY);
         if(this.area.contains(touch_point))
         {
            this.first_touch = touch_point;
            ++this.timer_tag;
            oneShotTimer.setTimeout(this, this.timer_tag, this.interval);
            this.state = CsiGestureTap.state_touched;
            this.move_rect = new Rect(0, 0, this.tolerance, this.tolerance);
            this.move_rect.center(touch_point.x, touch_point.y);
            rtn = true;
            if(this.client && typeof this.client.on_single_tap_start === "function")
            {
               this.client.on_single_tap_start(this);
            }
            if(this.prevent_defaults)
            {
               event.preventDefault();
            }
         }
      }
   }
   else if(this.state === CsiGestureTap.state_touched)
   {
      if(this.client && typeof this.client.on_single_tap_cancelled === "function")
      {
         this.client.on_single_tap_cancelled(this);
      }
      oneShotTimer.clearTimeout(this, this.timer_tag);
      this.state = CsiGestureTap.state_standby;
   }
   return rtn;
};


CsiGestureTap.prototype.on_touch_move = function(event)
{
   var rtn = (this.state !== CsiGestureTap.state_standby);
   if(this.state === CsiGestureTap.state_touched)
   {
      var touch = event.touches[0];
      var touch_point = new Point(touch.pageX, touch.pageY);
      if(this.prevent_defaults)
      {
         event.preventDefault();
      }
      if(!this.move_rect.contains(touch_point))
      {
         if(this.client && typeof this.client.on_single_tap_cancelled === "function")
         {
            this.client.on_single_tap_cancelled(this);
         }
         oneShotTimer.clearTimeout(this, this.timer_tag);
         this.state = CsiGestureTap.state_standby;
      }
   }
   return rtn;
};


CsiGestureTap.prototype.on_touch_end = function(event)
{
   var rtn = (this.state !== CsiGestureTap.state_standby);
   if(this.state === CsiGestureTap.state_touched)
   {
      this.state = CsiGestureTap.state_after_end;
   }
   return rtn;
};


CsiGestureTap.prototype.onOneShotTimer = function(tag)
{
   if(this.timer_tag === tag)
   {
      if(this.state === CsiGestureTap.state_touched)
      {
         if(this.client && typeof this.client.on_single_tap_cancelled === "function")
         {
            this.client.on_single_tap_cancelled(this);
         }
         this.state = CsiGestureTap.state_standby;
      }
      else if(this.state === CsiGestureTap.state_after_end)
      {
         this.state = CsiGestureTap.state_standby;
         if(this.client && typeof this.client.on_single_tap_complete === "function")
         {
            this.client.on_single_tap_complete(this);
         }
      }
   }
};


CsiGestureTap.prototype.get_origin = function()
{
   return new Point(
      this.move_rect.left + this.move_rect.width / 2,
      this.move_rect.top + this.move_rect.height / 2);
};





/* CsiGestureDoubleTap.js

   Copyright (C) 2013, 2013 Campbell Scientific, Inc.

   Written by: Jon Trauntvein 
   Date Begun: Tuesday 08 January 2013
   Last Change: Friday 11 January 2013
   Last Commit: $Date: 2013-03-04 11:56:24 -0700 (Mon, 04 Mar 2013) $
   Last Changed by: $Author: tmecham $

*/


////////////////////////////////////////////////////////////
// class CsiGestureDoubleTap
//
// Defines a class that will recognise a double tap gesture from
// a stream of multitouch events.  
////////////////////////////////////////////////////////////
function CsiGestureDoubleTap()
{
   // the page coordinates over which we will respond to touch events
   this.area = new Rect(0, 0, 100, 100);

   // the radius around the first coordinates.  If the touch moves outside this
   // radius, 
   this.tolerance = 50;

   // the object that will receive touch events
   this.client = null;

   // the maximum amount of time between the touch start and the touch end.
   this.interval = 700;

   // controls whether the component should prevent defaults for touch events
   this.prevent_defaults = false;
   
   // records the state of this recogniser
   this.state = CsiGestureDoubleTap.state_standby;
   this.first_touch = null;
   this.timer_tag = 0;
   this.move_rect = null;
   if(arguments.length >= 1)
   {
      this.client = arguments[0];
      if(arguments.length >= 2)
      {
         var arg1 = arguments[1]; 
         if(arg1 instanceof Rect)
         {
            this.area = new Rect(arg1);
         }
         if(arguments.length >= 3)
         {
            this.interval = Number(arguments[2]);
         }
      }
   }
}
CsiGestureDoubleTap.state_standby = 0;
CsiGestureDoubleTap.state_touched_1 = 1;
CsiGestureDoubleTap.state_released_1 = 2;
CsiGestureDoubleTap.state_touched_2 = 3;


CsiGestureDoubleTap.prototype.on_touch_start = function (event)
{
   var touch;
   var touch_point = null;
   var rtn = this.state !== CsiGestureDoubleTap.state_standby;
   var cancel = false;
   if(this.state === CsiGestureDoubleTap.state_standby)
   {
      if(event.touches.length === 1)
      {
         touch = event.touches[0];
         touch_point = new Point(touch.pageX, touch.pageY);
         if(this.area.contains(touch_point))
         {
            this.first_touch = touch_point;
            ++this.timer_tag;
            oneShotTimer.setTimeout(this, this.timer_tag, this.interval);
            this.state = CsiGestureDoubleTap.state_touched_1;
            this.move_rect = new Rect(0, 0, this.tolerance, this.tolerance);
            this.move_rect.center(touch_point.x, touch_point.y);
            rtn = true;
            csi_log("double tap start first: (" + touch_point.x + "," + touch_point.y + ")");
            if(this.client && typeof this.client.on_double_tap_start === "function")
            {
               this.client.on_double_tap_start(this);
            }
            if(this.prevent_defaults)
            {
               event.preventDefault();
            }
         }
      }
   }
   else if(this.state === CsiGestureDoubleTap.state_touched_1)
   {
      cancel = true;
   }
   else if(this.state === CsiGestureDoubleTap.state_released_1)
   {
      if(event.touches.length === 1)
      {
         touch = event.touches[0];
         touch_point = new Point(touch.pageX, touch.pageY);
         if(this.move_rect.contains(touch_point))
         {
            this.state = CsiGestureDoubleTap.state_touched_2;
            csi_log("double tap start second: (" + touch_point.x + "," + touch_point.y + ")");
            if(this.prevent_defaults)
            {
               event.preventDefault();
            }
         }
         else
         {
            cancel = true;
         }
      }
      else
      {
         cancel = true;
      }
   }
   if(cancel)
   {
      if(this.client && typeof this.client.on_double_tap_cancelled === "function")
      {
         this.client.on_double_tap_cancelled(this);
      }
      oneShotTimer.clearTimeout(this, this.timer_tag);
      this.state = CsiGestureDoubleTap.state_standby;
   }
   return rtn;
};


CsiGestureDoubleTap.prototype.on_touch_move = function(event)
{
   var rtn = this.state !== CsiGestureDoubleTap.state_standby;
   if(this.state === CsiGestureDoubleTap.state_touched_1 ||
      this.state === CsiGestureDoubleTap.state_touched_2)
   {
      var touch = event.touches[0];
      var touch_point = new Point(touch.pageX, touch.pageY);
      if(this.prevent_defaults)
      {
         event.preventDefault();
      }
      if(!this.move_rect.contains(touch_point))
      {
         if(this.client && typeof this.client.on_double_tap_cancelled === "function")
         {
            this.client.on_double_tap_cancelled(this);
         }
         oneShotTimer.clearTimeout(this, this.timer_tag);
         this.state = CsiGestureDoubleTap.state_standby;
      }
   }
   return rtn;
};


CsiGestureDoubleTap.prototype.on_touch_end = function(event)
{
   var rtn = this.state !== CsiGestureDoubleTap.state_standby;
   if(this.state === CsiGestureDoubleTap.state_touched_1)
   {
      if(this.prevent_defaults)
      {
         event.preventDefault();
      }
      this.state = CsiGestureDoubleTap.state_released_1;
   }
   if(this.state === CsiGestureDoubleTap.state_touched_2)
   {
      if(this.prevent_defaults)
      {
         event.preventDefault();
      }
      oneShotTimer.clearTimeout(this, this.timer_tag);
      this.state = CsiGestureDoubleTap.state_standby;
      rtn = false;
      if(this.client && typeof this.client.on_double_tap_complete === "function")
      {
         this.client.on_double_tap_complete(this);
      }
   }
   return rtn;
};


CsiGestureDoubleTap.prototype.onOneShotTimer = function(tag)
{
   if(this.state !== CsiGestureDoubleTap.state_standby && this.timer_tag === tag)
   {
      if(this.client && typeof this.client.on_double_tap_cancelled === "function")
      {
         this.client.on_double_tap_cancelled(this);
      }
      this.state = CsiGestureDoubleTap.state_standby;
   }
};


CsiGestureDoubleTap.prototype.get_origin = function()
{
   return new Point(
      this.move_rect.left + this.move_rect.width / 2,
      this.move_rect.top + this.move_rect.height / 2);
};


/* CsiGestureSwipe.js

   Copyright (C) 2013, 2013 Campbell Scientific, Inc.

   Written by: Jon Trauntvein 
   Date Begun: Tuesday 08 January 2013
   Last Change: Tuesday 05 March 2013
   Last Commit: $Date: 2013-03-05 15:35:08 -0700 (Tue, 05 Mar 2013) $
   Last Changed by: $Author: jon $

*/


////////////////////////////////////////////////////////////
// class CsiGestureSwipe
//
// Defines an object that will recognize a swipe gesture within
// a specified area based upon a stream of touch events.  
////////////////////////////////////////////////////////////
function CsiGestureSwipe()
{
   // the page coordinates over which we will respond to touch events
   this.area = new Rect(0, 0, 100, 100);

   // the object that will receive swipe events
   this.client = null;

   // controls whether the component should prevent defaults for touch events
   this.prevent_defaults = false;

   // initialize members that will maintain the state of this gesture
   this.state = CsiGestureSwipe.state_standby;
   this.origin = null;
   if(arguments.length >= 1)
   {
      this.client = arguments[0];
      if(arguments.length >= 2)
      {
         var arg1 = arguments[1];
         if(arg1 instanceof Rect)
         {
            this.area = new Rect(arg1);
         }
      }
   }
}
CsiGestureSwipe.state_standby = 0;
CsiGestureSwipe.state_touched = 1;
CsiGestureSwipe.state_moving = 2;


CsiGestureSwipe.prototype.on_touch_start = function(event)
{
   var rtn = (this.state !== CsiGestureSwipe.state_standby);
   if(this.state === CsiGestureSwipe.state_standby)
   {
      if(event.touches.length === 1)
      {
         var touch = event.touches[0];
         var touch_point = new Point(touch.pageX, touch.pageY);
         if(this.area.contains(touch_point))
         {
            this.origin = touch_point;
            this.state = CsiGestureSwipe.state_touched;
            rtn = true;
            if(this.client && typeof this.client.on_swipe_start === "function")
            {
               this.client.on_swipe_start(this);
            }
            if(this.prevent_defaults)
            {
               event.preventDefault();
            }
         }
      }
   }
   else
   {
      // any other touch start event when we are already started should reset us to a standby state.
      if(this.client && typeof this.client.on_swipe_cancelled === "function")
      {
         this.client.on_swipe_cancelled(this);
      }
      this.state = CsiGestureSwipe.state_standby;
   }
   return rtn;
};


CsiGestureSwipe.prototype.on_touch_move = function (event)
{
   var rtn = (this.state !== CsiGestureSwipe.state_standby);
   var touch = 0;
   var delta_x = 0;
   var delta_y = 0;
   if(this.state === CsiGestureSwipe.state_touched)
   {
      var move_rect = new Rect(0, 0, this.tolerance, this.tolerance);
      touch = event.touches[0];
      delta_x = touch.pageX - this.origin.x;
      delta_y = touch.pageY - this.origin.y;
      this.state = CsiGestureSwipe.state_moving;
      this.last_touch = new Point(touch.pageX, touch.pageY);
      if(this.client && typeof this.client.on_swipe_moved === "function")
      {
         this.client.on_swipe_moved(this, delta_x, delta_y);
      }
      if(this.prevent_defaults)
      {
         event.preventDefault();
      }
   }
   else if(this.state === CsiGestureSwipe.state_moving)
   {
      touch = event.touches[0];
      delta_x = touch.pageX - this.last_touch.x;
      delta_y = touch.pageY - this.last_touch.y;
      this.last_touch.x = touch.pageX;
      this.last_touch.y = touch.pageY;
      if(this.client && typeof this.client.on_swipe_moved === "function")
      {
         this.client.on_swipe_moved(this, delta_x, delta_y);
      }
      if(this.prevent_defaults)
      {
         event.preventDefault();
      }
   }
   return rtn;
};


CsiGestureSwipe.prototype.on_touch_end = function(event)
{
   var rtn = (this.state !== CsiGestureSwipe.state_standby);
   if(this.state === CsiGestureSwipe.state_touched)
   {
      this.state = CsiGestureSwipe.state_standby;
      if(this.client && typeof this.client.on_swipe_cancelled === "function")
      {
         this.client.on_swipe_cancelled(this);
      }
      if(this.prevent_defaults)
      {
         event.preventDefault();
      }
   }
   else if(this.state === CsiGestureSwipe.state_moving)
   {
      this.state = CsiGestureSwipe.state_standby;
      if(this.client && typeof this.client.on_swipe_complete === "function")
      {
         this.client.on_swipe_complete(this);
      }
      if(this.prevent_defaults)
      {
         event.preventDefault();
      }
   }  
   return rtn;
};


CsiGestureSwipe.prototype.get_origin = function ()
{
   return this.origin;
};


/* CsiGesturePinch.js

   Copyright (C) 2013, 2013 Campbell Scientific, Inc.

   Written by: Jon Trauntvein 
   Date Begun: Tuesday 08 January 2013
   Last Change: Friday 15 February 2013
   Last Commit: $Date: 2013-03-05 13:06:09 -0700 (Tue, 05 Mar 2013) $
   Last Changed by: $Author: tmecham $

*/


////////////////////////////////////////////////////////////
// class CsiGesturePinch
//
// Defines an object that will recognize a pinch gesture from a
// stream of multi-touch events.
////////////////////////////////////////////////////////////
function CsiGesturePinch()
{
   // specifies the page coordinates for which this gesture will be recognized.
   this.area = new Rect(0, 0, 100, 100);

   // specifies the object that will receive event notifications from this gesture.
   this.client = null;

   // specifies whether this gesture should prevent defaults when it touch events.
   this.prevent_defaults = false;

   // set up the state for this gesture
   this.state = CsiGesturePinch.state_standby;
   this.last_distance = NaN;
   this.last_midpoint = null;
   if(arguments.length >= 1)
   {
      this.client = arguments[0];
      if(arguments.length >= 2)
      {
         var arg1 = arguments[1];
         if(arg1 instanceof Rect)
         {
            this.area = new Rect(arg1);
         }
      }
   }
}
CsiGesturePinch.state_standby = 0;
CsiGesturePinch.state_touched = 1;


CsiGesturePinch.prototype.on_touch_start = function(event)
{
   var rtn = (this.state !== CsiGesturePinch.state_standby);
   if(this.state === CsiGesturePinch.state_standby)
   {
      if(event.touches.length === 2)
      {
         var touch0 = event.touches[0];
         var touch1 = event.touches[1];
         if(this.area.contains(new Point(touch0.pageX, touch0.pageY)) &&
            this.area.contains(new Point(touch1.pageX, touch1.pageY)))
         {
            // we need to calculate the distance between the touch points
            var distance_x = touch1.pageX - touch0.pageX;
            var distance_y = touch1.pageY - touch0.pageY;
            this.last_distance = Math.sqrt(
               distance_x * distance_x + distance_y * distance_y);
            this.last_midpoint = new Point(
               (touch0.pageX + touch1.pageX) / 2,
               (touch0.pageY + touch1.pageY) / 2);
            this.state = CsiGesturePinch.state_touched;
            if(this.prevent_defaults)
            {
               event.preventDefault();
            }
            rtn = true;
            if(this.client && typeof this.client.on_pinch_start === "function")
            {
               this.client.on_pinch_start(this);
            }
         }
      }
   }
   else
   {
      this.state = CsiGesturePinch.state_standby;
      if(this.client && typeof this.client.on_pinch_cancelled === "function")
      {
         this.client.on_pinch_cancelled(this);
      }
   }
   return rtn;
};


CsiGesturePinch.prototype.on_touch_move = function(event)
{
   var rtn = (this.state !== CsiGesturePinch.state_standby);
   if(this.state == CsiGesturePinch.state_touched)
   {
      var touch0 = event.touches[0];
      var touch1 = event.touches[1];
      var distance_x = touch1.pageX - touch0.pageX;
      var distance_y = touch1.pageY - touch0.pageY;
      var new_distance = Math.sqrt(
         distance_x * distance_x + distance_y * distance_y);
      var scale = this.last_distance / new_distance;
      var midpoint = new Point(
         (touch0.pageX + touch1.pageX) / 2,
         (touch0.pageY + touch1.pageY) / 2);
      var delta_x = midpoint.x - this.last_midpoint.x;
      var delta_y = midpoint.y - this.last_midpoint.y;
      if(!isNaN(scale))
      {
         this.last_distance = new_distance;
         if(this.client && typeof this.client.on_pinch_moved === "function")
         {
            this.client.on_pinch_moved(this, scale, midpoint, delta_x, delta_y);
         }
         this.last_midpoint = midpoint;
      }
   }
   return rtn;
};


CsiGesturePinch.prototype.on_touch_end = function(event)
{
   var rtn = (this.state !== CsiGesturePinch.state_standby);
   if(this.state == CsiGesturePinch.state_touched)
   {
      this.state  = CsiGesturePinch.state_standby;
      if(this.client && typeof this.client.on_pinch_complete === "function")
      {
         this.client.on_pinch_complete(this);
      }
   }      
   return rtn;
};


/* CsiGraph.js

   Copyright (C) 2011, 2013 Campbell Scientific, Inc.

   Written by: Kevin Westwood
   Date Begun: 15 April 2011
   Last Change: Tuesday 05 March 2013
   Last Commit: $Date: 2013-04-29 13:33:06 -0600 (Mon, 29 Apr 2013) $
   Last Changed by: $Author: jon $

*/

/* global CsiGestureTap: true */
/* global CsiGestureDoubleTap: true */
/* global CsiGestureSwipe: true */
/* global CsiGesturePinch: true */
/* global CsiGraphAxis: true */
/* global CsiNestedRect: true */
/* global drawDashedLine: true */
/* global measureText: true */
/* global CsiGraphSeries: true */
/* global CsiGraphScopeSeries: true */
/* global CsiGraphXYSeries: true */
/* global CsiGradient: true */


function CsiGraph(left, top, width, height)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   CsiComponent.call(this, left, top, width, height);

   //rtmc props
   this.background_transparent = false;
   this.background_color = "#C0C0C0";
   this.background_gradient = new CsiGradient();
   this.graphWidth = 60000; //How much data to get
   this.displayWidth = 60000; //How much data to show
   this.fill_and_clear = false;
   this.real_time = false;
   this.image_name = "";
   this.title = "Text";
   this.title_font = "12pt Arial";
   this.restore_btn_font = "10pt Arial";
   this.title_font_color = "#000000";
   this.show_legend = true;
   this.image_name = "";
   this.inside_graph = 0;
   this.image_style = 0;
   this.image_visible = 0;
   this.use_pc_time = false;
   this.legend_visible = 1;
   this.legend_transparent = 0;
   this.legend_back_color = "#FFFFFF";
   this.legend_shadow_color = "#000000";
   this.legend_position = 1;
   this.legend_position_offset = 10;
   this.legend_gradient = new CsiGradient();
   this.legend_font = "12pt Arial";
   this.legend_font_color = "#000000";
   this.enable_3d = 0;
   this.percent_3d = 15;
   this.rotation = 345;
   this.elevation = 345;
   this.orthogonal = 1;
   this.ortho_angle = 45;
   this.plot_area_transparent = false;
   this.plot_area_color = "#FFFFFF";
   this.plot_area_gradient = new CsiGradient();
   this.backgroundCsiImage = null;
   this.plotAreaCsiImage = null;
   this.plot_border_visible = 1;
   this.plot_border_style = 0;
   this.plot_border_color = "#000000";
   this.plot_border_width = 1;

   //misc
   this.bottomAxis = new CsiGraphAxis(this, CsiGraphAxis.axis_bottom);
   this.leftAxis = new CsiGraphAxis(this, CsiGraphAxis.axis_left);
   this.rightAxis = new CsiGraphAxis(this, CsiGraphAxis.axis_right);
   this.seriesarray = [];
   this.newestTimeStamp = 0;
   this.margin = 15;
   this.bar_count = 0;

   //cached positions
   this.positionsInvalid = true;
   this.legendBoxWidth = 0;
   this.legendBoxHeight = 0;
   this.legendMargin = 0;
   this.legendSpacing = 2;
   this.legendRect = null;
   this.plotRect = null;
   this.backgroundRect = new Rect(0, 0, this.width, this.height);
   this.legendColumnCount = 1;
   this.legendRowCount = 1;
   this.widthForSeries = 0;

   //zoom/pan
   this.needs_mouse_events = true;
   this.zoomRect = new Rect();
   this.zoomOrigin = new Point(0, 0);
   this.zooming = false;
   this.left_down = false;
   this.right_down = false;
   this.show_restore_btn = false;
   this.show_zoom_btn = false;
   this.button_rect = null;

   // gesture parsers
   this.double_zoom_gesture = new CsiGestureDoubleTap(
      this,
      this.translate_page(
         new Rect(left, top, width, height)));
   this.double_zoom_gesture.prevent_defaults = true;
   this.pan_gesture = new CsiGestureSwipe(
      this,
      this.translate_page(
         new Rect(left, top, width, height)));
   this.pan_gesture.prevent_defaults = true;
   this.marks_gesture = new CsiGestureTap(
      this,
      this.translate_page(
         new Rect(left, top, width, height)));
   this.pinch_gesture = new CsiGesturePinch(
      this,
      this.translate_page(
         new Rect(left, top, width, height)));
   this.pinch_gesture.prevent_defaults = true;
   this.restore_gesture = null;
}
CsiGraph.prototype = new CsiComponent();


CsiGraph.prototype.getBadData = function ()
{
   var len = this.seriesarray.length;
   var i;
   for(i = 0; i < len; i++)
   {
      if(this.seriesarray[i].bad_data)
      {
         return true;
      }
   }
   return false;
};


CsiGraph.prototype.clear_data = function (series)
{
   this.bottomAxis.auto_time = false;
   this.bottomAxis.auto_max = false;
   this.bottomAxis.auto_min = false;
   this.bottomAxis.min = this.newestTimeStamp;
   this.bottomAxis.max = this.newestTimeStamp + this.graphWidth;
   var len = this.seriesarray.length;
   var i;
   for(i = 0; i < len; i++)
   {
      if(series !== this.seriesarray[i])
      {
         this.seriesarray[i].data = [];
      }
      else
      {
         series.data.splice(0, series.data.length - 2); //Leave the newest value in the trace since it was never displayed
      }
   }

   this.positionsInvalid = true;
};


CsiGraph.prototype.getNanData = function ()
{
   return false;
};


CsiGraph.prototype.csiImageOnLoad = function ()
{
   this.ready = true;
   this.invalidate();
};


CsiGraph.prototype.csiImageOnError = function ()
{
   this.ready = true;
   this.invalidate();
};


CsiGraph.prototype.draw = function (context)
{
   if(this.positionsInvalid)
   {
      this.calculatePositions(context);
      this.positionsInvalid = false;
   }

   context.save();
   context.translate(this.left, this.top); //move to location
   clipRect(context, 0, 0, this.width, this.height);

   this.drawBackground(context);
   this.drawTitle(context);
   this.drawLegend(context);
   this.drawPlotArea(context);
   this.drawBorder(context, new Rect(0, 0, this.width, this.height));
   this.drawMarks(context);

   if(this.show_restore_btn || this.show_zoom_btn)
   {
      this.draw_button(context);
   }

   context.restore();
};


CsiGraph.prototype.calculatePositions = function (context)
{
   this.background_gradient.reset(new Rect(0, 0, this.width, this.height));

   var titleBottom = this.margin;
   if(this.title && this.title.length > 0)
   {
      context.font = this.title_font;
      titleBottom += context.measureText("W").width; //assume height("W") == width("W");
   }

   //calculate legendRect and plotRect
   if(this.legend_visible)
   {
      //legend position
      context.font = this.legend_font;
      var maxSeriesWidth = this.getMaxSeriesNameWidth(context);
      this.legendBoxHeight = Math.ceil(context.measureText("W").width * 1.1);
      this.legendBoxWidth = Math.ceil(this.legendBoxHeight * 1.2);
      this.legendMargin = 5;
      this.legendSpacing = 2;
      this.widthForSeries = Math.ceil(this.legendMargin + this.legendBoxWidth + this.legendMargin + maxSeriesWidth);

      switch(this.legend_position)
      {
         case Enum.LEGEND_ALIGNMENT.LEFT:
            this.legendRowCount = this.seriesarray.length;
            this.legendRect = new Rect(
               this.margin,
               this.margin + (this.height - this.margin * 2) * (this.legend_position_offset / 100),
               this.widthForSeries + this.legendMargin,
               this.legendBoxHeight * this.legendRowCount + this.legendSpacing * (this.legendRowCount - 1) + this.legendMargin * 2);
            this.plotRect = new Rect(
               this.legendRect.right + this.margin,
               titleBottom,
               this.width - this.legendRect.width - this.margin * 3,
               this.height - titleBottom - this.margin);
            break;
         case Enum.LEGEND_ALIGNMENT.RIGHT:
            this.legendRowCount = this.seriesarray.length;
            this.legendRect = new Rect(
               this.width - this.margin - this.widthForSeries - this.legendMargin,
               this.margin + (this.height - this.margin * 2) * (this.legend_position_offset / 100),
               this.widthForSeries + this.legendMargin,
               this.legendBoxHeight * this.legendRowCount + this.legendSpacing * (this.legendRowCount - 1) + this.legendMargin * 2);
            this.plotRect = new Rect(
               this.margin,
               titleBottom,
               this.width - this.legendRect.width - this.margin * 3,
               this.height - titleBottom - this.margin);
            break;
         case Enum.LEGEND_ALIGNMENT.TOP:
            this.createHorizontalLegendRect();
            this.legendRect.top = titleBottom;
            this.legendRect.updateBottom();
            this.legendRect.left = this.margin + (this.width - this.legendRect.width - this.margin * 2) * ((50 + this.legend_position_offset) / 100);
            this.legendRect.updateRight();
            this.plotRect = new Rect(
               this.margin,
               this.legendRect.bottom + this.margin,
               this.width - this.margin * 2,
               this.height - this.legendRect.bottom - this.margin * 2);
            break;
         case Enum.LEGEND_ALIGNMENT.BOTTOM:
            this.createHorizontalLegendRect();
            this.legendRect.top = this.height - this.margin - this.legendRect.height;
            this.legendRect.updateBottom();
            this.legendRect.left = this.margin + (this.width - this.legendRect.width - this.margin * 2) * ((50 + this.legend_position_offset) / 100);
            this.legendRect.updateRight();
            this.plotRect = new Rect(
               this.margin,
               titleBottom,
               this.width - this.margin * 2,
               this.legendRect.top - titleBottom - this.margin * 2);
            break;
      }
      this.legendRect.adjustForLines();
      this.legend_gradient.reset(this.legendRect);
   }
   else
   {
      this.legendRect = null;
      this.plotRect = new Rect(
         this.margin,
         titleBottom,
         this.width - this.margin * 2,
         this.height - titleBottom - this.margin * 2);
   }

   // the axes need to adjust the plot rectangle in order to account
   // for the space required by their labels.  There is a mutual
   // dependency between the height of the bottom axis and the width
   // of the left and right axes that makes this less than simple.
   var bottom_axis_rect = this.bottomAxis.generate_axis_rect(
      context, this.plotRect.width);
   var left_axis_rect = this.leftAxis.generate_axis_rect(
      context, this.plotRect.height - bottom_axis_rect.get_height());
   var right_axis_rect = this.rightAxis.generate_axis_rect(
      context, this.plotRect.height - bottom_axis_rect.get_height());

   if(this.bottomAxis.get_labels().length > 0)
   {
      var first_label = this.bottomAxis.get_labels()[0];
      var half_label_width = first_label.rect.get_width() / 2;
      var left_wprime = this.plotRect.left + left_axis_rect.width;
      var right_wprime = (this.width - this.plotRect.right) + right_axis_rect.width;

      var half_label_rect = null;
      if(half_label_width > left_wprime)
      {
         half_label_rect = new CsiNestedRect(0, 0, half_label_width - left_wprime, 2);
         left_axis_rect.shift_children(half_label_width - left_wprime, 0);
         left_axis_rect.add(half_label_rect);
      }
      if(half_label_width > right_wprime)
      {
         half_label_rect = new CsiNestedRect(0, 0, half_label_width - right_wprime, 2);
         right_axis_rect.add(half_label_rect);
      }
   }
   this.plotRect.set_height(this.plotRect.height - bottom_axis_rect.get_height());
   this.plotRect.set_width(
      this.plotRect.width - (left_axis_rect.get_width() + right_axis_rect.get_width()));
   this.plotRect.offset(left_axis_rect.width, 0);
   bottom_axis_rect = this.bottomAxis.generate_axis_rect(
      context, this.plotRect.width);
   bottom_axis_rect.move(this.plotRect.left, this.plotRect.bottom);
   left_axis_rect.set_right(this.plotRect.left);
   left_axis_rect.set_top(this.plotRect.top);
   right_axis_rect.set_left(this.plotRect.right);
   right_axis_rect.set_top(this.plotRect.top);
   this.plot_area_gradient.reset(this.plotRect);
   this.double_zoom_gesture.area = this.translate_page(this.plotRect);
   this.double_zoom_gesture.area.offset(this.left, this.top);
   this.pan_gesture.area = this.translate_page(this.plotRect);
   this.pan_gesture.area.offset(this.left, this.top);
   this.marks_gesture.area = this.translate_page(this.plotRect);
   this.marks_gesture.area.offset(this.left, this.top);
   this.pinch_gesture.area = this.translate_page(this.plotRect);
   this.pinch_gesture.area.offset(this.left, this.top);
};


CsiGraph.prototype.createHorizontalLegendRect = function ()
{
   this.legendRect = new Rect();

   //rect width
   var maxWidth = this.width - this.margin * 2 - this.legendMargin; //remove legendMargin for right side
   this.legendColumnCount = Math.min(Math.floor(maxWidth / this.widthForSeries), this.seriesarray.length); //how many across
   this.legendRect.width = this.legendColumnCount * this.widthForSeries + this.legendMargin;

   //center horizontally
   this.legendRect.left = (this.width - this.legendRect.width) / 2;
   this.legendRect.updateRight();

   //rect height
   this.legendRowCount = Math.ceil(this.seriesarray.length / this.legendColumnCount);
   this.legendRect.height = this.legendMargin +
                            this.legendBoxHeight * this.legendRowCount +
                            this.legendSpacing * (this.legendRowCount - 1) +
                            this.legendMargin;
   this.legendRect.updateBottom();
};


CsiGraph.prototype.getMaxSeriesNameWidth = function (context)
{
   var result = 0;
   var len = this.seriesarray.length;
   var i;
   for(i = 0; i < len; i++)
   {
      var temp = context.measureText(this.seriesarray[i].label).width;
      result = Math.max(result, temp);
   }

   return result;
};


CsiGraph.prototype.drawBackground = function (context)
{
   if(!this.background_transparent)
   {
      if(this.background_gradient.visible)
      {
         this.background_gradient.draw(context);
      }
      else
      {
         context.fillStyle = this.background_color;
         context.fillRect(0, 0, this.width, this.height);
      }
   }

   if(this.backgroundCsiImage)
   {
      this.backgroundCsiImage.draw(context, this.backgroundRect, 0, this.imageDrawStyle);
   }
};


CsiGraph.prototype.drawTitle = function (context)
{
   if(this.title !== "")
   {
      context.fillStyle = this.title_font_color;
      context.textAlign = "center";
      context.textBaseline = "middle";
      context.font = this.title_font;
      context.fillText(this.title, this.plotRect.left + this.plotRect.width / 2, this.margin);
   }
};


CsiGraph.prototype.drawLegend = function (context)
{
   if(this.legend_visible)
   {
      if(!this.legend_transparent)
      {
         this.drawLegendBackground(context);
      }
      this.drawLegendSeries(context);
   }
};


CsiGraph.prototype.drawLegendBackground = function (context)
{
   //draw shadow
   context.save(); //must save so we can reset the shadow props.
   context.shadowOffsetX = 3;
   context.shadowOffsetY = 3;
   context.shadowBlur = 5;
   context.shadowColor = this.legend_shadow_color;
   context.beginPath();
   context.rect(this.legendRect.left, this.legendRect.top, this.legendRect.width, this.legendRect.height);
   context.closePath();
   context.strokeStyle = this.legend_shadow_color;
   context.stroke();
   context.restore();

   if(this.legend_gradient.visible)
   {
      this.legend_gradient.draw(context);

      //draw border
      context.beginPath();
      context.rect(this.legendRect.left, this.legendRect.top, this.legendRect.width, this.legendRect.height);
      context.closePath();
      context.strokeStyle = "#000000";
      context.stroke();
   }
   else
   {
      //fill with background color and draw border
      context.beginPath();
      context.rect(this.legendRect.left, this.legendRect.top, this.legendRect.width, this.legendRect.height);
      context.closePath();
      context.fillStyle = this.legend_back_color;
      context.fill();
      context.strokeStyle = "#000000";
      context.stroke();
   }
};


CsiGraph.prototype.drawLegendSeries = function (context)
{
   context.textAlign = "left";
   context.textBaseline = "middle";
   context.font = this.legend_font;

   var seriesLen = this.seriesarray.length;
   var seriesI = -1;

   var graphicRect = new Rect(0, this.legendRect.top + this.legendMargin, this.legendBoxWidth, this.legendBoxHeight);
   graphicRect.adjustForLines();
   var row, col;
   for(row = 0; row < this.legendRowCount; row++)
   {
      for(col = 0; col < this.legendColumnCount; col++)
      {
         seriesI++;
         if(seriesI === seriesLen)
         {
            return;
         }

         graphicRect.left = this.legendRect.left + col * this.widthForSeries + this.legendMargin;
         graphicRect.updateRight();

         this.seriesarray[seriesI].drawLegendGraphic(context, graphicRect);
         context.fillStyle = this.legend_font_color;
         context.fillText(this.seriesarray[seriesI].label, graphicRect.right + this.legendMargin, graphicRect.top + this.legendBoxHeight / 2);
      }

      graphicRect.top = graphicRect.bottom + this.legendSpacing;
      graphicRect.updateBottom();
   }
};

CsiGraph.prototype.drawPlotArea = function (context)
{
   context.save();
   //draw plot area background
   this.drawPlotAreaBackground(context);

   //draw axis labels and ticks
   this.bottomAxis.draw(context);
   this.leftAxis.draw(context);
   this.rightAxis.draw(context);

   //draw series
   clipRect(context, this.plotRect.left, this.plotRect.top, this.plotRect.width, this.plotRect.height);
   var len = this.seriesarray.length;
   var i;
   for(i = 0; i < len; i++)
   {
      this.seriesarray[i].draw(context);
   }
   context.restore();

   if(this.zooming)
   {
      context.save();
      context.lineWidth = 3;
      context.strokeStyle = "RGBA(64, 64, 64, 0.55)";
      context.strokeRect(this.zoomRect.left, this.zoomRect.top, this.zoomRect.width, this.zoomRect.height);
      context.restore();
   }
};


CsiGraph.prototype.drawPlotAreaBackground = function (context)
{
   if(!this.plot_area_transparent)
   {
      if(this.plot_area_gradient.visible)
      {
         this.plot_area_gradient.draw(context);
      }
      else
      {
         //fill background
         context.beginPath();
         context.rect(this.plotRect.left, this.plotRect.top, this.plotRect.width, this.plotRect.height);
         context.closePath();
         context.fillStyle = this.plot_area_color;
         context.fill();
      }
   }

   //draw image
   if(this.plotAreaCsiImage)
   {
      this.plotAreaCsiImage.draw(context, this.plotRect, 0, this.imageDrawStyle);
   }

   //draw border?
   if(this.plot_border_visible && this.plot_border_style !== Enum.LINE_TYPE.CLEAR && this.plot_border_style !== Enum.LINE_TYPE.IGNORE)
   {
      var previous = [0, 0];
      context.strokeStyle = this.plot_border_color;
      context.lineWidth = this.plot_border_width;
      context.beginPath();
      switch(this.plot_border_style)
      {
         case Enum.LINE_TYPE.SOLID:
            context.strokeRect(this.plotRect.left, this.plotRect.top, this.plotRect.width, this.plotRect.height);
            break;
         case Enum.LINE_TYPE.DASH:
            drawDashedLine(context, this.plotRect.left, this.plotRect.top, this.plotRect.right, this.plotRect.top, Csi.dash_pattern, previous);
            drawDashedLine(context, this.plotRect.right, this.plotRect.top, this.plotRect.right, this.plotRect.bottom, Csi.dash_pattern, previous);
            drawDashedLine(context, this.plotRect.left, this.plotRect.bottom, this.plotRect.right, this.plotRect.bottom, Csi.dash_pattern, previous);
            drawDashedLine(context, this.plotRect.left, this.plotRect.bottom, this.plotRect.left, this.plotRect.top, Csi.dash_pattern, previous);
            break;
         case Enum.LINE_TYPE.DOT:
            drawDashedLine(context, this.plotRect.left, this.plotRect.top, this.plotRect.right, this.plotRect.top, Csi.dot_pattern, previous);
            drawDashedLine(context, this.plotRect.right, this.plotRect.top, this.plotRect.right, this.plotRect.bottom, Csi.dot_pattern, previous);
            drawDashedLine(context, this.plotRect.left, this.plotRect.bottom, this.plotRect.right, this.plotRect.bottom, Csi.dot_pattern, previous);
            drawDashedLine(context, this.plotRect.left, this.plotRect.bottom, this.plotRect.left, this.plotRect.top, Csi.dot_pattern, previous);
            break;
         case Enum.LINE_TYPE.DASHDOT:
            drawDashedLine(context, this.plotRect.left, this.plotRect.top, this.plotRect.right, this.plotRect.top, Csi.dash_dot_pattern, previous);
            drawDashedLine(context, this.plotRect.right, this.plotRect.top, this.plotRect.right, this.plotRect.bottom, Csi.dash_dot_pattern, previous);
            drawDashedLine(context, this.plotRect.left, this.plotRect.bottom, this.plotRect.right, this.plotRect.bottom, Csi.dash_dot_pattern, previous);
            drawDashedLine(context, this.plotRect.left, this.plotRect.bottom, this.plotRect.left, this.plotRect.top, Csi.dash_dot_pattern, previous);
            break;
         case Enum.LINE_TYPE.DASHDOTDOT:
            drawDashedLine(context, this.plotRect.left, this.plotRect.top, this.plotRect.right, this.plotRect.top, Csi.dash_dot_dot_pattern, previous);
            drawDashedLine(context, this.plotRect.right, this.plotRect.top, this.plotRect.right, this.plotRect.bottom, Csi.dash_dot_dot_pattern, previous);
            drawDashedLine(context, this.plotRect.left, this.plotRect.bottom, this.plotRect.right, this.plotRect.bottom, Csi.dash_dot_dot_pattern, previous);
            drawDashedLine(context, this.plotRect.left, this.plotRect.bottom, this.plotRect.left, this.plotRect.top, Csi.dash_dot_dot_pattern, previous);
            break;
         //case Enum.LINE_TYPE.SMALLDOTS: 
         default:
            drawDashedLine(context, this.plotRect.left, this.plotRect.top, this.plotRect.right, this.plotRect.top, Csi.small_dot_pattern, previous);
            drawDashedLine(context, this.plotRect.right, this.plotRect.top, this.plotRect.right, this.plotRect.bottom, Csi.small_dot_pattern, previous);
            drawDashedLine(context, this.plotRect.left, this.plotRect.bottom, this.plotRect.right, this.plotRect.bottom, Csi.small_dot_pattern, previous);
            drawDashedLine(context, this.plotRect.left, this.plotRect.bottom, this.plotRect.left, this.plotRect.top, Csi.small_dot_pattern, previous);
            break;
      }
      context.stroke();
   }
};


var restore_btn_text = "Restore";
var zoom_btn_text = "Zoom/Pan";
CsiGraph.prototype.draw_button = function (context)
{
   var btn_text = "";
   if(this.show_restore_btn)
   {
      btn_text = restore_btn_text;
   }
   else if(this.show_zoom_btn)
   {
      btn_text = zoom_btn_text;
   }

   context.save();
   context.textAlign = "center";
   context.textBaseline = "middle";
   context.font = this.restore_btn_font;

   if(!this.button_rect)
   {
      var size = measureText(context, zoom_btn_text); //Measure zoom_btn_text since it is longest
      this.button_rect = new Rect(5, 5, size.width + 12, size.height + 12);
   }

   context.fillStyle = "#CCCCCC";
   context.fillRect(5, 5, this.button_rect.width, this.button_rect.height);

   context.fillStyle = "#000000";
   context.fillText(btn_text, 5 + this.button_rect.width / 2.0, 5 + this.button_rect.height / 2.0);

   context.strokeStyle = "RGBA(85,85,85,.5)";
   context.lineWidth = 2;
   context.strokeRect(5, 5, this.button_rect.width, this.button_rect.height);
   context.restore();
   if(!this.restore_gesture)
   {
      this.restore_gesture = new CsiGestureTap(
         this, this.translate_page(this.restoreBtnRect));
      this.restore_gesture.area.offset(this.left, this.top);
      csiMouseEvents.register_gesture(this.restore_gesture, 0);
   }
};


CsiGraph.prototype.drawMarks = function (context)
{
   var len = this.seriesarray.length;
   var i;
   for(i = 0; i < len; i++)
   {
      this.seriesarray[i].draw_marks(context);
   }
};


CsiGraph.prototype.createSeries = function (expression, axis)
{
   var series = new CsiGraphSeries(expression, this, axis);
   this.seriesarray.push(series);
   return series;
};


CsiGraph.prototype.createScopeSeries = function (expression, axis)
{
   var series = new CsiGraphScopeSeries(expression, this, axis);
   this.seriesarray.push(series);
   return series;
};


CsiGraph.prototype.createXYSeries = function (expressionY, expressionX, axis)
{
   var series = new CsiGraphXYSeries(expressionY, expressionX, this, axis);
   this.seriesarray.push(series);
   return series;
};


CsiGraph.prototype.OnLButtonDown = function (mouseX, mouseY)
{
   var local_x = mouseX - this.left;
   var local_y = mouseY - this.top;

   //Don't start zooming unless we are inside the plot area
   if(this.plotRect.contains(new Point(local_x, local_y)))
   {
      this.left_down = true;
      this.zoomRect = new Rect(local_x, local_y, 0, 0);
      this.zoomOrigin.x = local_x;
      this.zoomOrigin.y = local_y;
   }

   var len = this.seriesarray.length;
   var i;
   for(i = 0; i < len; i++)
   {
      if(this.seriesarray[i].marks_enabled && this.seriesarray[i].marks_show_on_click)
      {
         this.seriesarray[i].current_mark = null;
         this.invalidate();
      }
   }

   return this.left_down; //prevent default behavior
};


CsiGraph.prototype.OnRButtonDown = function (mouseX, mouseY)
{
   var local_x = mouseX - this.left;
   var local_y = mouseY - this.top;

   //Don't start zooming unless we are inside the plot area
   if(this.plotRect.contains(new Point(local_x, local_y)))
   {
      this.right_down = true;
      this.zoomOrigin.x = local_x;
      this.zoomOrigin.y = local_y;
      if(this.leftAxis.scale)
      {
         this.left_pan_max = this.leftAxis.scale.get_max_value();
         this.left_pan_min = this.leftAxis.scale.get_min_value();
      }

      if(this.rightAxis.scale)
      {
         this.right_pan_max = this.rightAxis.scale.get_max_value();
         this.right_pan_min = this.rightAxis.scale.get_min_value();
      }

      if(this.bottomAxis.scale)
      {
         this.bottom_pan_max = this.bottomAxis.scale.get_max_value();
         this.bottom_pan_min = this.bottomAxis.scale.get_min_value();
      }
   }

   var len = this.seriesarray.length;
   var i;
   for(i = 0; i < len; i++)
   {
      if(this.seriesarray[i].marks_enabled && this.seriesarray[i].marks_show_on_click)
      {
         this.seriesarray[i].current_mark = null;
         this.invalidate();
      }
   }
};


CsiGraph.prototype.OnMouseMove = function (mouseX, mouseY)
{
   var local_x = mouseX - this.left;
   var local_y = mouseY - this.top;

   if(this.left_down)
   {
      //Draw the zoom rect
      this.zooming = true;
      this.zoomRect.set_drag_point(local_x, local_y, this.zoomOrigin.x, this.zoomOrigin.y);
      this.refresh();
      return true; //Prevent default behavior
   }
   else if(this.right_down)
   {
      if(!this.show_restore_btn)
      {
         this.show_restore_btn = true;
         this.SaveState();
      }
      this.panning = true;

      //Calculate our offset from the zoomOrigin and set scales accordingly
      if(this.leftAxis.scale)
      {
         var left_pan_origin_y = this.leftAxis.pos_to_value(this.zoomOrigin.y);
         var left_pan_y = this.leftAxis.pos_to_value(local_y);
         var left_diff = left_pan_origin_y - left_pan_y;
         this.leftAxis.auto_max = false;
         this.leftAxis.auto_min = false;
         this.leftAxis.max = this.left_pan_max + left_diff;
         this.leftAxis.min = this.left_pan_min + left_diff;
         this.leftAxis.auto_label = true;
      }

      if(this.rightAxis.scale)
      {
         var right_pan_origin_y = this.rightAxis.pos_to_value(this.zoomOrigin.y);
         var right_pan_y = this.rightAxis.pos_to_value(local_y);
         var right_diff = right_pan_origin_y - right_pan_y;
         this.rightAxis.auto_max = false;
         this.rightAxis.auto_min = false;
         this.rightAxis.max = this.right_pan_max + right_diff;
         this.rightAxis.min = this.right_pan_min + right_diff;
         this.rightAxis.auto_label = true;
      }

      if(this.bottomAxis.scale)
      {
         var bottom_pan_origin_x = this.bottomAxis.pos_to_value(this.zoomOrigin.x);
         var bottom_pan_x = this.bottomAxis.pos_to_value(local_x);
         var bottom_diff = bottom_pan_origin_x - bottom_pan_x;
         this.bottomAxis.auto_time = false;
         this.bottomAxis.auto_min = this.bottomAxis.auto_max = false;
         this.bottomAxis.max = this.bottom_pan_max + bottom_diff;
         this.bottomAxis.min = this.bottom_pan_min + bottom_diff;
         this.bottomAxis.auto_label = true;
      }

      //Force graph to recalculate scales
      this.positionsInvalid = true;
      this.refresh();
   }
   return false; //Don't override default behavior
};


CsiGraph.prototype.OnLButtonUp = function (mouseX, mouseY)
{
   var local_x = mouseX - this.left;
   var local_y = mouseY - this.top;

   if(this.zooming && (local_x !== this.zoomOrigin.x && local_y !== this.zoomOrigin.y))
   {

      if(!this.show_restore_btn)
      {
         //Only do this on the first zoom
         this.show_restore_btn = true;
         this.SaveState();
      }
      else
      {
         //Drag from bottom right to upper left undoes zoom
         if(this.zoomOrigin.x > local_x && this.zoomOrigin.y > local_y)
         {
            this.left_down = false;
            this.zooming = false;
            this.RestoreState();
            return;
         }
      }

      //Set the scales according to the zoom rect
      this.leftAxis.auto_label = true;
      this.leftAxis.auto_max = false;
      this.leftAxis.auto_min = false;
      if(this.leftAxis.inverted)
      {
         this.leftAxis.max = this.leftAxis.pos_to_value(this.zoomRect.bottom);
         this.leftAxis.min = this.leftAxis.pos_to_value(this.zoomRect.top);
      }
      else
      {
         this.leftAxis.max = this.leftAxis.pos_to_value(this.zoomRect.top);
         this.leftAxis.min = this.leftAxis.pos_to_value(this.zoomRect.bottom);
      }

      this.rightAxis.auto_label = true;
      this.rightAxis.auto_max = false;
      this.rightAxis.auto_min = false;
      if(this.rightAxis.inverted)
      {
         this.rightAxis.max = this.rightAxis.pos_to_value(this.zoomRect.bottom);
         this.rightAxis.min = this.rightAxis.pos_to_value(this.zoomRect.top);
      }
      else
      {
         this.rightAxis.max = this.rightAxis.pos_to_value(this.zoomRect.top);
         this.rightAxis.min = this.rightAxis.pos_to_value(this.zoomRect.bottom);
      }

      this.bottomAxis.auto_label = true;
      this.bottomAxis.auto_time = false;
      this.bottomAxis.auto_max = false;
      this.bottomAxis.auto_min = false;
      if(this.bottomAxis.inverted)
      {
         this.bottomAxis.max = this.bottomAxis.pos_to_value(this.zoomRect.left);
         this.bottomAxis.min = this.bottomAxis.pos_to_value(this.zoomRect.right);
      }
      else
      {
         this.bottomAxis.max = this.bottomAxis.pos_to_value(this.zoomRect.right);
         this.bottomAxis.min = this.bottomAxis.pos_to_value(this.zoomRect.left);
      }

      //Force graph to recalculate scales
      this.positionsInvalid = true;
   }

   //End zoom rect draw
   this.left_down = false;
   this.zooming = false;
   this.refresh();
};


CsiGraph.prototype.OnRButtonUp = function (mouseX, mouseY)
{
   this.panning = false;
   this.right_down = false;
};


CsiGraph.prototype.OnRButtonClick = function (mouseX, mouseY)
{
   var local_x = mouseX - this.left;
   var local_y = mouseY - this.top;

   if(!this.panning && this.plotRect.contains(new Point(local_x, local_y)))
   {
      this.ShowMenu(mouseX, mouseY); //use screen coords here
   }
};


CsiGraph.prototype.OnLButtonClick = function (mouseX, mouseY)
{
   var local_x = mouseX - this.left;
   var local_y = mouseY - this.top;

   var point = new Point(local_x, local_y);
   //Handle the restore btn click
   if(this.show_restore_btn && this.button_rect.contains(point))
   {
      this.RestoreState();
   }
   else if(!this.zooming)
   {
      var try_count = 1;
      var keep_trying = true;
      var any_series_has_marks = false;
      while(keep_trying && try_count <= 10) //Try 10 times
      {
         //We need to do a hit test on the series to see if we need to look for marks
         var len = this.seriesarray.length;
         var i;
         for(i = 0; i < len; i++)
         {
            if(this.seriesarray[i].marks_enabled)
            {
               any_series_has_marks = true;
               if(this.seriesarray[i].hit_test(point, 5 * try_count))
               {
                  keep_trying = false;
                  this.invalidate();
                  break;
               }
            }
         }

         if(!any_series_has_marks)
         {
            keep_trying = false;
         }
         else
         {
            ++try_count;
         }
      }
   }
};


CsiGraph.prototype.SaveState = function ()
{
   this.leftAxis.save_state();
   this.rightAxis.save_state();
   this.bottomAxis.save_state();
};


CsiGraph.prototype.RestoreState = function ()
{
   this.show_restore_btn = false;
   this.leftAxis.restore_state();
   this.rightAxis.restore_state();
   this.bottomAxis.restore_state();
   this.positionsInvalid = true;
   if(this.restore_gesture)
   {
      csiMouseEvents.release_gesture(this.restore_gesture);
      this.restore_gesture = null;
   }
   this.invalidate();
};


CsiGraph.prototype.ShowMenu = function (mouseX, mouseY)
{
   var component = this;
   csiMouseEvents.hideMenu();

   $("<div id='context'></div>").html("<ul class='context_menu'><li id='show_all_data' class='menu_item'>Show All Data</li><li id='restore' class='menu_item'>Restore</li></ul>")
   .css({
      position: 'absolute',
      zIndex: '9999',
      left: mouseX + $('#rtmc_canvas').offset().left,
      top: mouseY + $('#rtmc_canvas').offset().top
   }).show().appendTo('body');

   $('ul.context_menu').css({
      listStyle: 'none',
      padding: '1px',
      margin: '0px',
      backgroundColor: '#fff',
      border: '1px solid #999',
      width: 'auto'
   });

   $('li.menu_item').mouseover(function ()
   {
      $(this).css({
         backgroundColor: '#E9EFF8'
      });
   }).mouseout(function ()
   {
      $(this).css({
         backgroundColor: 'transparent'
      });
   }).css({
      width: 'auto',
      margin: '0px',
      color: '#000',
      display: 'block',
      cursor: 'default',
      padding: '3px',
      border: '1px solid #fff',
      backgroundColor: 'transparent'
   }).click(function ()
   {
      csiMouseEvents.hideMenu();
   });

   $('#restore').click(function ()
   {
      if(component.show_restore_btn)
      {
         component.RestoreState();
      }
   });


   $('#show_all_data').click(function ()
   {
      if(!component.show_restore_btn)
      {
         //Only do this on the first zoom
         component.show_restore_btn = true;
         component.SaveState();
      }

      component.leftAxis.auto_max = true;
      component.leftAxis.auto_min = true;
      component.rightAxis.auto_max = true;
      component.rightAxis.auto_min = true;
      component.bottomAxis.auto_max = true;
      component.bottomAxis.auto_min = true;
      component.positionsInvalid = true;
      component.refresh();
   });
};


CsiGraph.prototype.OnMouseExit = function ()
{
   if(this.zooming || this.left_down)
   {
      this.left_down = false;
      this.zooming = false;
      this.refresh();
      return true; //Prevent default behavior
   }
   else if(this.panning || this.right_down)
   {
      this.panning = false;
      this.right_down = false;
      return true; //Prevent default behavior
   }
   return false;
};


CsiGraph.prototype.on_double_tap_complete = function(gesture)
{
   var right_scale = this.rightAxis.scale;
   var left_scale = this.leftAxis.scale;
   var bottom_scale = this.bottomAxis.scale;
   var gesture_point = this.translate_canvas(gesture.get_origin());

   gesture_point.offset(-this.top, -this.left);
   if(!this.show_restore_btn)
   {
      this.show_restore_btn = true;
      this.SaveState();
   }
   if(right_scale)
   {
      var right_width = (right_scale.get_max_value() - right_scale.get_min_value()) / 2;
      var right_y = this.rightAxis.pos_to_value(gesture_point.y);
      this.rightAxis.auto_min = this.rightAxis.auto_max = false;
      this.rightAxis.min = right_y - right_width / 2;
      this.rightAxis.max = right_y + right_width / 2;
   }
   if(left_scale)
   {
      var left_width = (left_scale.get_max_value() - left_scale.get_min_value()) / 2;
      var left_y = this.leftAxis.pos_to_value(gesture_point.y);
      this.leftAxis.auto_min = this.leftAxis.auto_max = false;
      this.leftAxis.min = left_y - left_width / 2;
      this.leftAxis.max = left_y + left_width / 2;
   }
   if(bottom_scale)
   {
      var bottom_width = (bottom_scale.get_max_value() - bottom_scale.get_min_value()) / 2;
      var bottom_x = this.bottomAxis.pos_to_value(gesture_point.x);
      this.bottomAxis.auto_min = this.bottomAxis.auto_max = false;
      this.bottomAxis.auto_time = false;
      this.bottomAxis.min = bottom_x - bottom_width / 2;
      this.bottomAxis.max = bottom_x + bottom_width / 2;
   }
   for(var i = 0; i < this.seriesarray.length; ++i)
   {
      var series = this.seriesarray[i];
      if(series.marks_enabled && series.marks_show_on_click)
      {
         series.current_mark = null;
      }
   }
   this.positionsInvalid = true;
   this.invalidate();
};


CsiGraph.prototype.on_single_tap_complete = function(gesture)
{
   if(gesture === this.restore_gesture)
   {
      this.RestoreState();
      this.invalidate();
   }
   else if(gesture == this.marks_gesture)
   {
      var local = this.translate_canvas(gesture.get_origin());
      this.OnLButtonClick(local.x, local.y);
   }
};


CsiGraph.prototype.on_swipe_moved = function(gesture, delta_x, delta_y)
{
   var right_scale = this.rightAxis.scale;
   var left_scale = this.leftAxis.scale;
   var bottom_scale = this.bottomAxis.scale;
   if(!this.show_restore_btn)
   {
      this.show_restore_btn = true;
      this.SaveState();
   }
   if(right_scale)
   {
      var right_delta = delta_y / right_scale.scale;
      this.rightAxis.auto_min = this.rightAxis.auto_max = false;
      this.rightAxis.min = right_scale.get_min_value() + right_delta;
      this.rightAxis.max = right_scale.get_max_value() + right_delta;
   }
   if(left_scale)
   {
      var left_delta = delta_y / left_scale.scale;
      this.leftAxis.auto_min = this.leftAxis.auto_max = false;
      this.leftAxis.min = left_scale.get_min_value() + left_delta;
      this.leftAxis.max = left_scale.get_max_value() + left_delta;
   }
   if(bottom_scale)
   {
      var bottom_delta = delta_x / bottom_scale.scale;
      this.bottomAxis.auto_min = this.bottomAxis.auto_max = false;
      this.bottomAxis.auto_time = false;
      this.bottomAxis.min = bottom_scale.get_min_value() - bottom_delta;
      this.bottomAxis.max = bottom_scale.get_max_value() - bottom_delta;
   }
   this.positionsInvalid = true;
   this.refresh();
};


CsiGraph.prototype.on_swipe_complete = function(gesture)
{
   var series_len = this.seriesarray.length;
   for(var i = 0; i < series_len; ++i)
   {
      var series = this.seriesarray[i];
      if(series.marks_enabled && series.marks_show_on_click)
      {
         series.current_mark = null;
      }
   }
   this.invalidate();
};


CsiGraph.prototype.on_pinch_start = function(gesture)
{
   var series_len = this.seriesarray.length;
   for(var i = 0; i < series_len; ++i)
   {
      var series = this.seriesarray[i];
      if(series.marks_enabled && series.marks_show_on_click)
      {
         series.current_mark = null;
      }
   }
};


CsiGraph.prototype.on_pinch_moved = function(gesture, scale, midpoint_, delta_x, delta_y)
{
   var right_scale = this.rightAxis.scale;
   var left_scale = this.leftAxis.scale;
   var bottom_scale = this.bottomAxis.scale;
   var midpoint = this.translate_canvas(midpoint_);
   var max;
   var min;
   var ratio;
   var new_width;
   var value;

   midpoint.offset(-this.left, -this.top);
   if(!this.show_restore_btn)
   {
      this.show_restore_btn = true;
      this.SaveState();
   }
   if(right_scale)
   {
      max = right_scale.get_max_value();
      min = right_scale.get_min_value();
      new_width = (max - min) * scale;
      value = this.rightScale.pos_to_value(midpoint.y);
      ratio = (value - min) / (max - min);
      this.rightAxis.auto_min = this.rightAxis.auto_max = false;
      this.rightAxis.min = value - new_width * ratio + delta_y / right_scale.scale;
      this.rightAxis.max = this.rightAxis.min + new_width;
   }
   if(left_scale)
   {
      max = left_scale.get_max_value();
      min = left_scale.get_min_value();
      new_width = (max - min) * scale;
      value = this.leftAxis.pos_to_value(midpoint.y);
      ratio = (value - min) / (max - min);
      this.leftAxis.auto_min = this.leftAxis.auto_max = false;
      this.leftAxis.min = value - new_width * ratio + delta_y / left_scale.scale;
      this.leftAxis.max = this.leftAxis.min + new_width;
   }
   if(bottom_scale)
   {
      max = bottom_scale.get_max_value();
      min = bottom_scale.get_min_value();
      new_width = (max - min) * scale;
      value = this.bottomAxis.pos_to_value(midpoint.x);
      ratio = (value - min) / (max - min);
      this.bottomAxis.auto_min = this.bottomAxis.auto_max = false;
      this.bottomAxis.auto_time = false;
      this.bottomAxis.min = value - new_width * ratio - delta_x / bottom_scale.scale;
      this.bottomAxis.max = this.bottomAxis.min + new_width;
   }
   this.positionsInvalid = true;
   this.refresh();
};


CsiGraph.prototype.on_pinch_complete = function(gesture)
{
   this.invalidate();
};


CsiGraph.prototype.activate = function(context)
{
   CsiComponent.prototype.activate.call(this);
   csiMouseEvents.register_gesture(this.double_zoom_gesture);
   csiMouseEvents.register_gesture(this.pan_gesture);
   csiMouseEvents.register_gesture(this.marks_gesture);
   csiMouseEvents.register_gesture(this.pinch_gesture);
   if(this.restore_gesture)
   {
      csiMouseEvents.register_gesture(this.restore_gesture, 0);
   }
};


CsiGraph.prototype.deactivate = function()
{
   CsiComponent.prototype.deactivate.call(this);
   csiMouseEvents.release_gesture(this.double_zoom_gesture);
   csiMouseEvents.release_gesture(this.pan_gesture);
   csiMouseEvents.release_gesture(this.marks_gesture);
   csiMouseEvents.release_gesture(this.pinch_gesture);
   if(this.restore_gesture)
   {
      csiMouseEvents.release_gesture(this.restore_gesture);
   }
};


Enum.LEGEND_ALIGNMENT =
{
   LEFT: 0,
   RIGHT: 1,
   TOP: 2,
   BOTTOM: 3
};

/* CsiMouseEvents.js

   Copyright (C) 2010, 2013 Campbell Scientific, Inc.

   Written by: Jon Trauntvein 
   Date Begun: 5 October 2010
   Last Change: Thursday 21 February 2013
   Last Commit: $Date: 2013-03-05 15:35:08 -0700 (Tue, 05 Mar 2013) $
   Last Changed by: $Author: jon $

*/

/*component mouse events
OnLButtonClick/OnRButtonClick:  Mouse was pressed and released on component
OnLButtonDblClk: Left Mouse was double clicked
OnLButtonDown/OnRButtonDown:  Mouse button was pressed down on component
OnLButtonUp/OnRButtonUp:  Mouse button was released on component
OnMouseDrag: MouseDrag on a component. Mouse position can be inside or outside the range of the component.
OnMouseDragEnd: Left Mouse button was lifted after a drag (inside or outside the comp)
OnMouseRelease:  Left Mouse button was released after first pressing down on a comp.  The mouse can be inside or outside the component.
OnMouseEnter:  Mouse entered component
OnMouseExit:  Mouse exited component
OnMouseMove:  Mouse moved while over component
*/

var csiMouseEvents = null; //GLOBAL DECLARATION

function init_mouse()
{
   var canvas = $('#rtmc_canvas');
   csiMouseEvents = new CsiMouseEvents();
   canvas.mousedown(function (evt) { csiMouseEvents.onMouseDown(evt); });
   canvas.mouseup(function (evt) { csiMouseEvents.onMouseUp(evt); });
   canvas.mousemove(function (evt) { csiMouseEvents.onMouseMove(evt); });
   canvas.dblclick(function (evt) { csiMouseEvents.onDblClick(evt); });
   canvas.mouseout(function (evt) { csiMouseEvents.onMouseOut(evt); });

   canvas[0].addEventListener("touchstart", CsiMouseEvents.onTouchStart, false);
   canvas[0].addEventListener("touchend", CsiMouseEvents.onTouchEnd, false);
   canvas[0].addEventListener("touchmove", CsiMouseEvents.onTouchMove, false);
   document.body.addEventListener("touchcancel", CsiMouseEvents.onTouchCancel, false);
}

//Disable default browser context menu
$(document).on("contextmenu", function (e) { return false; });

//this class handles all mouse events
function CsiMouseEvents()
{
   this.mouseDownPos = null; //Track this position to make sure the mouseUp event triggers a click only if needed
   this.leftMouseDownComp = null;  //left mouseDown occurred on component
   this.rightMouseDownComp = null; //right mouseDown occurred on component
   this.mouseOverComp = null; //last component which the mouse moved over
   this.dragComp = null; //component being dragged with left button
   this.lastTouchPos = null; //Track the last touch position
   this.gestures = [];
}


CsiMouseEvents.find_touch_comp = function(event)
{
   var rtn = {
      component: null,
      touch_x: NaN,
      touch_y: NaN
   };
   var touch_count = event.touches.length;
   var canvas = $('#rtmc_canvas');
   var touch_test;
   var touch;
   
   for(var i = 0; i < touch_count; ++i)
   {
      touch = event.touches[i];
      rtn.touch_x = touch.pageX - canvas.offset().left;
      rtn.touch_y = touch.pageY - canvas.offset().top;
      touch_test = graphicsManager.hit_test_by_need(rtn.touch_x, rtn.touch_y);
      if(!rtn.component && touch_test)
      {
         rtn.component = touch_test;
      }
      else if(rtn != touch_test)
      {
         rtn.component = null;
         break;
      }
   }
   return rtn;
};


CsiMouseEvents.onTouchStart = function(evt)
{
   // we will give the list of gestures first crack on the event.
   var gestures_len = csiMouseEvents.gestures.length;
   var handled = false;
   csi_log("touch start event with " + evt.touches.length + " touches");
   for(var i = 0; i < gestures_len; ++i)
   {
      if(csiMouseEvents.gestures[i].on_touch_start(evt))
      {
         handled = true;
      }
   }

   // if now gesture handled the event, we will attempt to pass it as a mouse event
   if(!handled)
   {
      // we need to find the component associated with the touch coordinates
      var temp = CsiMouseEvents.find_touch_comp(evt);
      var touch_component = temp.component;
      var touch_x = temp.touch_x;
      var touch_y = temp.touch_y;
      var touch_count = evt.touches.length;

      if(touch_count === 1 && touch_component)
      {
         csiMouseEvents.mouseDownPos = new Point(touch_x, touch_y);
         csiMouseEvents.lastTouchPos = new Point(touch_x, touch_y);
         if(typeof touch_component.OnLButtonDown == "function")
         {
            touch_component.OnLButtonDown(touch_x, touch_y);
         }
         evt.preventDefault();
         graphicsManager.stopAutoTabbing();
         csiMouseEvents.hideMenu();
      }
      else
      {
         csiMouseEvents.mouseDownPos = null;
         csiMouseEvents.lastTouchPos = null;
      }
   }
};


CsiMouseEvents.onTouchMove = function(evt)
{
   // give the registered gestures first cut at the event
   var gestures_len = csiMouseEvents.gestures.length;
   var handled = false;
   csi_log("touch move event with " + evt.touches.length + " touches");
   for(var i = 0; i < gestures_len; ++i)
   {
      if(csiMouseEvents.gestures[i].on_touch_move(evt))
      {
         handled = true;
      }
   }

   // if no gesture handled the event, we will attempt to map it as a mouse event
   if(!handled)
   {
      var temp = CsiMouseEvents.find_touch_comp(evt);
      var mouseX = temp.touch_x;
      var mouseY = temp.touch_y;
      var hit_comp = temp.component;
      var prevent_default = false;

      if(hit_comp && evt.touches.length === 1)
      {
         // report a mouse move event
         csiMouseEvents.lastTouchPos = new Point(mouseX, mouseY);
         if(typeof hit_comp.OnMouseMove === "function")
         {
            hit_comp.OnMouseMove(mouseX, mouseY);
            prevent_default = true;
         }
         
         // report a left drag event
         if(csiMouseEvents.leftMouseDownComp)
         {
            csiMouseEvents.dragComp = csiMouseEvents.leftMouseDownComp;
            if(typeof csiMouseEvents.dragComp.OnMouseDrag === "function")
            {
               csiMouseEvents.dragComp.OnMouseDrag(mouseX, mouseY);
               prevent_default = true;
            }
         }
      }
      
      if(prevent_default)
      {
         evt.preventDefault();
      }
   }
};


CsiMouseEvents.onTouchEnd = function(evt)
{
   // give the registered gestures first crack at the event
   var gestures_len = csiMouseEvents.gestures.length;
   var handled = false;
   csi_log("touch end event with " + evt.touches.length + " touches");
   for(var i = 0; i < gestures_len; ++i)
   {
      if(csiMouseEvents.gestures[i].on_touch_end(evt))
      {
         handled = true;
      }
   }

   // if no gesture claimed the event, map it to a mouse event
   if(!handled)
   {
      var temp = CsiMouseEvents.find_touch_comp(evt);
      var mouseX = temp.touch_x;
      var mouseY = temp.touch_y;
      var hit_comp = temp.component;
      var prevent_default = false;
      graphicsManager.stopAutoTabbing();

      if(csiMouseEvents.lastTouchPos)
      {
         var last_mouseX = csiMouseEvents.lastTouchPos.x;
         var last_mouseY = csiMouseEvents.lastTouchPos.y;
         var last_hit_comp = graphicsManager.hit_test_by_need(last_mouseX, last_mouseY);
         if(last_hit_comp)
         {
            //LButtonUp
            if(typeof last_hit_comp.OnLButtonUp === "function")
            {
               last_hit_comp.OnLButtonUp(last_mouseX, last_mouseY);
               prevent_default = true;
            }
            
            //LButtonClick
            if(hit_comp === csiMouseEvents.leftMouseDownComp &&
               csiMouseEvents.mouseDownPos.x === mouseX &&
               csiMouseEvents.mouseDownPos.y === mouseY)
            {
               if(typeof hit_comp.OnLButtonClick === "function")
               {
                  hit_comp.OnLButtonClick(mouseX, mouseY);
                  prevent_default = true;
               }
            }
         }
         
         if(csiMouseEvents.dragComp)
         {
            if(typeof csiMouseEvents.dragComp.OnMouseDragEnd === "function")
            {
               csiMouseEvents.dragComp.OnMouseDragEnd(mouseX, mouseY);
               prevent_default = true;
            }
         }
         
         if(csiMouseEvents.leftMouseDownComp)
         {
            if(typeof csiMouseEvents.leftMouseDownComp.OnMouseRelease === "function")
            {
               csiMouseEvents.leftMouseDownComp.OnMouseRelease(mouseX, mouseY);
               prevent_default = true;
            }
         }
         
         if(prevent_default)
         {
            evt.preventDefault();
         }
      }
   }

   csiMouseEvents.mouseDownPos = null;
   csiMouseEvents.leftMouseDownComp = null;
   csiMouseEvents.rightMouseDownComp = null;
   csiMouseEvents.mouseOverComp = null;
   csiMouseEvents.dragComp = null;
   csiMouseEvents.lastTouchPos = null;
};


CsiMouseEvents.onTouchCancel = function(event)
{
   // give the registered gestures first crack at the event
   var gestures_len = csiMouseEvents.gestures.length;
   var handled = false;
   for(var i = 0; i < gestures_len && !handled; ++i)
   {
      handled = csiMouseEvents.gestures[i].on_touch_end(event);
   }
   CsiMouseEvents.onTouchEnd(event);
};


CsiMouseEvents.prototype.onDblClick = function (evt)
{
   var mouseX = evt.pageX - $('#rtmc_canvas').offset().left;
   var mouseY = evt.pageY - $('#rtmc_canvas').offset().top;
   var hit_comp = graphicsManager.hit_test_by_need(mouseX, mouseY);
   if(hit_comp)
   {
      if(evt.button === Enum.BUTTON.LEFT)
      {
         if(typeof hit_comp.OnLButtonDblClk === "function")
         {
            hit_comp.OnLButtonDblClk(mouseX, mouseY);
         }
      }
   }
};


CsiMouseEvents.prototype.onMouseDown = function (evt)
{
   graphicsManager.stopAutoTabbing();

   this.hideMenu();

   var mouseX = evt.pageX - $('#rtmc_canvas').offset().left;
   var mouseY = evt.pageY - $('#rtmc_canvas').offset().top;
   this.mouseDownPos = new Point(mouseX, mouseY); //store the click pos
   var hit_comp = graphicsManager.hit_test_by_need(mouseX, mouseY);

   if(evt.button === Enum.BUTTON.LEFT)
   {
      this.leftMouseDownComp = hit_comp;
      if(hit_comp)
      {
         if(typeof hit_comp.OnLButtonDown === "function")
         {
            hit_comp.OnLButtonDown(mouseX, mouseY);
         }
      }
   }
   else if(evt.button === Enum.BUTTON.RIGHT)
   {
      this.rightMouseDownComp = hit_comp;
      if(hit_comp) 
      {
         if(typeof hit_comp.OnRButtonDown === "function")
         {
            hit_comp.OnRButtonDown(mouseX, mouseY);
            return false; //Stop the right click event from moving to page
         }
      }
   }
   return true;
};


CsiMouseEvents.prototype.onMouseUp = function (evt)
{
   graphicsManager.stopAutoTabbing();

   var result = true;
   var mouseX = evt.pageX - $('#rtmc_canvas').offset().left;
   var mouseY = evt.pageY - $('#rtmc_canvas').offset().top;
   var hit_comp = graphicsManager.hit_test_by_need(mouseX, mouseY);

   if(evt.button === Enum.BUTTON.LEFT)
   {
      if(hit_comp)
      {
         //LButtonUp
         if(typeof hit_comp.OnLButtonUp === "function")
         {
            hit_comp.OnLButtonUp(mouseX, mouseY);
         }

         //LButtonClick
         if(hit_comp === this.leftMouseDownComp &&
            this.mouseDownPos.x === mouseX &&
            this.mouseDownPos.y === mouseY)
         {
            if(typeof hit_comp.OnLButtonClick === "function")
            {
               hit_comp.OnLButtonClick(mouseX, mouseY);
            }
         }
      }

      if(this.dragComp)
      {
         if(typeof this.dragComp.OnMouseDragEnd === "function")
         {
            this.dragComp.OnMouseDragEnd(mouseX, mouseY);
         }
      }

      if(this.leftMouseDownComp)
      {
         if(typeof this.leftMouseDownComp.OnMouseRelease === "function")
         {
            this.leftMouseDownComp.OnMouseRelease(mouseX, mouseY);
         }
      }

      this.leftMouseDownComp = null;
      this.dragComp = null;
   }
   else if(evt.button === Enum.BUTTON.RIGHT)
   {
      if(hit_comp)
      {
         if(typeof hit_comp.OnRButtonUp === "function")
         {
            hit_comp.OnRButtonUp(mouseX, mouseY);
            result = false; //Stop the right click event from moving to page
         }

         if(hit_comp === this.rightMouseDownComp)
         {
            if(typeof hit_comp.OnRButtonClick === "function")
            {
               if(this.mouseDownPos.x === mouseX && this.mouseDownPos.y === mouseY)
               {
                  hit_comp.OnRButtonClick(mouseX, mouseY);
               }
            }
         }
      }

      this.rightMouseDownComp = null;
   }

   return result;
};


CsiMouseEvents.prototype.onMouseMove = function (evt)
{
   var mouseX = evt.pageX - $('#rtmc_canvas').offset().left;
   var mouseY = evt.pageY - $('#rtmc_canvas').offset().top;
   var hit_comp = graphicsManager.hit_test_by_need(mouseX, mouseY);

   //mouseExit
   if((this.mouseOverComp) && (this.mouseOverComp !== hit_comp))
   {
      if(typeof this.mouseOverComp.OnMouseExit === "function")
      {
         this.mouseOverComp.OnMouseExit();
      }

      //allow selection in document after leaving component
      document.onselectstart = function () { return true; };
   }

   if(hit_comp)
   {
      //MouseEnter
      if(hit_comp !== this.mouseOverComp)
      {
         if(typeof hit_comp.OnMouseEnter === "function")
         {
            hit_comp.OnMouseEnter(mouseX, mouseY);
         }

         //do not show the select cursor when dragging from a dragable component
         if(!hit_comp.showSelectCursor)
         {
            document.onselectstart = function () { return false; };
         }
      }

      //MouseMove
      if(typeof hit_comp.OnMouseMove === "function")
      {
         hit_comp.OnMouseMove(mouseX, mouseY);
      }
   }

   //left drag
   if(this.leftMouseDownComp)
   {
      this.dragComp = this.leftMouseDownComp;
      if(typeof this.dragComp.OnMouseDrag === "function")
      {
         this.dragComp.OnMouseDrag(mouseX, mouseY);
      }
   }

   this.mouseOverComp = hit_comp;
   return true;
};


CsiMouseEvents.prototype.hideMenu = function ()
{
   var selector = $("#context");
   if(selector.length !== 0)
   {
      selector.remove();
      graphicsManager.OnMenuHidden();
   }
};


CsiMouseEvents.prototype.onMouseOut = function (evt)
{
   var mouseX = evt.pageX - $('#rtmc_canvas').offset().left;
   var mouseY = evt.pageY - $('#rtmc_canvas').offset().top;
   var hit_comp = graphicsManager.hit_test_by_need(mouseX, mouseY);

   //mouseExit
   if((this.mouseOverComp) && (this.mouseOverComp !== hit_comp))
   {
      if(typeof this.mouseOverComp.OnMouseExit === "function")
      {
         this.mouseOverComp.OnMouseExit();
      }

      //allow selection in document after leaving component
      document.onselectstart = function () { return true; };
   }

   this.mouseDownPos = null; //Track this position to make sure the mouseUp event triggers a click only if needed
   this.leftMouseDownComp = null;  //left mouseDown occurred on component
   this.rightMouseDownComp = null; //right mouseDown occurred on component
   this.mouseOverComp = null; //last component which the mouse moved over
   this.dragComp = null; //component being dragged with left button
   this.lastTouchPos = null; //Track the last touch position
};


CsiMouseEvents.prototype.register_gesture = function(gesture, priority)
{
   if(arguments.length < 2)
   {
      priority = 10;
   }
   gesture.priority = priority;
   this.gestures.push(gesture);
   this.gestures.sort(function(first, second) { return first.priority - second.priority; });
};


CsiMouseEvents.prototype.release_gesture = function(gesture)
{
   var gesture_index = this.gestures.indexOf(gesture);
   if(gesture_index >= 0)
   {
      this.gestures.splice(gesture_index, 1);
   }
};

////////////////////////////////////////////////////////////
// CsiComponent.page_rect
//
// Extends the CsiComponent class by adding a method, pager_rect(), which returns a
// rectangle for this component in page coordinates.
////////////////////////////////////////////////////////////
CsiComponent.prototype.page_rect = function()
{
   return this.translate_page(
      new Rect(this.left, this.top, this.widt, this.height));
};


////////////////////////////////////////////////////////////
// CsiComponent.translate_page
//
// Translates the rectangle or point to page coordinates.
////////////////////////////////////////////////////////////
CsiComponent.prototype.translate_page = function(arg)
{
   var rtn;
   var canvas = $('#rtmc_canvas');
   var offset = canvas.offset();
   if(arg instanceof Rect)
   {
      rtn = new Rect(
         arg.left + offset.left,
         arg.top + offset.top,
         arg.width,
         arg.height);
   }
   else if(arg instanceof Point)
   {
      rtn = new Point(arg.x + offset.left, arg.y + offset.top);
   }
   return rtn;
};


////////////////////////////////////////////////////////////
// CsiComponent.translate_canvas
//
// Translates a point or rectangle specified in page coordinates
// to a point or rectangle in canvas coordinates.
////////////////////////////////////////////////////////////
CsiComponent.prototype.translate_canvas = function(arg)
{
   var rtn;
   var canvas = $('#rtmc_canvas');
   var offset = canvas.offset();
   if(arg instanceof Rect)
   {
      rtn = new Rect(
         arg.left - offset.left,
         arg.top - offset.top,
         arg.width,
         arg.height);
   }
   else if(arg instanceof Point)
   {
      rtn = new Point(arg.x - offset.left, arg.y - offset.top);
   }
   return rtn;
};


/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiTable.js $

Copyright (C) 2010 Campbell Scientific, Inc.
Started On: 10/5/2010 7:51:33 AM
Started By: Kevin Westwood

$LastChangedBy: tmecham $
$LastChangedDate: 2013-03-19 06:27:21 -0600 (Tue, 19 Mar 2013) $
$LastChangedRevision: 17687 $
*/


function CsiTable(left, top, width, height, expression)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   CsiComponent.call(this, left, top, width, height);

   if(expression)
   {
      this.expression = expression;
      this.expression.ownerComponent = this;
   }
   else
   {
      this.expression = null;
   }

   this.maxRecords = 1000;
   this.timestampFormat = "%c";
   this.timeOffset = 0;
   this.newDataAtTop = false;
   this.showRecordNumber = false;
   this.showAllColumns = true;
   this.tableFilter = [];
   this.customHeadings = [];
   this.customPrecisions = [];
   this.font = "10pt Arial";

   //Internal use
   this.current_row = null;
   this.filter_index = null;
   this.table_count = 0;
   this.col_exp_array = [];
   this.fixed_table_header = [];
   this.col_types = [];
   this.rows = [];
   this.row_height = 0;
   this.top_row = 0;
   this.left_col = 0;
   this.col_count = 0;
   this.col_widths = [];
   this.col_char_counts = [];
   this.margin = 5;
   this.needs_hscrollbar = false;
   this.needs_vscrollbar = false;
   this.max_visible_rows = Number.MAX_VALUE;
   this.needs_mouse_events = true;
   this.precisions = [];
}
CsiTable.prototype = new CsiComponent();

var SCROLL_BTN_SIZE = 25.0;  //global


function CsiColumnExpressionComp(col_name, expression, ownerComponent)
{
   this.ownerComponent = ownerComponent;

   if(expression)
   {
      this.expression = expression;
      this.expression.ownerComponent = this;
   }
   else
   {
      this.expression = null;
   }

   this.col_name = col_name;
   this.bad_data = true;
   this.nan_data = false;
   this.col_index = -1; //Index into the displayed columns
}


CsiColumnExpressionComp.prototype.newValue = function (rec_value, timestamp, expectMore)
{
   if(this.col_index >= 0 && this.ownerComponent.current_row)
   {
      var col_offset = 1;
      if(this.ownerComponent.showRecordNumber)
         col_offset = 2;
      var col_value;
      var col_type = this.ownerComponent.col_types[this.col_index - col_offset];
      try
      {
         if(col_type === Enum.ColDataTypes.DATE)
         {
            col_value = CsiLgrDate.fromStr(rec_value).format(this.ownerComponent.timestampFormat);
         }
         else if(col_type === Enum.ColDataTypes.FLOAT)
         {
            if(rec_value === -Infinity)
            {
               col_value = "-INF";
            }
            else if(rec_value === Infinity)
            {
               col_value = "INF";
            }
            else if(isNaN(rec_value))
            {
               col_value = "NAN";
            }
            else
            {
               col_value = sprintf("%.*f", this.ownerComponent.precisions[this.col_index - col_offset], rec_value);
            }
         }
         else if(col_type === Enum.ColDataTypes.STRING)
         {
            col_value = rec_value;
         }
         else if(col_type === Enum.ColDataTypes.INT)
         {
            col_value = rec_value.toLocaleString();
         }
         else if(col_type === Enum.ColDataTypes.BOOL)
         {
            col_value = rec_value === 0 ? "True" : "False";
         }
         else
         {
            col_value = String(rec_value);
         }
      }
      catch(exception)
      {
         col_value = "";
      }

      this.ownerComponent.current_row[this.col_index] = col_value;
      //Check each column to see if we need to take a new measurement
      if(this.ownerComponent.current_row[this.col_index].length > this.ownerComponent.col_char_counts[this.col_index])
      {
         this.ownerComponent.col_widths[this.col_index] = graphicsManager.context.measureText(this.ownerComponent.current_row[this.col_index]).width + 2 * this.ownerComponent.margin;
         this.ownerComponent.col_char_counts[this.col_index] = this.ownerComponent.current_row[this.col_index].length;
      }

      this.invalidate();
   }
};


CsiColumnExpressionComp.prototype.newStringValue = function (value, timestamp, expect_more)
{
   this.newValue(value, timestamp, expect_more);
};


CsiColumnExpressionComp.prototype.newNanValue = function (value, timestamp, expect_more)
{
   this.newValue(value, timestamp, expect_more);
};


CsiColumnExpressionComp.prototype.invalidate = function ()
{
   this.ownerComponent.valid = false;
   graphicsManager.componentInvalidate(this.ownerComponent);
};


CsiTable.prototype.createColumnExpressionComp = function (col_name, expression)
{
   var col_exp = new CsiColumnExpressionComp(col_name, expression, this);
   this.col_exp_array.push(col_exp);
   return col_exp;
};


CsiTable.prototype.tableDefs = function (jsonHead)
{
   this.current_row = null;
   var f = 0;
   var j = 0;
   var i = 0;

   //Reset the index of all the expression columns
   var total_col_exp = this.col_exp_array.length;
   for(j = 0; j < total_col_exp; j++)
   {
      this.col_exp_array[j].col_index = -1;
   }

   this.fixed_table_header = [];
   this.col_types = [];

   //add fixed header cells
   var total_col_count = jsonHead.fields.length;

   this.fixed_table_header.push("Timestamp");
   if(this.showRecordNumber)
   {
      this.fixed_table_header.push("Record #");
   }

   if(this.showAllColumns)
   {
      for(j = 0; j < total_col_count; j++)
      {
         //Look for a custom heading label
         if(jQuery.type(this.customHeadings[jsonHead.fields[j].name]) !== "undefined")
         {
            this.fixed_table_header.push(this.customHeadings[jsonHead.fields[j].name]);
         }
         else
         {
            this.fixed_table_header.push(jsonHead.fields[j].name);
         }

         this.col_types.push(this.get_type(jsonHead.fields[j].type));

         //set the precisions if they exist
         if(jQuery.type(this.customPrecisions[jsonHead.fields[j].name]) !== "undefined")
         {
            this.precisions.push(parseInt(this.customPrecisions[jsonHead.fields[j].name], 10));
         }
         else
         {
            this.precisions.push(2);
         }
      }
   }
   else
   {
      this.filter_index = [];
      //Put all the filters in the header
      var flen = this.tableFilter.length;
      for(f = 0; f < flen; f++)
      {
         var found = false;
         for(j = 0; j < total_col_count && !found; j++)
         {
            if(this.tableFilter[f] === jsonHead.fields[j].name)
            {
               //Look for a custom heading label
               if(jQuery.type(this.customHeadings[jsonHead.fields[j].name]) !== "undefined")
               {
                  this.fixed_table_header.push(this.customHeadings[jsonHead.fields[j].name]);
               }
               else
               {
                  this.fixed_table_header.push(jsonHead.fields[j].name);
               }

               //set the precisions if they exist
               if(jQuery.type(this.customPrecisions[jsonHead.fields[j].name]) !== "undefined")
               {
                  this.precisions.push(parseInt(this.customPrecisions[jsonHead.fields[j].name], 10));
               }
               else
               {
                  this.precisions.push(2);
               }

               //Cache the index for fast lookup
               this.col_types.push(this.get_type(jsonHead.fields[j].type));
               this.filter_index[f] = j;
               found = true;
            }
         }
      }
   }

   //First let's try to match the column titles for the index.  This only fails if custom headings are used.
   this.col_count = this.fixed_table_header.length;
   for(f = 0; f < this.col_count; f++)
   {
      //Assign the index of the column expression comps
      for(i = 0; i < total_col_exp; i++)
      {
         //Is the col_index uninitialized?
         if(this.col_exp_array[i].col_index === -1)
         {
            if(this.col_exp_array[i].col_name === this.fixed_table_header[f])
            {
               this.col_exp_array[i].col_index = f;
               break;
            }
            else if(jQuery.type(this.customHeadings[this.col_exp_array[i].col_name]) !== "undefined")
            {
               //Try to find the matching column title from the customHeading
               if(this.customHeadings[this.col_exp_array[i].col_name] === this.fixed_table_header[f])
               {
                  this.col_exp_array[i].col_index = f;
                  break;
               }
            }
         }
      }
   }
   //See if we need to pick out any custom headings for the expression index.
   for(i = 0; i < total_col_exp; i++)
   {
      if(this.col_exp_array[i].col_index === -1) //Still no index so check custom headings
      {
         if(jQuery.type(this.customHeadings[this.col_exp_array[i].col_name]) !== "undefined")
         {
            this.col_exp_array[i].col_index = i;
         }
      }
   }

   graphicsManager.context.font = this.fontContents;
   var contentsFontHeight = graphicsManager.context.measureText("W").width * 1.5 + 2 * this.margin;
   graphicsManager.context.font = this.fontHeading;
   var headingFontHeight = graphicsManager.context.measureText("W").width * 1.5 + 2 * this.margin;
   if(headingFontHeight < contentsFontHeight)
   {
      graphicsManager.context.font = this.fontContents;
      this.row_height = contentsFontHeight;
   }
   else
   {
      this.row_height = headingFontHeight;
   }

   //Height - fixed header and then minus hscroll if needed
   this.max_visible_rows = parseFloat((((this.height - this.row_height - (this.needs_hscrollbar ? SCROLL_BTN_SIZE : 0)) / this.row_height) - 1).toFixed(0));

   //default the col widths to the column headings
   for(i = 0; i < this.col_count; i++)
   {
      this.col_char_counts[i] = this.fixed_table_header[i].length;
      this.col_widths[i] = graphicsManager.context.measureText(this.fixed_table_header[i]).width + 2 * this.margin;
   }

   var total_col_width = 0;
   for(i = 0; i < this.col_count; i++)
   {
      total_col_width += this.col_widths[i];
   }

   if(total_col_width > this.width)
   {
      this.needs_hscrollbar = true;
   }
   else
   {
      this.needs_hscrollbar = false;
   }

   this.invalidate();
};


CsiTable.prototype.newRecord = function (jsonRecord, timestamp, expect_more)
{
   var value_count = jsonRecord.vals.length;
   var i = 0;
   var rec_value;
   var offset_timestamp = new CsiLgrDate(timestamp.milliSecs + this.timeOffset);

   //add the row
   this.current_row = [];
   this.current_row.push(offset_timestamp.format(this.timestampFormat));
   if(this.showRecordNumber)
   {
      this.current_row.push(jsonRecord.no.toLocaleString());
   }

   if(this.showAllColumns)
   {
      for(i = 0; i < value_count; i++)
      {
         rec_value = jsonRecord.vals[i];
         if(this.col_types[i] === Enum.ColDataTypes.DATE)
         {
            this.current_row.push(CsiLgrDate.fromStr(rec_value).format(this.timestampFormat));
         }
         else if(this.col_types[i] === Enum.ColDataTypes.FLOAT)
         {
            if(rec_value === -Infinity || rec_value === "-INF")
            {
               this.current_row.push("-INF");
            }
            else if(rec_value === Infinity || rec_value === "+INF")
            {
               this.current_row.push("+INF");
            }
            else if(isNaN(rec_value))
            {
               this.current_row.push("NAN");
            }
            else
            {
               this.current_row.push(sprintf("%.*f", this.precisions[i], rec_value));
            }
         }
         else if(this.col_types[i] === Enum.ColDataTypes.STRING)
         {
            this.current_row.push(rec_value);
         }
         else if(this.col_types[i] === Enum.ColDataTypes.INT)
         {
            this.current_row.push(rec_value.toLocaleString());
         }
         else if(this.col_types[i] === Enum.ColDataTypes.BOOL)
         {
            this.current_row.push(rec_value === true ? "True" : "False");
         }
         else
         {
            this.current_row.push(String(rec_value));
         }
      }
   }
   else if(this.filter_index)
   {
      var flen = this.tableFilter.length;
      //check to see if it passes the filter
      for(i = 0; i < flen; i++)
      {
         rec_value = jsonRecord.vals[this.filter_index[i]];
         if(this.col_types[i] === Enum.ColDataTypes.DATE)
         {
            this.current_row.push(CsiLgrDate.fromStr(rec_value).format(this.timestampFormat));
         }
         else if(this.col_types[i] === Enum.ColDataTypes.FLOAT)
         {
            if(rec_value === -Infinity)
            {
               this.current_row.push("-INF");
            }
            else if(rec_value === Infinity)
            {
               this.current_row.push("INF");
            }
            else if(isNaN(rec_value))
            {
               this.current_row.push("NAN");
            }
            else
            {
               this.current_row.push(sprintf("%.*f", this.precisions[i], rec_value));
            }
         }
         else if(this.col_types[i] === Enum.ColDataTypes.STRING)
         {
            this.current_row.push(rec_value);
         }
         else if(this.col_types[i] === Enum.ColDataTypes.INT)
         {
            this.current_row.push(rec_value.toLocaleString());
         }
         else if(this.col_types[i] === Enum.ColDataTypes.BOOL)
         {
            this.current_row.push(rec_value === 0 ? "True" : "False");
         }
         else
         {
            this.current_row.push(String(rec_value));
         }
      }
   }

   for(i = 0; i < this.col_count; i++)
   {
      //Check each column to see if we need to take a new measurement
      if(this.current_row[i].length > this.col_char_counts[i])
      {
         this.col_widths[i] = graphicsManager.context.measureText(this.current_row[i]).width + 2 * this.margin;
         this.col_char_counts[i] = this.current_row[i].length;
      }
   }

   if(this.newDataAtTop)
   {
      this.rows.unshift(this.current_row);
   }
   else
   {
      this.rows.push(this.current_row);
   }

   if(!expect_more)
   {
      var rows_to_remove = this.rows.length - this.maxRecords;
      if(rows_to_remove > 0)
      {
         if(this.newDataAtTop)
         {
            this.rows.splice(this.maxRecords, rows_to_remove);
         }
         else
         {
            this.rows.splice(0, rows_to_remove);
         }
      }

      if(this.rows.length > this.max_visible_rows)
      {
         this.needs_vscrollbar = true;
      }
      else
      {
         this.needs_vscrollbar = false;
      }

      var total_col_width = 0;
      for(i = 0; i < this.col_count; i++)
      {
         total_col_width += this.col_widths[i];
      }

      if(total_col_width > this.width)
      {
         this.needs_hscrollbar = true;
      }
      else
      {
         this.needs_hscrollbar = false;
      }

      this.invalidate();
   }
};


CsiTable.prototype.draw = function (context)
{
   context.translate(this.left, this.top); //move to location

   clipRect(context, 0, 0, this.width, this.height);

   context.lineCap = "butt";
   context.lineJoin = "miter";
   context.lineWidth = 1;
   context.strokeStyle = "#000000";
   context.fillStyle = "#FFFFFF";
   context.fillRect(0, 0, this.width, this.height); //Draw background

   if(this.col_count > 0)
   {
      context.fillStyle = "#F0F0F0";
      //Draw fixed header background
      context.fillRect(0, 0, this.width, this.row_height);

      //Draw the fixed backgrounds
      if(this.showRecordNumber)
      {
         context.fillRect(0, this.row_height, this.col_widths[0] + this.col_widths[1], this.height - this.row_height);
      }
      else
      {
         context.fillRect(0, this.row_height, this.col_widths[0], this.height - this.row_height);
      }

      var cur_x = 0;

      //Frame Timestamp
      context.strokeRect(cur_x, 0, this.col_widths[0], this.height);
      cur_x += this.col_widths[0];

      if(this.showRecordNumber)
      {
         //Draw Record Number
         context.strokeRect(cur_x, 0, this.col_widths[1], this.height);
         cur_x += this.col_widths[1];
      }

      var fixed_offset = (this.showRecordNumber ? 2 : 1);
      if(this.left_col < fixed_offset)
      {
         this.left_col = fixed_offset;
      }

      var cur_col;
      for(cur_col = this.left_col; cur_col < this.col_count && cur_x < this.width; cur_col++)
      {
         context.strokeRect(cur_x, 0, this.col_widths[cur_col], this.height);
         cur_x += this.col_widths[cur_col];
      }

      context.textAlign = "center";
      context.textBaseline = "middle";

      //Draw fixed header labels
      var cur_y = this.row_height / 2.0 - this.margin;
      this.draw_row(context, this.fixed_table_header, cur_y, "center"); //Always draw this row at top
      cur_y += this.row_height;

      //Draw all the data rows
      var total_row_count = this.rows.length;
      var row_index;
      for(row_index = this.top_row; row_index < total_row_count && cur_y <= this.height; row_index++)
      {
         this.draw_row(context, this.rows[row_index], cur_y, "right");
         cur_y += this.row_height;
      }

      this.draw_scrollbars(context);
   }
   context.strokeRect(1, 1, this.width - 1, this.height - 1); //Frame the border last
};


CsiTable.prototype.draw_row = function (context, row, y_pos, alignment)
{
   var cur_x = 0;
   context.fillStyle = this.fontColorHeading;
   context.font = this.fontHeading;

   //Draw Timestamp
   context.fillText(row[0], cur_x + this.col_widths[0] / 2.0, y_pos + this.margin);
   cur_x += this.col_widths[0];

   if(this.showRecordNumber)
   {
      //Draw Record Number
      context.fillText(row[1], cur_x + this.col_widths[1] / 2.0, y_pos + this.margin);
      cur_x += this.col_widths[1];
   }

   var fixed_offset = (this.showRecordNumber ? 2 : 1);
   if(this.left_col < fixed_offset)
   {
      this.left_col = fixed_offset;
   }

   if(row !== this.fixed_table_header)
   {
      context.fillStyle = this.fontColorContents;
      context.font = this.fontContents;
   }
   var i;
   for(i = this.left_col; i < this.col_count && cur_x < this.width; i++)
   {
      context.fillText(row[i], cur_x + this.col_widths[i] / 2.0, y_pos + this.margin);
      cur_x += this.col_widths[i];
   }

   context.strokeRect(0, y_pos - 2 * this.margin, this.width, this.row_height);
};


CsiTable.prototype.draw_scrollbars = function (context)
{
   if(this.needs_vscrollbar)
   {
      this.draw_vscrollbar(context);
   }

   if(this.needs_hscrollbar)
   {
      this.draw_hscrollbar(context);
   }

   //Draw the bottom right corner
   if(this.needs_vscrollbar && this.needs_hscrollbar)
   {
      context.fillStyle = "#F0F0F0";
      context.fillRect(this.width - SCROLL_BTN_SIZE, this.height - SCROLL_BTN_SIZE, SCROLL_BTN_SIZE, SCROLL_BTN_SIZE);
   }
};


CsiTable.prototype.draw_vscrollbar = function (context)
{
   //Draw the vertical scrollbar
   context.lineWidth = 1;
   context.fillStyle = "#F0F0F0";
   context.fillRect(this.width - SCROLL_BTN_SIZE, 0, SCROLL_BTN_SIZE, this.height - (this.needs_hscrollbar ? SCROLL_BTN_SIZE : 0));
   context.lineWidth = 1;
   context.strokeStyle = "#999999";
   context.strokeRect(this.width - SCROLL_BTN_SIZE, 0, SCROLL_BTN_SIZE, this.height - (this.needs_hscrollbar ? SCROLL_BTN_SIZE : 0));

   //Draw the up and down scroll buttons
   this.draw_arrow_btn(context, this.width - SCROLL_BTN_SIZE, 0, Enum.ScrollBarBtn.UP);
   this.draw_arrow_btn(context, this.width - SCROLL_BTN_SIZE, this.height - (this.needs_hscrollbar ? (2 * SCROLL_BTN_SIZE) : SCROLL_BTN_SIZE), Enum.ScrollBarBtn.DOWN);

   //Calculate the available track height
   var avail_height = this.height - (2 * SCROLL_BTN_SIZE);

   //If there is also a horizontal scrollbar, offset the height by the horizontal scrollbar height
   if(this.needs_hscrollbar)
   {
      avail_height -= SCROLL_BTN_SIZE;
   }

   var scroll_steps = avail_height / ((this.rows.length - this.max_visible_rows));
   var btn_size = scroll_steps;
   if(btn_size < 12) //Keep the btn at least 12 px
   {
      btn_size = 12;
      avail_height -= btn_size;
      scroll_steps = avail_height / ((this.rows.length - this.max_visible_rows));
   }

   var ypos = scroll_steps * this.top_row + SCROLL_BTN_SIZE + 3;
   if((ypos + 1 + btn_size - 8) > (this.height - (this.needs_hscrollbar ? (2 * SCROLL_BTN_SIZE) : SCROLL_BTN_SIZE)))
   {
      ypos = this.height - (this.needs_hscrollbar ? (2 * SCROLL_BTN_SIZE) : SCROLL_BTN_SIZE) - btn_size + 3;
   }
   context.strokeStyle = "#959595";
   context.strokeRect(this.width - 21, ypos, 17, btn_size - 6);

   context.fillStyle = "#FAFAFA";
   context.fillRect(this.width - 20, ypos + 1, 15, btn_size - 8);

   //Draw the 3 lines on the button if it is big enough
   if(btn_size > 15)
   {
      context.fillStyle = "#999999";
      var mid_pos = ypos + btn_size / 2 - 4;
      context.fillRect(this.width - 16, mid_pos, 7, 2);
      context.fillRect(this.width - 16, mid_pos - 3, 7, 2);
      context.fillRect(this.width - 16, mid_pos + 3, 7, 2);
   }
};


CsiTable.prototype.draw_hscrollbar = function (context)
{
   context.fillStyle = "#F0F0F0";
   context.fillRect(0, this.height - SCROLL_BTN_SIZE, this.width - (this.needs_vscrollbar ? SCROLL_BTN_SIZE : 0), SCROLL_BTN_SIZE);
   context.lineWidth = 1;
   context.strokeStyle = "#999999";
   context.strokeRect(0, this.height - SCROLL_BTN_SIZE, this.width - (this.needs_vscrollbar ? SCROLL_BTN_SIZE : 0), SCROLL_BTN_SIZE);

   this.draw_arrow_btn(context, 0, this.height - SCROLL_BTN_SIZE, Enum.ScrollBarBtn.LEFT);
   this.draw_arrow_btn(context, this.width - (this.needs_vscrollbar ? (2 * SCROLL_BTN_SIZE) : SCROLL_BTN_SIZE), this.height - SCROLL_BTN_SIZE, Enum.ScrollBarBtn.RIGHT);

   var avail_width = this.width - (2 * SCROLL_BTN_SIZE);
   if(this.needs_vscrollbar)
   {
      avail_width -= SCROLL_BTN_SIZE;
   }
   var scroll_steps = avail_width / (this.col_count - (this.showRecordNumber ? 2 : 1)); //Offset by fixed cols
   var btn_size = scroll_steps;
   if(btn_size < 12) //Keep the btn at least 12 px
   {
      btn_size = 12;
      avail_width -= btn_size;
      scroll_steps = avail_width / (this.col_count - (this.showRecordNumber ? 2 : 1)); //Offset by fixed cols
   }

   var xpos = scroll_steps * (this.left_col - (this.showRecordNumber ? 2 : 1)); //Offset by fixed cols
   context.strokeStyle = "#959595";
   context.strokeRect(xpos + 28, this.height - 21, btn_size - 6, 17);

   context.fillStyle = "#FAFAFA";
   context.fillRect(xpos + 29, this.height - 20, btn_size - 8, 15);

   //Draw the 3 lines on the button if it is big enough
   if(btn_size > 15)
   {
      context.fillStyle = "#999999";
      var mid_pos = xpos + 28 + btn_size / 2 - 4;
      context.fillRect(mid_pos, this.height - 16, 2, 7);
      context.fillRect(mid_pos - 3, this.height - 16, 2, 7);
      context.fillRect(mid_pos + 3, this.height - 16, 2, 7);
   }
};


CsiTable.prototype.deactivate = function ()
{
   CsiComponent.prototype.deactivate.call(this);
   csiMouseEvents.hideMenu();
};



//right mouse button click.  Show popup "Acknowledge Alarm" menu item
CsiTable.prototype.OnRButtonClick = function (mouseX, mouseY)
{
   var component = this;
   csiMouseEvents.hideMenu();

   $("<div id='context'></div>").html("<ul class='context_menu'><li id='export_data' class='menu_item'>Export Data</li><li id='clear_data' class='menu_item'>Remove All Data</li><li class='menu_item'>Cancel</li></ul>")
      .css({
         position: 'absolute',
         zIndex: '9999',
         left: mouseX + $('#rtmc_canvas').offset().left,
         top: mouseY + $('#rtmc_canvas').offset().top
      }).show().appendTo('body');

   $('ul.context_menu').css({
      listStyle: 'none',
      padding: '1px',
      margin: '0px',
      backgroundColor: '#fff',
      border: '1px solid #999',
      width: 'auto'
   });

   $('li.menu_item').mouseover(function ()
   {
      $(this).css({
         backgroundColor: '#E9EFF8'
      });
   }).mouseout(function ()
   {
      $(this).css({
         backgroundColor: 'transparent'
      });
   }).css({
      width: 'auto',
      margin: '0px',
      color: '#000',
      display: 'block',
      cursor: 'default',
      padding: '3px',
      border: '1px solid #fff',
      backgroundColor: 'transparent'
   }).click(function ()
   {
      csiMouseEvents.hideMenu();
   });

   $('#export_data').click(function ()
   {
      var col_count = 0;
      var i;
      for(i = 0; i < component.col_count; ++i)
      {
         col_count += component.col_char_counts[i] + 4; //pad each column
      }

      var row_count = component.rows.length;
      var generator = window.open('', '_blank', 'location=no,menubar=yes,titlebar=yes,toolbar=yes,resizable=yes,scrollbars=yes', true);

      var doc_contents = "";
      doc_contents += '<html><head><title>Data Export</title></head><body>';
      doc_contents += '<textArea cols=' + col_count + ' rows=' + row_count + ' title="Data Export" readOnly="true" wrap="off" >';
      //Write the header first
      var fh;
      for(fh = 0; fh < component.col_count; ++fh)
      {
         if(fh > 0)
         {
            doc_contents += ', ';
         }
         //Quote all the header labels
         doc_contents += '"' + component.fixed_table_header[fh] + '"';
      }
      generator.document.write(doc_contents);
      doc_contents = "";

      //Write out each row
      var r;
      for(r = 0; r < row_count; ++r)
      {
         var current_row = component.rows[r];
         var c;
         for(c = 0; c < component.col_count; ++c)
         {
            if(c === 0) //Is this a new line?
            {
               doc_contents += '\r\n';
            }
            else
            {
               doc_contents += ', ';
            }

            //Quote strings and dates if needed
            var needs_quote = (c === 0); //Timestamp always needs quoted
            if(!needs_quote)
            {
               var offset = 1; //Timestamp always shown
               if(this.showRecordNumber)
               {
                  offset = 2;
                  if(c === 1)
                  {
                     needs_quote = false;
                  }
               }

               if((c - offset) >= 0)
               {
                  var col_type = component.col_types[c - offset];
                  if(col_type === Enum.ColDataTypes.DATE || col_type === Enum.ColDataTypes.STRING)
                  {
                     needs_quote = true;
                  }
               }
            }

            if(needs_quote)
            {
               doc_contents += '"' + current_row[c] + '"';
            }
            else
            {
               doc_contents += current_row[c];
            }
         }
      }
      doc_contents += '</textArea></body></html>';

      generator.document.write(doc_contents);
      doc_contents = "";

      generator.document.close();
   });
   $('#clear_data').click(function ()
   {
      component.rows = [];
      component.invalidate();
   });
};


CsiTable.prototype.OnLButtonDown = function (mouseX, mouseY)
{
   this.buttonDown = true;
   var hit_btn = this.scroll_btn_hit_test(mouseX, mouseY);
   switch(hit_btn)
   {
      case Enum.ScrollBarBtn.NONE:
         return false;
      default:
         return true;
   }
};


CsiTable.prototype.OnLButtonUp = function (mouseX, mouseY)
{
   if(this.buttonDown)
   {
      var hit_btn = this.scroll_btn_hit_test(mouseX, mouseY);
      switch(hit_btn)
      {
         case Enum.ScrollBarBtn.UP:
            this.top_row -= 1;
            if(this.top_row < 0)
            {
               this.top_row = 0;
            }
            this.invalidate();
            break;
         case Enum.ScrollBarBtn.DOWN:
            this.top_row += 1;
            if(this.top_row > this.rows.length - this.max_visible_rows)
            {
               this.top_row = this.rows.length - this.max_visible_rows;
            }
            this.invalidate();
            break;
         case Enum.ScrollBarBtn.LEFT:
            this.left_col -= 1;
            if(this.left_col < 0)
            {
               this.left_col = 0;
            }
            this.invalidate();
            break;
         case Enum.ScrollBarBtn.RIGHT:
            this.left_col += 1;
            if(this.left_col > this.col_count - 1)
            {
               this.left_col = this.col_count - 1;
            }
            this.invalidate();
            break;
         case Enum.ScrollBarBtn.HSCROLLER:
            var scroll_x_click = mouseX - this.left - SCROLL_BTN_SIZE;
            var avail_width = this.width - (2 * SCROLL_BTN_SIZE);
            if(this.needs_vscrollbar)
            {
               avail_width -= SCROLL_BTN_SIZE;
            }
            var percent_x = scroll_x_click / avail_width;
            this.left_col = parseFloat(((this.col_count - 1) * percent_x).toFixed(0));
            this.invalidate();
            break;
         case Enum.ScrollBarBtn.VSCROLLER:
            var scroll_y_click = mouseY - this.top - SCROLL_BTN_SIZE;
            var avail_height = this.height - (2 * SCROLL_BTN_SIZE);
            if(this.needs_hscrollbar)
            {
               avail_height -= SCROLL_BTN_SIZE;
            }
            var percent_y = scroll_y_click / avail_height;
            this.top_row = parseFloat((((this.rows.length) - this.max_visible_rows) * percent_y).toFixed(0));
            this.invalidate();
            break;
         //case Enum.ScrollBarBtn.NONE:        
         default:
            break;
      }
   }
   this.buttonDown = false;
};


CsiTable.prototype.OnMouseDrag = function (mouseX, mouseY)
{
   var rtn = false;
   var hit_btn = this.scroll_btn_hit_test(mouseX, mouseY);
   switch(hit_btn)
   {
      case Enum.ScrollBarBtn.HSCROLLER:
         var scroll_x_click = mouseX - this.left - SCROLL_BTN_SIZE;
         var avail_width = this.width - (2 * SCROLL_BTN_SIZE);
         if(this.needs_vscrollbar)
         {
            avail_width -= SCROLL_BTN_SIZE;
         }
         var percent_x = scroll_x_click / avail_width;
         this.left_col = parseFloat(((this.col_count - 1) * percent_x).toFixed(0));
         this.invalidate();
         rtn = true;
         break;
      case Enum.ScrollBarBtn.VSCROLLER:
         var scroll_y_click = mouseY - this.top - SCROLL_BTN_SIZE;
         var avail_height = this.height - (2 * SCROLL_BTN_SIZE);
         if(this.needs_hscrollbar)
         {
            avail_height -= SCROLL_BTN_SIZE;
         }
         var percent_y = scroll_y_click / avail_height;
         if(percent_y > 0.97)
         {
            percent_y = 1.0;
         }
         this.top_row = parseFloat(((this.rows.length - this.max_visible_rows) * percent_y).toFixed(0));
         this.invalidate();
         rtn = true;
         break;
      //case Enum.ScrollBarBtn.NONE:      
      //case Enum.ScrollBarBtn.UP:      
      //case Enum.ScrollBarBtn.DOWN:      
      //case Enum.ScrollBarBtn.LEFT:      
      //case Enum.ScrollBarBtn.RIGHT:      
      default:
         break;
   }
   return rtn; //Prevent default behavior
};


CsiTable.prototype.OnMouseMove = function (mouseX, mouseY)
{
   var rtn = false;
   if(this.scroll_btn_hit_test(mouseX, mouseY) !== Enum.ScrollBarBtn.NONE)
   {
      document.body.style.cursor = "pointer";
      rtn = true; //Prevent default behavior
   }
   else
   {
      document.body.style.cursor = "default";
      rtn = false;
   }
   return rtn;
};


CsiTable.prototype.OnMouseExit = function ()
{
   document.body.style.cursor = "default";
   this.buttonDown = false;
   return true; //Prevent default behavior
};


CsiTable.prototype.scroll_btn_hit_test = function (mouseX, mouseY)
{
   var relX = mouseX - this.left;
   var relY = mouseY - this.top;
   //See if we can find where we are clicking
   var rtn = Enum.ScrollBarBtn.NONE;
   if(this.needs_hscrollbar && relY > this.height - SCROLL_BTN_SIZE)
   {
      if(relX <= SCROLL_BTN_SIZE)
      {
         rtn = Enum.ScrollBarBtn.LEFT;
      }
      else
      {
         if(relX >= (this.width - (this.needs_vscrollbar ? (2 * SCROLL_BTN_SIZE) : SCROLL_BTN_SIZE)) &&
            relX < (this.width - (this.needs_vscrollbar ? (2 * SCROLL_BTN_SIZE) : SCROLL_BTN_SIZE)) + SCROLL_BTN_SIZE)
         {
            rtn = Enum.ScrollBarBtn.RIGHT;
         }
         else if(relX > SCROLL_BTN_SIZE && relX < (this.width - (this.needs_vscrollbar ? (2 * SCROLL_BTN_SIZE) : SCROLL_BTN_SIZE)))
         {
            rtn = Enum.ScrollBarBtn.HSCROLLER;
         }
      }
   }
   else if(this.needs_vscrollbar && relX > this.width - SCROLL_BTN_SIZE)
   {
      if(relY <= SCROLL_BTN_SIZE)
      {
         rtn = Enum.ScrollBarBtn.UP;
      }
      else
      {
         if(relY >= (this.height - (this.needs_hscrollbar ? (2 * SCROLL_BTN_SIZE) : SCROLL_BTN_SIZE)) &&
            relY < (this.height - (this.needs_hscrollbar ? (2 * SCROLL_BTN_SIZE) : SCROLL_BTN_SIZE)) + SCROLL_BTN_SIZE)
         {
            rtn = Enum.ScrollBarBtn.DOWN;
         }
         else if(relY > SCROLL_BTN_SIZE && relY < (this.height - (this.needs_hscrollbar ? (2 * SCROLL_BTN_SIZE) : SCROLL_BTN_SIZE)))
         {
            rtn = Enum.ScrollBarBtn.VSCROLLER;
         }
      }
   }
   return rtn;
};


CsiTable.prototype.draw_arrow_btn = function (context, x, y, direction)
{
   context.save();
   context.translate(x + 12.5, y + 12.5);
   switch(direction)
   {
      case Enum.ScrollBarBtn.RIGHT:
         context.rotate(Math.PI * 0.5);
         break;
      case Enum.ScrollBarBtn.DOWN:
         context.rotate(Math.PI);
         break;
      case Enum.ScrollBarBtn.LEFT:
         context.rotate(Math.PI * 1.5);
         break;
      //case Enum.ScrollBarBtn.UP:  
      default:
         break;
   }

   context.lineJoin = "round";
   context.strokeStyle = "#999999";
   context.fillStyle = "#333333";
   context.strokeRect(-12.5, -12.5, SCROLL_BTN_SIZE, SCROLL_BTN_SIZE);
   context.beginPath();
   context.moveTo(-5, 5);
   context.lineTo(0, -5);
   context.lineTo(5, 5);
   context.closePath();
   context.fill();
   context.restore();
};


CsiTable.prototype.get_type = function (xsd_type)
{
   var rtn = Enum.ColDataTypes.OTHER;
   if(xsd_type === "xsd:dateTime")
   {
      rtn = Enum.ColDataTypes.DATE;
   }
   else if(xsd_type === "xsd:float" || xsd_type === "xsd:double")
   {
      rtn = Enum.ColDataTypes.FLOAT;
   }
   else if(xsd_type === "xsd:string")
   {
      rtn = Enum.ColDataTypes.STRING;
   }
   else if(xsd_type === "xsd:int")
   {
      rtn = Enum.ColDataTypes.INT;
   }
   else if(xsd_type === "xsd:boolean")
   {
      rtn = Enum.ColDataTypes.BOOL;
   }
   return rtn;
};


CsiTable.prototype.reset_data = function ()
{
   this.bad_data = true;
   this.rows = [];
   this.maxRecords = Number.MAX_VALUE;
   this.top_row = 0;
   this.needs_vscrollbar = false;
   this.needs_hscrollbar = false;
};


Enum.ScrollBarBtn =
{
   NONE: -1,
   UP: 0,
   RIGHT: 1,
   DOWN: 2,
   LEFT: 3,
   HSCROLLER: 4,
   VSCROLLER: 5
};


Enum.ColDataTypes =
{
   DATE: 0,
   FLOAT: 1,
   STRING: 2,
   INT: 3,
   BOOL: 4,
   OTHER: 5
};/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiLabel.js $

Copyright (C) 2010 Campbell Scientific, Inc.
Started On: 10/5/2010 7:51:33 AM
Started By: Kevin Westwood

$LastChangedBy: tmecham $
$LastChangedDate: 2013-03-05 13:06:09 -0700 (Tue, 05 Mar 2013) $
$LastChangedRevision: 17505 $
 */

function CsiLabel(left, top, width, height, caption)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   CsiComponent.call(this, left, top, width, height);

   this.caption = caption || "";
   this.multiline_caption = String(this.caption);
   this.font = "12pt Arial";
   this.font_color = "rgba(0, 0, 0, 1)";
   this.displayVertically = false;
   this.transparent = false;
   this.background_color = "white";
   this.textAlign = Enum.ALIGNMENT.CENTER;
   this.textBaseline = "middle";
   this.word_wrap = false;
   this.max_line_count = 1;
   this.max_char_per_line = 1;
   this.multilines = null;
   this.bad_data = false;
   this.force_multiline = false; //For ReportNote
}
CsiLabel.prototype = new CsiComponent();


CsiLabel.prototype.draw = function (context)
{
   var i = 0;
   context.translate(this.left, this.top); //move to location
   clipRect(context, 0, 0, this.width, this.height);

   if(!this.transparent)
   {
      context.fillStyle = this.background_color;
      context.fillRect(0, 0, this.width, this.height);
   }

   context.font = this.font;
   context.textBaseline = this.textBaseline;
   context.fillStyle = this.font_color;

   if(this.displayVertically)
   {
      context.textAlign = "center";
      var text_height = context.measureText("W").width;
      var len = this.caption.length;
      var x_offset = this.width / 2;
      var y_offset = 0;

      for(i = 0; i < len; i++)
      {
         switch(this.textAlign)
         {
            case Enum.ALIGNMENT.LEFT: //Top
               if(i === 0)
               {
                  y_offset = text_height + 5;
               }
               context.fillText(this.caption[i], x_offset, y_offset);
               y_offset += text_height;
               break;
            case Enum.ALIGNMENT.CENTER: //Middle
               if(i === 0)
               {
                  y_offset = (this.height / 2) - ((text_height * len) / 2 + 5);
               }
               context.fillText(this.caption[i], x_offset, y_offset);
               y_offset += text_height;
               break;
            case Enum.ALIGNMENT.RIGHT: //Bottom
               if(i === 0)
               {
                  y_offset = this.height - (text_height * len + 5);
               }
               context.fillText(this.caption[i], x_offset, y_offset);
               y_offset += text_height;
               break;
         }
      }
   }
   else
   {
      var char_size = context.measureText("W").width * 1.1;
      if(!this.multilines || this.multiline_caption != this.caption) 
      {
         this.multilines = this.getLines(context, this.caption, this.width);
         this.multiline_caption = String(this.caption); //cache this so we can see if it changes
      }

      if(this.force_multiline || this.multilines.length > 1)
      {
         context.textBaseline = "top";
         var line_count = this.multilines.length;
         this.max_line_count = this.height / char_size;
         this.max_char_per_line = this.width / char_size;
         var total_char_height = char_size * line_count;

         var cur_height = 0;
         if(!this.force_multiline)
         {
            cur_height = this.height / 2.0 - total_char_height / 2.0;
         }

         for(i = 0; i < line_count; i++)
         {
            var cur_line = this.multilines[i];
            switch(this.textAlign)
            {
               case Enum.ALIGNMENT.LEFT:
                  context.textAlign = "left";
                  context.fillText(cur_line, char_size / 4, cur_height);
                  break;
               case Enum.ALIGNMENT.CENTER:
                  context.textAlign = "center";
                  context.fillText(cur_line, this.width / 2, cur_height);
                  break;
               case Enum.ALIGNMENT.RIGHT:
                  context.textAlign = "right";
                  context.fillText(cur_line, this.width - char_size / 4, cur_height);
                  break;
               default:
                  break;
            }
            cur_height += char_size;
         }
      }
      else
      {
         switch(this.textAlign)
         {
            case Enum.ALIGNMENT.CENTER:
               context.textAlign = "center";
               context.fillText(this.caption, this.width / 2, this.height / 2);
               break;
            case Enum.ALIGNMENT.LEFT:
               context.textAlign = "left";
               context.fillText(this.caption, char_size / 4, this.height / 2);
               break;
            case Enum.ALIGNMENT.RIGHT:
               context.textAlign = "right";
               context.fillText(this.caption, this.width - char_size / 4, this.height / 2);
               break;
            default:
               break;
         }
      }
   }
   this.drawBorder(context, new Rect(0, 0, this.width, this.height), this.border_style);
};


CsiLabel.prototype.getLines = function (context, phrase, allowed_width)
{
   //Break up the entire string into linefeeds using all possible line endings
   var linefeeds = phrase.split("\r\n");
   if(linefeeds.length === 1)
   {
      linefeeds = phrase.split("\r");
   }

   if(linefeeds.length === 1)
   {
      linefeeds = phrase.split("\n");
   }

   if(!this.word_wrap)
   {
      return linefeeds; //Just return the array of hard line feeds if no word wrap
   }
   else //Break each of these linefeeds into word wraps if enabled
   {
      var rtn = [];
      var linefeed_count = linefeeds.length;
      var i, j;
      for(i = 0; i < linefeed_count; i++)
      {
         var cur_phrase = "";
         var measure = 0;
         var cur_line = linefeeds[i];
         var words = cur_line.split(" "); //Break line feeds up into words one line at a time
         var word_count = words.length;
         if(word_count > 1)
         {
            for(j = 0; j < word_count; j++)
            {
               //Add the next word onto the phrase and see if it fits
               var test_phrase = cur_phrase;
               if(test_phrase.length)
               {
                  test_phrase += " ";
               }
               test_phrase += words[j];
               measure = context.measureText(test_phrase).width;
               if(measure < allowed_width) //It fits
               {
                  cur_phrase = test_phrase;
               }
               else //Didn't fit, so end the line we had and start a new one
               {
                  rtn.push(cur_phrase);
                  cur_phrase = words[j];
               }
            }

            //Add the last phrase to the rtn
            rtn.push(cur_phrase);
         }
         else //Only one word, so just push it on the rtn array
         {
            rtn.push(words[0]);
         }
      }
      return rtn;
   }
};
/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiGaugePointer.js $

Copyright (C) 2010 Campbell Scientific, Inc.
Started On: 10/5/2010 7:54:41 AM
Started By: Tyler Mecham

$LastChangedBy: tmecham $
$LastChangedDate: 2013-03-05 13:06:09 -0700 (Tue, 05 Mar 2013) $
$LastChangedRevision: 17505 $
*/


function CsiGaugePointer(gauge, expression)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   if(expression)
   {
      this.expression = expression;
      this.expression.ownerComponent = this;
   }
   else
   {
      this.expression = null;
   }

   this.ownerGauge = gauge;
   this.animating = false;
   this.width_percent = 0.1;
   this.length_percent = 1.0;
   this.margin = 0;
   this.style = Enum.GAUGE_POINTER_TYPE.TRIANGLE;
   this.color = "green";
   this.line_start = Enum.LINE_END_STYLE.LineCapArrowAnchor;
   this.line_end = Enum.LINE_END_STYLE.LineCapRoundAnchor;
   this.first_data = true;
   this.track = Enum.TRACK_OPTION.NORMAL;
   this.step_to_target = 0;
   this.target_value = this.ownerGauge.scale_min;
   this.cur_value = this.last_value = gauge.scale_min;
   this.fill_gradient = null;
   this.reset_max_min();
   this.bad_data = true;
   this.nan_data = false;
}


CsiGaugePointer.prototype.invalidate = function ()
{
   this.ownerGauge.valid = false;
   graphicsManager.componentInvalidate(this.ownerGauge);
};


CsiGaugePointer.prototype.newValue = function (value)
{
   this.last_value = value;
   this.bad_data = false;
   if(this.first_data || (this.target_value !== value))
   {
      if(this.first_data)
      {
         this.reset_max_min();
         this.target_value = value;

         //no animation for first data of max/min pointers
         if((this.track === Enum.TRACK_OPTION.MAX) ||
             (this.track === Enum.TRACK_OPTION.MIN))
         {
            this.cur_value = value;
         }

         this.first_data = false;
      }

      if(this.track === Enum.TRACK_OPTION.MAX)
      {
         if(value > this.target_value)
         {
            this.target_value = value;
         }
      }
      else if(this.track === Enum.TRACK_OPTION.MIN)
      {
         if(value < this.target_value)
         {
            this.target_value = value;
         }
      }
      else
      {
         this.target_value = value;
      }

      if((graphicsManager.animation_disabled) || (!this.ownerGauge.active))
      {
         this.cur_value = this.target_value;
      }
      this.animating = this.target_value !== this.cur_value;
      this.ownerGauge.invalidate();
   }
};


CsiGaugePointer.prototype.reset_max_min = function ()
{
   if(this.first_data)
   {
      if(this.track === Enum.TRACK_OPTION.MAX)
      {
         this.cur_value = this.ownerGauge.scale_min;
      }
      else if(this.track === Enum.TRACK_OPTION.MIN)
      {
         this.cur_value = this.ownerGauge.scale_max;
      }
   }
   else
   {
      this.cur_value = this.target_value = this.last_value;
   }
};


CsiGaugePointer.prototype.updateAnimation = function ()
{
   if(this.cur_value !== this.target_value)
   {
      try
      {
         this.step_to_target = (this.target_value - this.cur_value) / 2.0;
         this.cur_value += this.step_to_target;

         //if percent difference < .1 stop animation
         var max;
         var min;
         if(this.ownerGauge.logarithmic)
         {
            max = Math.log(this.ownerGauge.scale_max) / Math.log(10.0);
            min = this.ownerGauge.scale_min;
            if(min <= 0)
            {
               min = 1;
            }
            min = Math.log(min) / Math.log(10.0);
         }
         else
         {
            max = this.ownerGauge.scale_max;
            min = this.ownerGauge.scale_min;
         }

         var percentDiff = Math.abs(this.step_to_target / (max - min));
         if(percentDiff > 0.001)
         {
            this.animating = true;
         }
         else
         {
            this.cur_value = this.target_value;
            this.animating = false;
         }
      }
      catch(exception)
      {
         this.cur_value = this.target_value;
         this.animating = false;
      }
   }
};


CsiGaugePointer.prototype.draw = function (context)
{
   context.save();

   var draw_value = this.cur_value;
   if(this.ownerGauge.logarithmic)
   {
      //convert value to log10(value)
      draw_value = Math.log(draw_value) / Math.log(10.0);
   }

   var scale_max = this.ownerGauge.scale_max;
   var scale_min = this.ownerGauge.scale_min;

   if(draw_value > scale_max)
   {
      draw_value = scale_max;
   }
   else if(draw_value < scale_min)
   {
      draw_value = scale_min;
   }

   draw_value -= scale_min;

   var percent_full = draw_value / (scale_max - scale_min);

   if(this.ownerGauge.reverse_scale)
   {
      context.rotate(degreesToRadians(this.ownerGauge.start_angle + (this.ownerGauge.draw_range - (percent_full * this.ownerGauge.draw_range - 0.5))));
   }
   else
   {
      context.rotate(degreesToRadians(this.ownerGauge.start_angle + (percent_full * this.ownerGauge.draw_range - 0.5)));
   }

   switch(this.style)
   {
      case Enum.GAUGE_POINTER_TYPE.LINE:
         this.draw_style_line(context);
         break;
      //case Enum.GAUGE_POINTER_TYPE.TRIANGLE: 
      default:
         this.draw_style_triangle(context);
         break;
   }
   context.restore();
};


CsiGaugePointer.prototype.draw_style_triangle = function (context)
{
   var needle_length = this.ownerGauge.outer_arc_radius * this.length_percent;
   var needle_width = this.ownerGauge.outer_arc_radius * this.width_percent;
   var needle_left = -needle_width;
   var needle_top = -needle_length - this.margin;
   var needle_right = needle_width;
   var needle_bottom = -this.margin;

   if(!this.fill_gradient) 
   {
      this.fill_gradient = context.createLinearGradient(needle_left, 0, needle_right, 0);
      this.fill_gradient.addColorStop(0, this.color);
      this.fill_gradient.addColorStop(1, "white");
   }

   //Fill the triangle
   context.beginPath();
   context.moveTo(needle_left, needle_bottom);
   context.lineTo(0, needle_top);
   context.lineTo(needle_right, needle_bottom);
   context.closePath();

   context.fillStyle = this.fill_gradient;
   context.fill();

   context.lineWidth = 1;
   context.strokeStyle = "RGBA(0,0,0,.5)";
   context.stroke();
};


CsiGaugePointer.prototype.draw_style_line = function (context)
{
   var needle_length = this.ownerGauge.outer_arc_radius * this.length_percent;
   var needle_width = this.ownerGauge.outer_arc_radius * this.width_percent;
   var needle_left = -needle_width;
   var needle_top = -needle_length - this.margin;
   var needle_right = needle_width;
   var needle_bottom = -this.margin;
   var needle_radius = needle_width * 0.5;
   var line_top = needle_top;
   var line_bottom = needle_bottom;
   var line_left = needle_left * 0.5;
   var line_right = needle_right * 0.5;

   if(!this.fill_gradient) 
   {
      this.fill_gradient = context.createLinearGradient(needle_left, 0, needle_right * 1.5, 0);
      this.fill_gradient.addColorStop(0, this.color);
      this.fill_gradient.addColorStop(1, "white");
   }

   context.fillStyle = this.fill_gradient;
   //Fill the line
   context.beginPath();
   switch(this.line_start)
   {
      case Enum.LINE_END_STYLE.LineCapSquare:
         line_top = needle_top - needle_width * 0.5;
         break;
      case Enum.LINE_END_STYLE.LineCapRound:
         context.moveTo(0, needle_top);
         context.arc(0, needle_top, needle_radius, 0, Math.PI * 2.0, true);
         break;
      case Enum.LINE_END_STYLE.LineCapTriangle:
         var triangle_top = needle_top - needle_width * 0.5 + 1;
         context.moveTo(line_left, needle_top);
         context.lineTo(0, triangle_top);
         context.lineTo(line_right, needle_top);
         break;
      case Enum.LINE_END_STYLE.LineCapFlat:
      case Enum.LINE_END_STYLE.LineCapNoAnchor:
         break;
      case Enum.LINE_END_STYLE.LineCapSquareAnchor:
         context.moveTo(needle_left * 0.75, needle_top - needle_width * 0.75);
         context.lineTo(needle_right * 0.75, needle_top - needle_width * 0.75);
         context.lineTo(needle_right * 0.75, needle_top + needle_width * 0.75);
         context.lineTo(needle_left * 0.75, needle_top + needle_width * 0.75);
         context.lineTo(needle_left * 0.75, needle_top - needle_width * 0.75);
         break;
      case Enum.LINE_END_STYLE.LineCapRoundAnchor:
         context.moveTo(0, needle_top);
         context.arc(0, needle_top, needle_width, 0, 2 * Math.PI, true);
         break;
      case Enum.LINE_END_STYLE.LineCapDiamondAnchor:
         var diamond_top = line_top - needle_width;
         context.moveTo(0, diamond_top);
         context.lineTo(needle_left, diamond_top + needle_width);
         context.lineTo(0, diamond_top + needle_width * 2.0);
         context.lineTo(needle_right, diamond_top + needle_width);
         context.lineTo(0, diamond_top);
         break;
      case Enum.LINE_END_STYLE.LineCapArrowAnchor:
         context.moveTo(0, needle_top);
         context.lineTo(needle_left, needle_top + 1.5 * needle_width+1);
         context.lineTo(needle_right, needle_top + 1.5 * needle_width+1);
         context.lineTo(0, needle_top);

         line_top += 1.5 * needle_width;
         break;
   }
   context.fill();

   switch(this.line_end)
   {
      case Enum.LINE_END_STYLE.LineCapSquare:
         line_bottom += needle_radius;
         break;
      case Enum.LINE_END_STYLE.LineCapArrowAnchor:
         line_bottom -= 1.5 * needle_width;
         break;
      default:
         break;
   }

   context.beginPath();
   context.moveTo(line_left, line_bottom);
   context.lineTo(line_left, line_top);
   context.lineTo(line_right, line_top);
   context.lineTo(line_right, line_bottom);
   context.lineTo(line_left, line_bottom);
   context.fill();

   context.beginPath();
   context.moveTo(0, 0);
   switch(this.line_end)
   {
      case Enum.LINE_END_STYLE.LineCapSquare:
         line_bottom += needle_radius;
         break;
      case Enum.LINE_END_STYLE.LineCapRound:
         context.moveTo(0, needle_bottom);
         context.arc(0, needle_bottom, needle_radius, 0, Math.PI * 2.0, false);
         break;
      case Enum.LINE_END_STYLE.LineCapTriangle:
         context.moveTo(line_left, needle_bottom - 1.0);
         context.lineTo(0, needle_bottom + needle_width * 0.5);
         context.lineTo(line_right, needle_bottom - 1.0);
         break;
      case Enum.LINE_END_STYLE.LineCapFlat:
      case Enum.LINE_END_STYLE.LineCapNoAnchor:
         break;
      case Enum.LINE_END_STYLE.LineCapSquareAnchor:
         context.moveTo(needle_left * 0.75, needle_bottom - needle_width * 0.75);
         context.lineTo(needle_right * 0.75, needle_bottom - needle_width * 0.75);
         context.lineTo(needle_right * 0.75, needle_bottom + needle_width * 0.75);
         context.lineTo(needle_left * 0.75, needle_bottom + needle_width * 0.75);
         context.lineTo(needle_left * 0.75, needle_bottom - needle_width * 0.75);
         break;
      case Enum.LINE_END_STYLE.LineCapRoundAnchor:
         context.arc(0, line_bottom, needle_width, 0, 2 * Math.PI, false);
         break;
      case Enum.LINE_END_STYLE.LineCapDiamondAnchor:
         var diamond_bottom = line_bottom - needle_width;
         context.moveTo(0, diamond_bottom);
         context.lineTo(needle_left, diamond_bottom + needle_width);
         context.lineTo(0, diamond_bottom + needle_width * 2.0);
         context.lineTo(needle_right, diamond_bottom + needle_width);
         context.lineTo(0, diamond_bottom);
         break;
      case Enum.LINE_END_STYLE.LineCapArrowAnchor:
         context.moveTo(needle_left, line_bottom-1);
         context.lineTo(needle_right, line_bottom-1);
         context.lineTo(0, needle_bottom);
         context.lineTo(needle_left, line_bottom-1);
         break;
   }

   context.fill();
};


CsiGaugePointer.prototype.reset_data = function ()
{
   this.bad_data = true;
   this.target_value = this.ownerGauge.scale_min;
   this.cur_value = this.ownerGauge.scale_min;
   this.reset_max_min();
};


Enum.GAUGE_POINTER_TYPE =
{
   TRIANGLE: 0,
   LINE: 1
};
Enum.LINE_END_STYLE =
{
   LineCapFlat: 0,
   LineCapSquare: 1,
   LineCapRound: 2,
   LineCapTriangle: 3,
   LineCapNoAnchor: 4,
   LineCapSquareAnchor: 5,
   LineCapRoundAnchor: 6,
   LineCapDiamondAnchor: 7,
   LineCapArrowAnchor: 8
};
Enum.TRACK_OPTION =
{
   NORMAL: 0,
   MIN: 1,
   MAX: 2
};/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiGauge.js $

Copyright (C) 2010 Campbell Scientific, Inc.
Started On: 10/5/2010 7:54:50 AM
Started By: Tyler Mecham

$LastChangedBy: jon $
$LastChangedDate: 2013-04-29 13:33:06 -0600 (Mon, 29 Apr 2013) $
$LastChangedRevision: 18017 $
*/

/* global CsiGaugePointer: true */


function CsiGauge(left, top, width, height)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   CsiComponent.call(this, left, top, width, height);

   this.transparent = true;
   this.background_color = "#C0C0C0";
   this.step_to_target = 0;
   this.scale_max = 100.0;
   this.scale_min = 0;
   this.major_tick_count = 11;
   this.tick_label_precision = 0;
   this.reverse_scale = false;
   this.required_ends_margin = 0;
   this.the_font = "12pt Arial";
   this.transparent_rim = false;
   this.border_margin = 3;
   this.border_style = Enum.BORDER_STYLE.NONE;
   this.auto_label = false;
   this.ends_margin = 0;
   this.show_scale_labels = true;
   this.show_major_ticks = true;
   this.major_tick_length = 15;
   this.show_minor_ticks = true;
   this.minor_tick_count = 4;
   this.minor_tick_length = 5;
   this.major_tick_color = "#000000";
   this.minor_tick_color = "#000000";
   this.minor_tick_alignment = Enum.ALIGNMENT.CENTER;
   this.show_tick_axis = true;
   this.tick_label_margin = 0;
   this.tick_margin = 0;
   this.start_angle = 225;
   this.draw_range = 270;
   this.hub_size_percent = 0.1;
   this.show_hub = true;
   this.transparent = true;
   this.background_color = "#C0C0C0";
   this.hub_color = "#C0C0C0";
   this.hub_on_top = true;
   this.show_inner_arc = false;
   this.show_outer_arc = false;
   this.reverse_scale = false;
   this.logarithmic = false;

   this.rim_color = "#808080";
   this.font_color = "#000000";
   this.bg_outer_color = "#C0C0C0";
   this.bg_inner_color = "#FFFFFF";

   this.rim_gradient = null;
   this.bg_gradient = null;
   this.color_section_gradient = null;
   this.outer_arc_radius = 0;

   //Keep track of where we are, so we can re-orient to 0 if we need to
   this.current_rotation = 0;

   this.pointers = [];
   this.colored_sections = [];

   //Cache the text_height so we only have to calculate it once
   this.text_height = 0;
   this.needs_mouse_events = true;
}
CsiGauge.prototype = new CsiComponent();


CsiGauge.prototype.createPointer = function (expression)
{
   var pointer = new CsiGaugePointer(this, expression);
   this.pointers.push(pointer);
   return pointer;
};


CsiGauge.prototype.getBadData = function ()
{
   var len = this.pointers.length;
   var i;
   for(i = 0; i < len; i++)
   {
      if(this.pointers[i].bad_data)
      {
         return true;
      }
   }
   return false;
};


CsiGauge.prototype.getNanData = function ()
{
   var len = this.pointers.length;
   var i;
   for(i = 0; i < len; i++)
   {
      if(this.pointers[i].nan_data)
      {
         return true;
      }
   }
   return false;
};


function RTMCGaugeColoredSection(start, stop, color)
{
   this.start = start;
   this.stop = stop;
   this.color = color;
   this.radius = 0;

   this.color_section_gradient = null;
}


CsiGauge.prototype.createColoredSection = function (start, stop, color)
{
   var section = new RTMCGaugeColoredSection(start, stop, color);
   this.colored_sections.push(section);
   return section;
};


CsiGauge.prototype.draw = function (context)
{
   clipRect(context, this.left, this.top, this.width, this.height);

   //Store off the originals so we can change the scale for painting
   var orig_scale_max = this.scale_max;
   var orig_scale_min = this.scale_min;

   if(this.logarithmic)
   {
      //force scale_max and scale_min to be power of 10.
      //convert min/max to log10(min/max)
      this.scale_max = Math.ceil(Math.log(this.scale_max) / Math.log(10) - 0.0000001);
      if(this.scale_min <= 0)
      {
         this.scale_min = 1;
      }
      this.scale_min = Math.floor(Math.log(this.scale_min) / Math.log(10) + 0.0000001);

      //update major_tick_count to force major ticks to be on powers of 10.
      this.major_tick_count = Math.floor(this.scale_max - this.scale_min + 0.5) + 1;
   }

   if(this.text_height === 0)
   {
      context.font = this.the_font;
      this.text_height = context.measureText("W").width;
   }

   var center_x = this.left + this.width / 2.0;
   var center_y = this.top + this.height / 2.0;
   var radius = this.width / 2.0 - 2;
   if(this.width > this.height)
   {
      radius = this.height / 2.0 - 2;
   }

   if(!this.transparent)
   {
      context.fillStyle = this.background_color;
      context.fillRect(this.left, this.top, this.width, this.height);
   }
   this.drawBorder(context, new Rect(this.left, this.top, this.width, this.height), this.border_style);

   var rim_radius = radius * 0.915;
   if(!this.transparent_rim)
   {
      // Draw the Rim
      if(!this.rim_gradient) 
      {
         this.rim_gradient = context.createLinearGradient(
            center_x - radius,
            center_y - radius,
            center_x + radius,
            center_y + radius);
         this.rim_gradient.addColorStop(0.2, 'white');
         this.rim_gradient.addColorStop(0.5, this.rim_color);
         this.rim_gradient.addColorStop(0.9, 'white');
      }

      context.beginPath();
      context.arc(center_x, center_y, radius, 0, Math.PI * 2, false);
      context.closePath();

      context.fillStyle = this.rim_gradient;
      context.fill();

      context.strokeStyle = this.rim_color;
      context.lineWidth = 2.5;
      context.stroke();

      // Draw the gauge section
      if(!this.bg_gradient) 
      {
         this.bg_gradient = context.createRadialGradient(
            center_x,
            center_y,
            0.0,
            center_x,
            center_y,
            rim_radius);
         this.bg_gradient.addColorStop(0.0, this.bg_inner_color);
         this.bg_gradient.addColorStop(1.0, this.bg_outer_color);
      }
      context.beginPath();
      context.arc(center_x, center_y, rim_radius, 0, Math.PI * 2, false);
      context.closePath();

      context.fillStyle = this.bg_gradient;
      context.fill();

      context.strokeStyle = this.rim_color;
      context.lineWidth = 2.5;
      context.stroke();
   }

   context.translate(center_x, center_y);

   if(this.scale_max !== this.scale_min)
   {
      context.save();
      this.draw_colored_sections(context, rim_radius);

      context.lineWidth = 0.5;
      this.outer_arc_radius = rim_radius - (1.3 * this.text_height);
      if(this.show_outer_arc)
      {
         context.beginPath();
         context.arc(
            0, 0,
            this.outer_arc_radius,
            degreesToRadians(this.start_angle - 90),
            degreesToRadians(this.start_angle + this.draw_range - 90),
            false);
         context.strokeStyle = "#000000";
         context.stroke();
      }
      if(this.show_inner_arc)
      {
         context.beginPath();
         context.arc(
            0, 0,
            rim_radius - this.major_tick_length - (1.3 * this.text_height),
            degreesToRadians(this.start_angle - 90),
            degreesToRadians(this.start_angle + this.draw_range - 90),
            false);
         context.strokeStyle = "#000000";
         context.stroke();
      }
      this.draw_scale(context, rim_radius);
      context.restore();
   }

   if(this.hub_on_top)
   {
      this.draw_pointers(context);
      this.draw_hub(context);
   }
   else
   {
      this.draw_hub(context);
      this.draw_pointers(context);
   }

   //restore the original scale now that we are done painting
   this.scale_max = orig_scale_max;
   this.scale_min = orig_scale_min;
};


CsiGauge.prototype.updateAnimation = function ()
{
   var len = this.pointers.length;
   var i;
   for(i = 0; i < len; i++)
   {
      this.pointers[i].updateAnimation();
   }
};


CsiGauge.prototype.getAnimating = function ()
{
   var len = this.pointers.length;
   var i;
   for(i = 0; i < len; i++)
   {
      if(this.pointers[i].animating)
      {
         return true;
      }
   }

   return false;
};


CsiGauge.prototype.draw_pointers = function (context)
{
   if(this.scale_max !== this.scale_min)
   {
      var len = this.pointers.length;
      var i;
      for(i = 0; i < len; i++)
      {
         this.pointers[i].draw(context);
      }
   }
};


CsiGauge.prototype.draw_hub = function (context)
{
   //Draw the hub
   if(this.show_hub)
   {
      var hub_radius = this.hub_size_percent * this.outer_arc_radius;
      context.fillStyle = "black"; //Canvas bug?  alpha carries over from last draw in triangle if I don't set this
      var hub_gradient = context.createLinearGradient(
         -hub_radius,
         0,
         hub_radius,
         0);
      hub_gradient.addColorStop(0.0, this.hub_color);
      hub_gradient.addColorStop(1.0, "white");
      context.beginPath();
      context.arc(0, 0, hub_radius, 0, Math.PI * 2, false);
      context.closePath();

      context.fillStyle = hub_gradient;
      context.fill();

      context.lineWidth = 1;
      context.strokeStyle = "RGBA(0,0,0,.5)";
      context.stroke();
   }
};


CsiGauge.prototype.draw_colored_sections = function (context, rim_radius)
{
   if(this.text_height === 0)
   {
      context.font = this.the_font;
      this.text_height = context.measureText("W").width;
   }

   var scale_range = this.scale_max - this.scale_min;
   var gradient_radius = rim_radius - (1.3 * this.text_height);
   var arc_radius = gradient_radius - this.major_tick_length / 2.0;
   var len = this.colored_sections.length;
   var begin, end, i;
   for(i = 0; i < len; i++)
   {
      var cur_section = this.colored_sections[i];
      var start;
      var stop;

      if(this.logarithmic)
      {
         start = Math.log(this.colored_sections[i].start) / Math.log(10);
         stop = Math.log(this.colored_sections[i].stop) / Math.log(10.0);
      }
      else
      {
         start = this.colored_sections[i].start;
         stop = this.colored_sections[i].stop;
      }

      if(stop < start)
      {
         var temp = start;
         start = stop;
         stop = temp;
      }

      if(stop < this.scale_min)
      {
         stop = this.scale_min;
      }
      else if(stop > this.scale_max)
      {
         stop = this.scale_max;
      }

      if(start < this.scale_min)
      {
         start = this.scale_min;
      }
      else if(start > this.scale_max)
      {
         start = this.scale_max;
      }

      if(start !== stop)
      {
         if(!cur_section.color_section_gradient || cur_section.radius !== gradient_radius) 
         {
            cur_section.color_section_gradient =
               context.createRadialGradient(0, 0, gradient_radius, 0, 0, gradient_radius - this.major_tick_length);
            cur_section.color_section_gradient.addColorStop(0.0, this.colored_sections[i].color);
            cur_section.color_section_gradient.addColorStop(0.5, "RGBA(255,255,255,.6)");
            cur_section.color_section_gradient.addColorStop(1.0, cur_section.color);
         }

         if(this.reverse_scale)
         {
            begin = ((this.scale_max - Math.max(start, this.scale_min)) / scale_range) * this.draw_range;
            end = ((this.scale_max - Math.min(stop, this.scale_max)) / scale_range) * this.draw_range;
            begin += this.start_angle - 90.0;
            end += this.start_angle - 90.0;
         }
         else
         {
            begin = ((Math.max(start, this.scale_min) - this.scale_min) / scale_range) * this.draw_range;
            end = ((Math.min(stop, this.scale_max) - this.scale_min) / scale_range) * this.draw_range;
            begin += this.start_angle - 90.0;
            end += this.start_angle - 90.0;
         }

         context.beginPath();
         context.arc(
            0, 0,
            arc_radius,
            degreesToRadians(begin),
            degreesToRadians(end),
            this.reverse_scale);

         context.lineWidth = this.major_tick_length;
         context.strokeStyle = this.colored_sections[i].color;
         context.stroke();
         context.strokeStyle = this.colored_sections[i].color_section_gradient;
         context.stroke();
      }
   }
};


CsiGauge.prototype.draw_scale = function (context, rim_radius)
{
   var range = this.scale_max - this.scale_min;
   if(range <= 0)
   {
      return;
   }

   var step_size = (this.scale_max - this.scale_min) / (this.major_tick_count - 1.0);
   var prev_angle = 0;
   var prev_tick = 0;
   var tick;
   for(tick = this.scale_min; tick < (this.scale_max + 0.0000001); tick += step_size)
   {
      context.save();
      var angle = (tick - this.scale_min) / range * this.draw_range;
      if(this.reverse_scale)
      {
         var reverse_start_angle = this.start_angle + this.draw_range;
         context.rotate(degreesToRadians(reverse_start_angle - angle));
      }
      else
      {
         context.rotate(degreesToRadians(this.start_angle + angle));
      }
      var hide_last_label = this.draw_range === 360 && (tick+step_size > this.scale_max + 0.0000001);
      this.draw_major_tick(context, tick, rim_radius, hide_last_label);
      context.restore();

      if(tick !== this.scale_min)
      {
         this.draw_minor_ticks(context, angle, prev_angle, tick, prev_tick, rim_radius);
      }
      prev_angle = angle;
      prev_tick = tick;
   }
};


CsiGauge.prototype.draw_major_tick = function (context, tick, radius, hide_last_label)
{
   if(this.show_major_ticks)
   {
      context.lineWidth = 0.75;
      context.beginPath();
      context.moveTo(0, -radius + this.tick_margin + (1.3 * this.text_height));
      context.lineTo(0, -radius + this.tick_margin + this.major_tick_length + (1.3 * this.text_height));
      context.strokeStyle = this.major_tick_color;
      context.stroke();
   }

   if(this.show_scale_labels && !hide_last_label)
   {
      context.textAlign = "center";
      context.textBaseline = "top";
      context.font = this.the_font;
      context.fillStyle = this.font_color;
      context.fillText(this.get_scale_label(tick), 0, -radius - this.tick_label_margin);
   }
};


CsiGauge.prototype.draw_minor_ticks = function (context, cur_angle, prev_angle, cur_value, prev_value, radius)
{
   if(!this.show_minor_ticks)
   {
      return;
   }

   var range;
   var unLogValue;
   var logValue;
   var percent;
   if(this.logarithmic)
   {
      //range is determined by unlog of values rather than pixels
      range = Math.abs(Math.pow(10.0, cur_value) - Math.pow(10.0, prev_value));
      unLogValue = Math.pow(10.0, Math.min(prev_value, cur_value));
   }
   else
   {
      range = cur_angle - prev_angle;
   }

   var step_size = range / (this.minor_tick_count + 1.0);
   var angle = prev_angle;
   var i;
   for(i = 0; i < this.minor_tick_count; i++)
   {
      if(this.logarithmic)
      {
         unLogValue += step_size; //actual value
         logValue = Math.log(unLogValue) / Math.log(10.0); //logarithmic value for plotting
         logValue -= this.scale_min;
         percent = logValue / (this.scale_max - this.scale_min);
         angle = percent * this.draw_range;
      }
      else
      {
         angle += step_size;
      }

      context.save();
      if(this.reverse_scale)
      {
         var reverse_start_angle = this.start_angle + this.draw_range;
         context.rotate(degreesToRadians(reverse_start_angle - angle));
      }
      else
      {
         context.rotate(degreesToRadians(this.start_angle + angle));
      }

      if(this.text_height === 0)
      {
         context.font = this.the_font;
         this.text_height = context.measureText("W").width;
      }

      var offset = 0;
      switch(this.minor_tick_alignment)
      {
         case Enum.ALIGNMENT.CENTER:
            offset = -radius + this.tick_margin + (1.3 * this.text_height) + this.major_tick_length / 2.0 - this.minor_tick_length / 2.0;
            break;
         case Enum.ALIGNMENT.LEFT:
            offset = -radius + this.tick_margin + (1.3 * this.text_height) + this.major_tick_length - this.minor_tick_length;
            break;
         //case Enum.ALIGNMENT.RIGHT: 
         default:
            offset = -radius + this.tick_margin + (1.3 * this.text_height);
            break;
      }

      if(this.show_minor_ticks)
      {
         context.lineWidth = 0.75;
         context.beginPath();
         context.moveTo(0, offset);
         context.lineTo(0, offset + this.minor_tick_length);
         context.strokeStyle = this.minor_tick_color;
         context.stroke();
      }
      context.restore();
   }
};

//return label to be displayed
CsiGauge.prototype.get_scale_label = function (value)
{
   if(this.logarithmic)
   {
      //get the scale label for the value.
      //if logarithmic, all values and min/max are converted to the log10(value)
      //thus when we display the labels, convert the log10(value) back to the value.
      var value2 = Math.pow(10, value);
      return value2.toFixed(this.tick_label_precision);
   }
   else
   {
      return value.toFixed(this.tick_label_precision);
   }
};


//left mouse button click.  We want to show the menu item with a left button click because
//the handheld touch screens do not distinguish between a left and right button click
CsiGauge.prototype.OnLButtonClick = function (mouseX, mouseY)
{
   this.OnRButtonClick(mouseX, mouseY);
};


CsiGauge.prototype.OnRButtonClick = function (mouseX, mouseY)
{
   var show_menu = false;
   var len = this.pointers.length;
   var i;
   for(i = 0; i < len && !show_menu; i++)
   {
      if(this.pointers[i].track > 0)
      {
         show_menu = true;
      }
   }

   if(show_menu)
   {
      this.ShowMenu(mouseX, mouseY);
   }
};


CsiGauge.prototype.reset_max_min = function ()
{
   var len = this.pointers.length;
   var i;
   for(i = 0; i < len; i++)
   {
      if(this.pointers[i].track > 0)
      {
         this.pointers[i].reset_max_min();
      }
   }
   this.invalidate();
};


CsiGauge.prototype.deactivate = function ()
{
   CsiComponent.prototype.deactivate.call(this);
   csiMouseEvents.hideMenu();
};


CsiGauge.prototype.ShowMenu = function (mouseX, mouseY)
{
   var component = this;
   csiMouseEvents.hideMenu();

   $("<div id='context'></div>").html("<ul class='context_menu'><li id='reset_max_min' class='menu_item'>Reset Max and Min Pointers</li></ul>")
   .css({
      position: 'absolute',
      zIndex: '9999',
      left: mouseX + $('#rtmc_canvas').offset().left,
      top: mouseY + $('#rtmc_canvas').offset().top
   }).show().appendTo('body');

   $('ul.context_menu').css({
      listStyle: 'none',
      padding: '1px',
      margin: '0px',
      backgroundColor: '#fff',
      border: '1px solid #999',
      width: 'auto'
   });

   $('li.menu_item').mouseover(function ()
   {
      $(this).css({
         backgroundColor: '#E9EFF8'
      });
   }).mouseout(function ()
   {
      $(this).css({
         backgroundColor: 'transparent'
      });
   }).css({
      width: 'auto',
      margin: '0px',
      color: '#000',
      display: 'block',
      cursor: 'default',
      padding: '3px',
      border: '1px solid #fff',
      backgroundColor: 'transparent'
   }).click(function ()
   {
      csiMouseEvents.hideMenu();
   });

   $('#reset_max_min').click(function ()
   {
      component.reset_max_min();
      component.refresh();
   });
};
/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiNumeric.js $

Copyright (C) 2010 Campbell Scientific, 2013 Campbell Scientific, Inc.
Started On: 10/5/2010 7:51:33 AM
Started By: Kevin Westwood

$LastChangedBy: jon $
$LastChangedDate: 2013-04-29 13:33:06 -0600 (Mon, 29 Apr 2013) $
$LastChangedRevision: 18017 $
*/

/* global CsiLabel */


function CsiNumeric(left, top, width, height, expression)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   CsiLabel.call(this, left, top, width, height, this.value);

   this.caption = "0.0";
   this.value = 0.0; //default to 0.0

   if(expression)
   {
      this.expression = expression;
      this.expression.ownerComponent = this;
   }
   else
   {
      this.expression = null;
   }

   this.precision = 1;
   this.textBaseline = "middle";
   this.units = "";
   this.bad_data = true;
   this.nan_data = false;
}
CsiNumeric.prototype = new CsiLabel();


CsiNumeric.prototype.newNanValue = function (value)
{
   var new_caption;
   this.value = value;
   if(value === -Infinity)
   {
      new_caption = "-INF" + this.units;
   }
   else if(value === Infinity)
   {
      new_caption = "INF" + this.units;
   }
   else
   {
      new_caption = "NAN" + this.units;
   }

   if(new_caption !== this.caption)
   {
      this.caption = new_caption;
      this.invalidate();
   }
};


CsiNumeric.prototype.reset_data = function ()
{
   this.caption = "0.0" + this.units;
   this.value = 0.0; //default to 0.0
   this.bad_data = true;
   this.nan_data = false;
};


CsiNumeric.prototype.newStringValue = function (value, timestamp, expect_more)
{
   this.newValue(value, timestamp, expect_more);
};


CsiNumeric.prototype.newValue = function (value)
{
   var new_caption;
   this.value = value;
   try
   {
      if(typeof this.value === "boolean")
      {
         if(this.value === true)
         {
            new_caption = "true" + this.units;
         }
         else
         {
            new_caption = "false" + this.units;
         }
      }
      else if(typeof this.value === "string")
      {
         new_caption = this.value + this.units;
      }
      else if(this.value instanceof CsiLgrDate)
      {
         new_caption = this.value.format("%c") + this.units;
      }
      else
      {
         new_caption = sprintf("%.*f%s", this.precision, this.value, this.units);
      }
   }
   catch(exception)
   {
      new_caption = String(this.units);
   }
   if(new_caption !== this.caption)
   {
      this.caption = new_caption;
      this.invalidate();
   }
};

/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiImageComponent.js $

Copyright (C) 2010 Campbell Scientific, Inc.
Started On: 5/4/2011 3:15:00 AM
Started By: Kevin Westwood

$LastChangedBy: jon $
$LastChangedDate: 2013-04-29 13:33:06 -0600 (Mon, 29 Apr 2013) $
$LastChangedRevision: 18017 $
*/

/* global CsiImage: true */


function CsiImageComponent(left, top, width, height, filename, rotation, drawStyle, expression, refreshInterval)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   if(expression)
   {
      this.expression = expression;
      this.expression.ownerComponent = this;
   }
   else
   {
      this.expression = null;
   }

   CsiComponent.call(this, left, top, width, height);
   this.drawRect = new Rect(left, top, width, height);
   this.csiImage = new CsiImage(this, filename, rotation, drawStyle, true, refreshInterval);
   this.ready = false; //set to true when the image is loaded
   this.bad_data = false;
}
CsiImageComponent.prototype = new CsiComponent();


CsiImageComponent.prototype.getBadData = function ()
{
   if(this.expression) 
   {
      return this.bad_data;
   }
   else
   {
      return false;
   }
};


CsiImageComponent.prototype.getNanData = function ()
{
   if(this.expression) 
   {
      return this.nan_data;
   }
   else
   {
      return false;
   }
};


CsiImageComponent.prototype.newValue = function (value)
{
   if(value !== this.last_value)
   {
      this.last_value = value;
      this.csiImage.rotation = value;
      this.invalidate();
   }
};


CsiImageComponent.prototype.csiImageOnLoad = function ()
{
   this.ready = true;
   this.invalidate();
};


CsiImageComponent.prototype.csiImageOnError = function ()
{
   this.ready = true;
   this.invalidate();
};


CsiImageComponent.prototype.draw = function (context)
{
   this.csiImage.draw(context, this.drawRect, this.rotation, this.drawStyle);
};


/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/RTMCScreen.js $

   Copyright (C) 2010 Campbell Scientific, Inc.
   Started On: 10/5/2010 7:48:58 AM
   Started By: Tyler Mecham

   $LastChangedBy: tmecham $
   $LastChangedDate: 2013-02-20 09:45:24 -0700 (Wed, 20 Feb 2013) $
   $LastChangedRevision: 17309 $
*/


function RTMCScreen()
{
   this.width = graphicsManager.canvas.width;
   this.height = graphicsManager.canvas.height;
   this.show_image = false;
   this.file_name = "";
   this.background_image = null;
   this.background_color = "white";
   this.drawStyle = Enum.DrawStyleType.stretch;
   this.ready = false;
}
RTMCScreen.prototype = [];


RTMCScreen.prototype.draw = function (context)
{
   context.fillStyle = this.background_color;
   context.fillRect(0, 0, this.width, this.height);
   if(this.file_name.length > 0)
   {
      if(this.background_image === null) 
      {
         this.ready = false;
         this.background_image = new Image();
         this.background_image.owner = this;
         this.background_image.onload = RTMCScreen.prototype.onload;
         this.background_image.onerror = RTMCScreen.prototype.onerror;
         this.background_image.onabort = RTMCScreen.prototype.onerror;
         this.background_image.src = this.file_name;
      }
      else if(this.ready)
      {
         if(this.drawStyle === Enum.DrawStyleType.stretch)
         {
            context.drawImage(this.background_image, 0, 0, this.width, this.height);
         }
         else if(this.drawStyle === Enum.DrawStyleType.tile)
         {
            var currLeft = 0;
            while(currLeft <= this.width)
            {
               var currTop = 0;
               while(currTop <= this.height)
               {
                  context.drawImage(this.background_image, currLeft, currTop);
                  currTop += this.background_image.height;
               }
               currLeft += this.background_image.width;
            }
         }
         else if(this.drawStyle === Enum.DrawStyleType.center)
         {
            context.drawImage(this.background_image, (this.width - this.background_image.width) / 2.0,
               (this.height - this.background_image.height) / 2.0);
         }
         else //Enum.DrawStyleType.best_fit
         {
            var im_w = this.background_image.width;
            var im_h = this.background_image.height;
            var comp_w = this.width;
            var comp_h = this.height;
            var image_aspect_ratio = 0;
            //Scale the image
            if(im_w < im_h)
            {
               image_aspect_ratio = im_w / im_h;
               im_h = comp_h;
               im_w = im_h * image_aspect_ratio;

               if(im_w > comp_w) //Keep the image inside the comp bounds
               {
                  im_w = comp_w;
                  im_h = im_w / image_aspect_ratio;
               }
            }
            else
            {
               image_aspect_ratio = im_h / im_w;
               im_w = comp_w;
               im_h = im_w * image_aspect_ratio;

               if(im_h > comp_h) //Keep the image inside the comp bounds
               {
                  im_h = comp_h;
                  im_w = im_h / image_aspect_ratio;
               }
            }
            var im_x = (this.width/2) - (im_w/2);
            var im_y = (this.height/2) - (im_h/2);
            context.drawImage(this.background_image, im_x, im_y, im_w, im_h);
         }
      }
      //else
      //{
      //   No image loaded, so don't draw anything
      //}
   }
};


RTMCScreen.prototype.onload = function()
{
   this.owner.ready = true;
   graphicsManager.invalidate();
};


RTMCScreen.prototype.onerror = function()
{
   this.owner.ready = false;
   this.owner.background_image = null;
};


Enum.DrawStyleType =
{
   stretch:0,
   tile:1,
   center:2,
   best_fit: 3
};/* $HeadURL: svn://engsoft/loggernet-4.2/rtmc/javascript/CsiGraphicsManager.js $

Copyright (C) 2010 Campbell Scientific, Inc.
Started On: 10/5/2010 7:51:33 AM
Started By: Kevin Westwood

$LastChangedBy: tmecham $
$LastChangedDate: 2013-05-22 09:08:43 -0600 (Wed, 22 May 2013) $
$LastChangedRevision: 18245 $
*/

var graphicsManager = null; //GLOBAL DECLARATION
var mobileBrowser = false; //GLOBAL DECLARATION

//CsiGraphicsManager manages painting of controls
function CsiGraphicsManager(canvas, context)
{
   //Do not add properties to prototype
   if(arguments.length === 0)
   {
      return;
   }

   //Check the user agent to see if we are a mobile browser or not
   var ua = navigator.userAgent;
   var checker = {
      iphone: ua.match(/(iPhone|iPod|iPad)/),
      blackberry: ua.match(/BlackBerry/),
      android: ua.match(/Android/),
      palm: ua.match(/Palm/),
      nokia: ua.match(/Nokia/),
      mini: ua.match(/Mini/),
      mobile: ua.match(/Mobi/)
   };
   if(checker.iphone || checker.blackberry || checker.android || checker.palm || checker.nokia || checker.mini || checker.mobile)
   {
      mobileBrowser = true; //Set the global boolean for mobileBrowser 
   }

   this.canvas = canvas;
   this.context = context;
   this.tabs = [];
   this.active_comps = null;
   this.animation_disabled = false;
   this.setFramesPerSecond(15);
   this.animationIntervalID = -1;
   this.count = 0; //count down timer
   this.color_r = 0;
   this.color_g = 0;
   this.color_b = 0;
   this.auto_tab_interval = 0;
   this.cur_tab_index = 0;
   this.data_manager_started = false;
   this.other_tab_showing = false;
   this.ignore_next_activate = false;
   this.auto_tabbing = false;
   this.total_tab_count = 0; //total tabs including data, status, etc
}


CsiGraphicsManager.prototype.setFramesPerSecond = function (fps)
{
   this.framesPerSecond = fps;
   this.refreshRate = (1 / this.framesPerSecond) * 1000; //convert to ms refresh rate
};


CsiGraphicsManager.prototype.addTab = function (components)
{
   //Activate the first set of comps we get
   if(this.tabs.length <= 0)
   {
      this.active_comps = components;
   }

   components.all_ready = false;
   this.tabs.push(components);

   var len = components.length;
   var i;
   for(i = 0; i < len; i++)
   {
      components[i].graphicsManager = this;
   }
};


CsiGraphicsManager.prototype.setTotalTabCount = function (total_count)
{
   this.total_tab_count = total_count;
};


CsiGraphicsManager.prototype.selectTab = function (tab_index)
{
   if(this.ignore_next_activate)
   {
      this.ignore_next_activate = false;
   }
   else
   {
      if(tab_index !== this.cur_tab_index)
      {
         this.activateTab(tab_index, true, false);
      }
   }
};

jQuery.fn.reverse = [].reverse;

CsiGraphicsManager.prototype.activateTab = function (tab_index, stop_tabbing, from_menu)
{
   var total_tab_count = this.total_tab_count;
   //Return true if the tab is for a canvas tab
   this.other_tab_showing = false;
   var comp_count = 0;
   var canvas_tab_count = this.tabs.length;
   var theTabs = $("#tabs");
   if(tab_index >= this.total_tab_count || tab_index < 0)
   {
      tab_index = 0;
   }

   var theLi = null;
   var tabNav = theTabs.find('ul');
   var tab_visible = false;
   tabNav.find('li').each(function (j, li)
   {
      if(j == tab_index)
      {
         theLi = $(li);
         if(graphicsManager.is_tab_visible(tabNav, theLi))
         {
            tab_visible = true;
         }
      }
   });

   if(theLi && !tab_visible)
   {
      var scroll_pos = tabNav.scrollLeft() + theLi.position().left - tabNav.outerWidth()/2.0;
      tabNav.animate({ 'scrollLeft': scroll_pos + "px" });
   }

   if(tab_index >= canvas_tab_count) //This tab index is for a non canvas tab
   {
      this.other_tab_showing = true;
   }

   this.cur_tab_index = tab_index;

   if(theTabs.length > 0)
   {
      this.ignore_next_activate = true;
      theTabs.tabs("option", "active", this.cur_tab_index);
      this.ignore_next_activate = false;
   }

   var i;
   if(this.active_comps)
   {
      comp_count = this.active_comps.length;
      for(i = 0; i < comp_count; i++)
      {
         this.active_comps[i].deactivate();
      }
   }

   if(!this.other_tab_showing) //Only activate if this is a canvas tab
   {
      this.active_comps = this.tabs[tab_index];

      comp_count = this.active_comps.length;
      for(i = 0; i < comp_count; i++)
      {
         this.active_comps[i].activate(this.context);
      }

      this.draw(false);
   }
   else
   {
      this.active_comps = null;
   }

   if(stop_tabbing)
   {
      this.stopAutoTabbing();
   }
};


CsiGraphicsManager.prototype.is_tab_visible = function (tabNav, tab)
{
   var tab_pos = tab.position().left;
   var tab_width = tab.width();
   var nav_width = tabNav.width();

   return (tab_pos > 0 && ((tab_pos + tab_width) < nav_width));
};


//Called initially In RTMC project when the main window is ready.
CsiGraphicsManager.prototype.start = function ()
{
   this.invalidate();
   if(this.auto_tab_interval > 0)
   {
      this.startAutoTabbing();
      $("#resume_auto_tab").click(function () { graphicsManager.startAutoTabbing(); });
   }
};


CsiGraphicsManager.prototype.startAutoTabbing = function ()
{
   if(this.auto_tab_interval > 0)
   {
      oneShotTimer.setTimeout(this, "AutoTab", this.auto_tab_interval);
      $("#resume_auto_tab").hide();
   }
};


CsiGraphicsManager.prototype.stopAutoTabbing = function ()
{
   if(this.auto_tab_interval > 0)
   {
      oneShotTimer.clearTimeout(this, "AutoTab");
      $("#resume_auto_tab").fadeIn(1000);
   }
};


CsiGraphicsManager.prototype.onOneShotTimer = function (tag)
{
   if(tag === "AutoTab")
   {
      if(this.isActiveTabReady() || this.cur_tab_index >= this.tabs.length)
      {
         this.auto_tabbing = true;
         this.activateTab(this.cur_tab_index + 1, false, true);
         this.auto_tabbing = false;
      }
      oneShotTimer.setTimeout(this, "AutoTab", this.auto_tab_interval);
   }
   else if(tag === "AlarmCheck")
   {
      var check_alarms_again = false;


      if(check_alarms_again)
      {
         oneShotTimer.setTimeout(this, "AlarmCheck", 10000); //Check for alarm tab updates
      }
   }
};


CsiGraphicsManager.prototype.update_alarm_tabs = function ()
{
   var tab_count = this.tabs.length;
   var i;
   for(i = 0; i < tab_count; i++)
   {
      var tab_has_alarm = false;
      var cur_tab = this.tabs[i];
      var comp_count = cur_tab.length;
      var c;
      for(c = 0; c < comp_count && !tab_has_alarm; c++)
      {
         if(typeof cur_tab[c].hasActiveAlarm === 'function') 
         {
            if(cur_tab[c].hasActiveAlarm())
            {
               tab_has_alarm = true;
            }
         }
      }

      if(tab_has_alarm)
      {
         $(String("#tabs-" + i)).show();
      }
      else
      {
         $(String("#tabs-" + i)).hide();
      }
   }
};


function forceDraw()
{
   graphicsManager.draw(true);
}


CsiGraphicsManager.prototype.invalidate = function ()
{
   if(this.animationIntervalID < 0)
   {
      this.animationIntervalID = setInterval(forceDraw, this.refreshRate);
   }
};


//When a component calls invalidate, this method is called
CsiGraphicsManager.prototype.componentInvalidate = function (component)
{
   if(component.active)
   {
      this.invalidate();
   }
};


//When component.refresh() is called, redraw the entire screen
CsiGraphicsManager.prototype.componentRefresh = function (component)
{
   if(component.active)
   {
      this.draw(false);
   }
};


//Draw all components (if they are all ready).  This method is called via a
//setInterval() timer.  The timer stops when all components have stopped animating.
//updateAnimation should only be passed as true if called by the animation timer
CsiGraphicsManager.prototype.draw = function (updateAnimation)
{
   var i = 0;
   if(this.other_tab_showing) //Don't draw
   { return; }

   if(this.active_comps === null)
   {
      this.context.fillStyle = 'white';
      this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
   }
   else
   {
      this.active_comps.draw(this.context);
   }



   if(this.active_comps && this.isActiveTabReady())
   {
      var animating = false;

      var bad_data_comps = [];
      var nan_data_comps = [];
      var len = this.active_comps.length;
      for(i = 0; i < len; i++)
      {
         this.context.save();
         var component = this.active_comps[i];

         try
         {
            if(component.getAnimating())
            {
               if(updateAnimation)
               {
                  component.updateAnimation();
               }

               if(component.getAnimating())
               {
                  animating = true; //still needs animation
               }
            }

            if((!component.valid) || (!component.drawOnlyIfInvalid))
            {
               component.draw(this.context);
               component.valid = true;
            }

            if(component.getBadData())
            {
               bad_data_comps.push(component);
            }
            else if(component.getNanData())
            {
               nan_data_comps.push(component);
            }
         }
         catch(err)
         {
            csi_log(err + "\nError drawing component at " + component.left + ", " + component.top);
         }

         this.context.restore();
      }

      //Draw the bad data symbol if there are any
      len = bad_data_comps.length;
      for(i = 0; i < len; i++)
      {
         drawBadData(bad_data_comps[i], this.context);
      }

      //Draw the bad data symbol if there are any
      len = nan_data_comps.length;
      for(i = 0; i < len; i++)
      {
         drawNanData(nan_data_comps[i], this.context);
      }

      //if animating and the animation timer is not going, start it
      if(animating)
      {
         this.invalidate();
      }
      else
      {
         //if no longer animating, stop the animation timer
         clearInterval(this.animationIntervalID);
         this.animationIntervalID = -1;
      }
   }
   else
   {
      //Draw the loading graphic
      i = 0;
      var size, x, y, ang, rads;
      var density = 30;
      var animBits = Math.round(density * 1.0);
      var bitMod, minBitMod = 0;
      var arc = 0;
      var di = 200;
      var e = 0.47;

      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

      this.context.save();
      this.context.translate(this.canvas.width / 2.0, this.canvas.height / 2.0);
      this.count += 10;
      this.count %= 360;
      if(this.count === 0)
      {
         this.color_r = Math.floor(Math.random() * 156);
         this.color_g = Math.floor(Math.random() * 156);
         this.color_b = Math.floor(Math.random() * 156);
      }
      this.context.rotate(degreesToRadians(this.count));
      while(i < density)
      {
         bitMod = i <= animBits ? 1 - ((1 - minBitMod) / animBits * i) : bitMod = minBitMod;
         ang = 270 - 360 / density * i;
         rads = degreesToRadians(ang);
         this.context.fillStyle = "rgba(" + this.color_r + ", " + this.color_g + ", " + this.color_b + ", " + bitMod.toString() + ")";
         size = di * 0.07;
         x = di * e + Math.cos(rads) * (di * e - size) - di * e;
         y = di * e + Math.sin(rads) * (di * e - size) - di * e;
         this.context.beginPath();
         this.context.arc(x, y, size * bitMod, 0, Math.PI * 2, false);
         this.context.closePath();
         this.context.fill();
         ++i;
      }
      this.context.restore();

      this.context.save();
      this.context.translate(this.canvas.width / 2.0, this.canvas.height / 2.0);
      this.context.font = "20pt Arial";
      this.context.textAlign = "center";
      this.context.textBaseline = "middle";
      this.context.fillStyle = "rgba(" + this.color_r + ", " + this.color_g + ", " + this.color_b + ", 1.0)";
      this.context.fillText("Loading", 0, 0);
      this.context.restore();
   }
};


//Are all active components ready to be painted.  Some components, such as images
//cannot be accessed until their resources are completely loaded
CsiGraphicsManager.prototype.isActiveTabReady = function ()
{
   var rtn = true;
   if(this.active_comps === null)
   {
      rtn = false;
   }
   else
   {
      if(!this.active_comps.all_ready)
      {
         var j;
         var comp_count = this.active_comps.length;
         for(j = 0; j < comp_count && rtn; j++)
         {
            if(!this.active_comps[j].ready)
            {
               rtn = false;
            }
         }

         if(rtn)
         {
            this.active_comps.all_ready = true;

            //We should be ok to start the data manager now
            if(!this.data_manager_started)
            {
               this.data_manager_started = true;
               dataManager.start();
               if(theAlarmsManager)
               {
                  theAlarmsManager.start();
               }
            }
         }
      }
   }
   return rtn;
};


//Find the tab containing find_comp and see if it is all ready
CsiGraphicsManager.prototype.isParentTabReady = function (find_comp)
{
   var rtn = false;
   var found_tab = false;
   var tab_count = this.tabs.length;
   var cur_comp = null;
   var t = 0;
   var c = 0;
   for(t = 0; t < tab_count && !found_tab; t++)
   {
      var cur_tab = this.tabs[t];
      var comp_count = cur_tab.length;
      for(c = 0; c < comp_count && !rtn; c++)
      {
         cur_comp = cur_tab[c];
         if(cur_comp === find_comp)
         {
            found_tab = true;
            if(cur_tab.all_ready)
            {
               rtn = true;
            }
            break;
         }
      }

      if(found_tab && !rtn) //If the tab was found but wasn't considered ready, recheck all for ready
      {
         var all_ready = true;
         for(c = 0; c < comp_count && !rtn; c++)
         {
            cur_comp = cur_tab[c];
            if(!cur_comp.ready)
            {
               all_ready = false;
               break;
            }
         }
         cur_tab.all_ready = all_ready;
         if(cur_tab.all_ready) //The tab is now ready, so return true
         {
            rtn = true;
         }
      }
   }
   return rtn;
};


CsiGraphicsManager.prototype.hit_test_by_need = function (mouseX, mouseY)
{
   var rtn = null;
   if(this.active_comps) 
   {
      var len = this.active_comps.length;
      var i;
      for(i = len - 1; i >= 0; i--)
      {
         //Only look for components that might need the mouse
         var comp = this.active_comps[i];
         if(comp.needs_mouse_events)
         {
            //Check to see if we are in the comp bounds
            if(mouseX > comp.left && mouseX < comp.right &&
               mouseY > comp.top && mouseY < comp.bottom)
            {
               rtn = comp;
               break;
            }
         }
      }
   }
   return rtn;
};


CsiGraphicsManager.prototype.OnMenuHidden = function ()
{
   if(this.active_comps) 
   {
      var len = this.active_comps.length;
      var i;
      for(i = 0; i < len; i++)
      {
         var comp = this.active_comps[i];
         if(typeof comp.OnMenuHidden === "function")
         {
            comp.OnMenuHidden();
         }
      }
   }
};



function start()
{
   var canvas = $('#rtmc_canvas')[0];
   var context = null;
   if(canvas)
   {
      if(canvas.getContext)
      {
         context = canvas.getContext('2d');
         if(typeof init_mouse === 'function')
            init_mouse();
      }
   }

   if(context)
   {
      var variables = [
        new CsiVariable("nivelAvg", false),
        new CsiVariable("nivelMax", false),
        new CsiVariable("nivelMin", false),
        new CsiVariable("hora1", true),
        new CsiVariable("nivelMax", false),
        new CsiVariable("nivelMin", false),
        new CsiVariable("nivelAvg", false),
        new CsiVariable("nivelSmp", false),
        new CsiVariable("nivelMax", false),
        new CsiVariable("FechaHora", false),
        new CsiVariable("nivelStd", false),
        new CsiVariable("Calidad(5)", false),
        new CsiVariable("Calidad(3)", false),
        new CsiVariable("battVolt", false),
        new CsiVariable("Calidad(4)", false),
        new CsiVariable("Calidad(1)", false),
        new CsiVariable("nivelSmp", false),
        new CsiVariable("Calidad(2)", false),
        new CsiVariable("nivelAvg", false),
        new CsiVariable("nivelMin", false),
        new CsiVariable("Calidad(11)", false),
        new CsiVariable("nivelMax", false),
        new CsiVariable("nivelAvg", false),
        new CsiVariable("nivelMax", false),
        new CsiVariable("nivelMin", false),
        new CsiVariable("hora1", true),
        new CsiVariable("nivelMax", false),
        new CsiVariable("nivelMin", false),
        new CsiVariable("nivelAvg", false),
        new CsiVariable("nivelSmp", false),
        new CsiVariable("FechaHora", false),
        new CsiVariable("nivelSmp", false),
        new CsiVariable("nivelAvg", false),
        new CsiVariable("nivelMin", false),
        new CsiVariable("nivelMax", false),
        new CsiVariable("FechaHora", false),
        new CsiVariable("nivelSmp", false),
        new CsiVariable("nivelAvg", false),
        new CsiVariable("nivelMin", false),
        new CsiVariable("nivelMax", false),
        new CsiVariable("nivelSmp", false),
        new CsiVariable("hora1", true),
        new CsiVariable("FechaHora", false),
        new CsiVariable("nivelAvg", false),
        new CsiVariable("nivelMax", false),
        new CsiVariable("nivelMin", false),
        new CsiVariable("nivelStd", false),
        new CsiVariable("Calidad(5)", false),
        new CsiVariable("Calidad(3)", false),
        new CsiVariable("battVolt", false),
        new CsiVariable("Calidad(4)", false),
        new CsiVariable("Calidad(1)", false),
        new CsiVariable("nivelSmp", false),
        new CsiVariable("Calidad(2)", false),
        new CsiVariable("nivelAvg", false),
        new CsiVariable("nivelMin", false),
        new CsiVariable("Calidad(11)", false),
        new CsiVariable("nivelMax", false),
        new CsiVariable("nivelMax", false),
        new CsiVariable("FechaHora", false),
        new CsiVariable("nivelAvg", false),
        new CsiVariable("nivelSmp", false),
        new CsiVariable("nivelMin", false),
        new CsiVariable("nivelStd", false),
        new CsiVariable("Calidad(5)", false),
        new CsiVariable("Calidad(3)", false),
        new CsiVariable("battVolt", false),
        new CsiVariable("Calidad(4)", false),
        new CsiVariable("Calidad(1)", false),
        new CsiVariable("nivelSmp", false),
        new CsiVariable("Calidad(2)", false),
        new CsiVariable("nivelAvg", false),
        new CsiVariable("nivelMin", false),
        new CsiVariable("Calidad(11)", false),
        new CsiVariable("nivelMax", false),
        new CsiVariable("nivelMax", false),
        new CsiVariable("FechaHora", false),
        new CsiVariable("nivelAvg", false),
        new CsiVariable("nivelMax", false),
        new CsiVariable("nivelMin", false),
        new CsiVariable("nivelStd", false),
        new CsiVariable("Calidad(5)", false),
        new CsiVariable("Calidad(3)", false),
        new CsiVariable("battVolt", false),
        new CsiVariable("Calidad(4)", false),
        new CsiVariable("Calidad(1)", false),
        new CsiVariable("nivelSmp", false),
        new CsiVariable("Calidad(2)", false),
        new CsiVariable("nivelAvg", false),
        new CsiVariable("nivelMin", false),
        new CsiVariable("Calidad(11)", false),
        new CsiVariable("nivelMax", false),
        new CsiVariable("nivelMax", false),
        new CsiVariable("FechaHora", false),
        new CsiVariable("nivelAvg", false),
        new CsiVariable("nivelMax", false),
        new CsiVariable("nivelMin", false),
        new CsiVariable("nivelStd", false),
        new CsiVariable("Calidad(5)", false),
        new CsiVariable("Calidad(3)", false),
        new CsiVariable("battVolt", false),
        new CsiVariable("Calidad(4)", false),
        new CsiVariable("Calidad(1)", false),
        new CsiVariable("nivelSmp", false),
        new CsiVariable("Calidad(2)", false),
        new CsiVariable("nivelAvg", false),
        new CsiVariable("nivelMin", false),
        new CsiVariable("Calidad(11)", false),
        new CsiVariable("nivelMax", false)
      ];

      var expressions = [
        new CsiExpression([
          new CsiConstant(33.891),
          variables[0],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[1],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[2],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          variables[3]
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[4],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[5],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[6],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[7],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          variables[8]
        ]),
        new CsiExpression([
          variables[9],
          new CsiTimestamp(),
          new CsiConstant(5),
          new CsiConstant(3600000000000),
          new CsiMultiplication(),
          new CsiSubtraction(),
          new CsiToInt(),
          new CsiToDate(),
          new CsiConstant("%d-%m-%y %H:%M:%S"),
          new CsiFormatTime()
        ]),
        new CsiExpression([
          variables[10]
        ]),
        new CsiExpression([
          variables[11]
        ]),
        new CsiExpression([
          variables[12]
        ]),
        new CsiExpression([
          variables[13]
        ]),
        new CsiExpression([
          variables[14]
        ]),
        new CsiExpression([
          variables[15]
        ]),
        new CsiExpression([
          variables[16]
        ]),
        new CsiExpression([
          variables[17]
        ]),
        new CsiExpression([
          variables[18]
        ]),
        new CsiExpression([
          variables[19]
        ]),
        new CsiExpression([
          variables[20]
        ]),
        new CsiExpression([
          variables[21]
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[22],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication(),
          new CsiConstant(1.05),
          new CsiMultiplication(),
          new CsiConstant(1.3),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[23],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication(),
          new CsiConstant(1.05),
          new CsiMultiplication(),
          new CsiConstant(1.3),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[24],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication(),
          new CsiConstant(1.05),
          new CsiMultiplication(),
          new CsiConstant(1.3),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          variables[25]
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[26],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication(),
          new CsiConstant(1.05),
          new CsiMultiplication(),
          new CsiConstant(1.3),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[27],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication(),
          new CsiConstant(1.05),
          new CsiMultiplication(),
          new CsiConstant(1.3),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[28],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication(),
          new CsiConstant(1.05),
          new CsiMultiplication(),
          new CsiConstant(1.3),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[29],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication(),
          new CsiConstant(1.05),
          new CsiMultiplication(),
          new CsiConstant(1.3),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          variables[30],
          new CsiTimestamp(),
          new CsiConstant(3),
          new CsiConstant(3600000000000),
          new CsiMultiplication(),
          new CsiSubtraction(),
          new CsiToInt(),
          new CsiToDate(),
          new CsiConstant("%d-%m-%y %H:%M:%S"),
          new CsiFormatTime()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[31],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication(),
          new CsiConstant(1.05),
          new CsiMultiplication(),
          new CsiConstant(1.3),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[32],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication(),
          new CsiConstant(1.05),
          new CsiMultiplication(),
          new CsiConstant(1.3),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[33],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication(),
          new CsiConstant(1.05),
          new CsiMultiplication(),
          new CsiConstant(1.3),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[34],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication(),
          new CsiConstant(1.05),
          new CsiMultiplication(),
          new CsiConstant(1.3),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          variables[35],
          new CsiTimestamp(),
          new CsiConstant(3),
          new CsiConstant(3600000000000),
          new CsiMultiplication(),
          new CsiSubtraction(),
          new CsiToInt(),
          new CsiToDate(),
          new CsiConstant("%d-%m-%y %H:%M:%S"),
          new CsiFormatTime()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[36],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication(),
          new CsiConstant(1.05),
          new CsiMultiplication(),
          new CsiConstant(1.3),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[37],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication(),
          new CsiConstant(1.05),
          new CsiMultiplication(),
          new CsiConstant(1.3),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[38],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication(),
          new CsiConstant(1.05),
          new CsiMultiplication(),
          new CsiConstant(1.3),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          new CsiConstant(33.891),
          variables[39],
          new CsiConstant(1.07),
          new CsiAddition(),
          new CsiConstant(2.363),
          new CsiExponentiation(),
          new CsiMultiplication(),
          new CsiConstant(1.05),
          new CsiMultiplication(),
          new CsiConstant(1.3),
          new CsiMultiplication()
        ]),
        new CsiExpression([
          variables[40]
        ]),
        new CsiExpression([
          variables[41]
        ]),
        new CsiExpression([
          variables[42],
          new CsiTimestamp(),
          new CsiConstant(5),
          new CsiConstant(3600000000000),
          new CsiMultiplication(),
          new CsiSubtraction(),
          new CsiToInt(),
          new CsiToDate(),
          new CsiConstant("%d-%m-%y %H:%M:%S"),
          new CsiFormatTime()
        ]),
        new CsiExpression([
          variables[43]
        ]),
        new CsiExpression([
          variables[44]
        ]),
        new CsiExpression([
          variables[45]
        ]),
        new CsiExpression([
          variables[46]
        ]),
        new CsiExpression([
          variables[47]
        ]),
        new CsiExpression([
          variables[48]
        ]),
        new CsiExpression([
          variables[49]
        ]),
        new CsiExpression([
          variables[50]
        ]),
        new CsiExpression([
          variables[51]
        ]),
        new CsiExpression([
          variables[52]
        ]),
        new CsiExpression([
          variables[53]
        ]),
        new CsiExpression([
          variables[54]
        ]),
        new CsiExpression([
          variables[55]
        ]),
        new CsiExpression([
          variables[56]
        ]),
        new CsiExpression([
          variables[57]
        ]),
        new CsiExpression([
          variables[58]
        ]),
        new CsiExpression([
          variables[59],
          new CsiTimestamp(),
          new CsiConstant(5),
          new CsiConstant(3600000000000),
          new CsiMultiplication(),
          new CsiSubtraction(),
          new CsiToInt(),
          new CsiToDate(),
          new CsiConstant("%d-%m-%y %H:%M:%S"),
          new CsiFormatTime()
        ]),
        new CsiExpression([
          variables[60]
        ]),
        new CsiExpression([
          variables[61]
        ]),
        new CsiExpression([
          variables[62]
        ]),
        new CsiExpression([
          variables[63]
        ]),
        new CsiExpression([
          variables[64]
        ]),
        new CsiExpression([
          variables[65]
        ]),
        new CsiExpression([
          variables[66]
        ]),
        new CsiExpression([
          variables[67]
        ]),
        new CsiExpression([
          variables[68]
        ]),
        new CsiExpression([
          variables[69]
        ]),
        new CsiExpression([
          variables[70]
        ]),
        new CsiExpression([
          variables[71]
        ]),
        new CsiExpression([
          variables[72]
        ]),
        new CsiExpression([
          variables[73]
        ]),
        new CsiExpression([
          variables[74]
        ]),
        new CsiExpression([
          variables[75]
        ]),
        new CsiExpression([
          variables[76],
          new CsiTimestamp(),
          new CsiConstant(5),
          new CsiConstant(3600000000000),
          new CsiMultiplication(),
          new CsiSubtraction(),
          new CsiToInt(),
          new CsiToDate(),
          new CsiConstant("%d-%m-%y %H:%M:%S"),
          new CsiFormatTime()
        ]),
        new CsiExpression([
          variables[77]
        ]),
        new CsiExpression([
          variables[78]
        ]),
        new CsiExpression([
          variables[79]
        ]),
        new CsiExpression([
          variables[80]
        ]),
        new CsiExpression([
          variables[81]
        ]),
        new CsiExpression([
          variables[82]
        ]),
        new CsiExpression([
          variables[83]
        ]),
        new CsiExpression([
          variables[84]
        ]),
        new CsiExpression([
          variables[85]
        ]),
        new CsiExpression([
          variables[86]
        ]),
        new CsiExpression([
          variables[87]
        ]),
        new CsiExpression([
          variables[88]
        ]),
        new CsiExpression([
          variables[89]
        ]),
        new CsiExpression([
          variables[90]
        ]),
        new CsiExpression([
          variables[91]
        ]),
        new CsiExpression([
          variables[92]
        ]),
        new CsiExpression([
          variables[93],
          new CsiTimestamp(),
          new CsiConstant(5),
          new CsiConstant(3600000000000),
          new CsiMultiplication(),
          new CsiSubtraction(),
          new CsiToInt(),
          new CsiToDate(),
          new CsiConstant("%d-%m-%y %H:%M:%S"),
          new CsiFormatTime()
        ]),
        new CsiExpression([
          variables[94]
        ]),
        new CsiExpression([
          variables[95]
        ]),
        new CsiExpression([
          variables[96]
        ]),
        new CsiExpression([
          variables[97]
        ]),
        new CsiExpression([
          variables[98]
        ]),
        new CsiExpression([
          variables[99]
        ]),
        new CsiExpression([
          variables[100]
        ]),
        new CsiExpression([
          variables[101]
        ]),
        new CsiExpression([
          variables[102]
        ]),
        new CsiExpression([
          variables[103]
        ]),
        new CsiExpression([
          variables[104]
        ]),
        new CsiExpression([
          variables[105]
        ]),
        new CsiExpression([
          variables[106]
        ]),
        new CsiExpression([
          variables[107]
        ]),
        new CsiExpression([
          variables[108]
        ])
      ];

      var web_queries = [
        new CsiWebQuery("H0719:hora1", "most-recent", "1", "", "real-time", 600000, -1, [variables[8], variables[9], variables[10], variables[11], variables[12], variables[13], variables[14], variables[15], variables[16], variables[17], variables[18], variables[19], variables[20], variables[21], variables[30], variables[31], variables[32], variables[33], variables[34], variables[35], variables[36], variables[37], variables[38], variables[39] ], "",0),
        new CsiWebQuery("H1156:hora1", "most-recent", "1", "", "real-time", 600000, -1, [variables[40], variables[42], variables[46], variables[47], variables[48], variables[49], variables[50], variables[51], variables[52], variables[53], variables[54], variables[55], variables[56], variables[57] ], "",0),
        new CsiWebQuery("H0721:hora1", "most-recent", "1", "", "real-time", 600000, -1, [variables[58], variables[59], variables[63], variables[64], variables[65], variables[66], variables[67], variables[68], variables[69], variables[70], variables[71], variables[72], variables[73], variables[74] ], "",0),
        new CsiWebQuery("H1153:hora1", "most-recent", "1", "", "real-time", 600000, -1, [variables[75], variables[76], variables[80], variables[81], variables[82], variables[83], variables[84], variables[85], variables[86], variables[87], variables[88], variables[89], variables[90], variables[91] ], "",0),
        new CsiWebQuery("H1136:hora1", "most-recent", "1", "", "real-time", 600000, -1, [variables[92], variables[93], variables[97], variables[98], variables[99], variables[100], variables[101], variables[102], variables[103], variables[104], variables[105], variables[106], variables[107], variables[108] ], "",0),
        new CsiWebQuery("H0719:hora1", "backfill", "259200", "", "collected", 600000, -1, [variables[0], variables[1], variables[2], variables[22], variables[23], variables[24] ], "",0),
        new CsiWebQuery("H0719:hora1", "most-recent", "100", "", "collected", 600000, -1, [variables[25], variables[26], variables[27], variables[28], variables[29] ], "",0),
        new CsiWebQuery("H1156:hora1", "most-recent", "100", "", "collected", 600000, -1, [variables[41] ], "",0),
        new CsiWebQuery("H0719:hora1", "most-recent", "720", "", "collected", 600000, -1, [variables[3], variables[4], variables[5], variables[6], variables[7] ], "",0),
        new CsiWebQuery("H1156:hora1", "backfill", "259200", "", "collected", 600000, -1, [variables[43], variables[44], variables[45] ], "",0),
        new CsiWebQuery("H0721:hora1", "backfill", "259200", "", "collected", 600000, -1, [variables[60], variables[61], variables[62] ], "",0),
        new CsiWebQuery("H1153:hora1", "backfill", "259200", "", "collected", 600000, -1, [variables[77], variables[78], variables[79] ], "",0),
        new CsiWebQuery("H1136:hora1", "backfill", "259200", "", "collected", 600000, -1, [variables[94], variables[95], variables[96] ], "",0)
      ];

      theAlarmsManager = new CsiAlarmsManager(600000);
      dataManager = new CsiDataManager(web_queries);

      graphicsManager = new CsiGraphicsManager(canvas, context);

      var tab_0 = new RTMCScreen();
      tab_0.background_color = "#FFFFFF";
      var image_1 = new CsiImageComponent(50, 225, 554, 372, 'image_1.png', 0, 0, '', 0);
      tab_0.push(image_1);

      var image_2 = new CsiImageComponent(673, 50, 408, 272, 'image_2.JPG', 0, 0, '', 0);
      tab_0.push(image_2);

      var label_1 = new CsiLabel(675, 254, 140, 64, "UBICACION:\r\n\r\nLat:\t        0\u00ba 19' 5\" S\r\nLong:    77\u00ba 47' 23\" O\r\nAltura:  \t1469 msnm");
      label_1.font = "italic bold 8pt Arial";
      label_1.font_color = "#FFFBF0";
      label_1.displayVertically = false;
      label_1.transparent = true;
      label_1.background_color = "#FFFFFF";
      label_1.textAlign = 0;
      label_1.border_style = 0;
      label_1.word_wrap = false;
      label_1.border_style = 0;
      tab_0.push(label_1);

      var label_2 = new CsiLabel(67, 281, 184, 25, "Nivel de Agua M\u00e1ximo");
      label_2.font = "bold 8pt Arial";
      label_2.font_color = "#000000";
      label_2.displayVertically = false;
      label_2.transparent = true;
      label_2.background_color = "#FFFFFF";
      label_2.textAlign = 0;
      label_2.border_style = 0;
      label_2.word_wrap = false;
      label_2.border_style = 0;
      tab_0.push(label_2);

      var label_3 = new CsiLabel(67, 295, 192, 25, "Nivel de Agua M\u00ednimo");
      label_3.font = "bold 8pt Arial";
      label_3.font_color = "#000000";
      label_3.displayVertically = false;
      label_3.transparent = true;
      label_3.background_color = "#FFFFFF";
      label_3.textAlign = 0;
      label_3.border_style = 0;
      label_3.word_wrap = false;
      label_3.border_style = 0;
      tab_0.push(label_3);

      var label_4 = new CsiLabel(67, 326, 171, 25, "Nivel de Agua Instant\u00e1neo");
      label_4.font = "bold 8pt Arial";
      label_4.font_color = "#000000";
      label_4.displayVertically = false;
      label_4.transparent = true;
      label_4.background_color = "#FFFFFF";
      label_4.textAlign = 0;
      label_4.border_style = 0;
      label_4.word_wrap = false;
      label_4.border_style = 0;
      tab_0.push(label_4);

      var label_5 = new CsiLabel(67, 310, 195, 25, "Nivel de Agua Promedio");
      label_5.font = "bold 8pt Arial";
      label_5.font_color = "#000000";
      label_5.displayVertically = false;
      label_5.transparent = true;
      label_5.background_color = "#FFFFFF";
      label_5.textAlign = 0;
      label_5.border_style = 0;
      label_5.word_wrap = false;
      label_5.border_style = 0;
      tab_0.push(label_5);

      var label_6 = new CsiLabel(404, 241, 68, 11, "MEDICI\u00d3N");
      label_6.font = "bold 8pt Arial";
      label_6.font_color = "#008000";
      label_6.displayVertically = false;
      label_6.transparent = true;
      label_6.background_color = "#FFFFFF";
      label_6.textAlign = 0;
      label_6.border_style = 0;
      label_6.word_wrap = false;
      label_6.border_style = 0;
      tab_0.push(label_6);

      var numeric_1 = new CsiNumeric(421, 270, 73, 25, expressions[21]);
      numeric_1.font = "bold 8pt Arial";
      numeric_1.font_color = "#000000";
      numeric_1.displayVertically = false;
      numeric_1.transparent = true;
      numeric_1.background_color = "#FFFFFF";
      numeric_1.textAlign = 0;
      numeric_1.border_style = 0;
      numeric_1.precision = 2;
      numeric_1.units = "  m";
      numeric_1.caption = "0.0  m";
      tab_0.push(numeric_1);

      var numeric_2 = new CsiNumeric(543, 345, 75, 25, expressions[20]);
      numeric_2.font = "bold 8pt Arial";
      numeric_2.font_color = "#000000";
      numeric_2.displayVertically = false;
      numeric_2.transparent = true;
      numeric_2.background_color = "#FFFFFF";
      numeric_2.textAlign = 0;
      numeric_2.border_style = 0;
      numeric_2.precision = 0;
      numeric_2.units = " ";
      numeric_2.caption = "0.0 ";
      tab_0.push(numeric_2);

      var numeric_3 = new CsiNumeric(421, 285, 75, 25, expressions[19]);
      numeric_3.font = "bold 8pt Arial";
      numeric_3.font_color = "#000000";
      numeric_3.displayVertically = false;
      numeric_3.transparent = true;
      numeric_3.background_color = "#FFFFFF";
      numeric_3.textAlign = 0;
      numeric_3.border_style = 0;
      numeric_3.precision = 2;
      numeric_3.units = "  m";
      numeric_3.caption = "0.0  m";
      tab_0.push(numeric_3);

      var numeric_4 = new CsiNumeric(421, 300, 75, 25, expressions[18]);
      numeric_4.font = "bold 8pt Arial";
      numeric_4.font_color = "#000000";
      numeric_4.displayVertically = false;
      numeric_4.transparent = true;
      numeric_4.background_color = "#FFFFFF";
      numeric_4.textAlign = 0;
      numeric_4.border_style = 0;
      numeric_4.precision = 2;
      numeric_4.units = "  m";
      numeric_4.caption = "0.0  m";
      tab_0.push(numeric_4);

      var numeric_5 = new CsiNumeric(543, 285, 75, 25, expressions[17]);
      numeric_5.font = "bold 8pt Arial";
      numeric_5.font_color = "#000000";
      numeric_5.displayVertically = false;
      numeric_5.transparent = true;
      numeric_5.background_color = "#FFFFFF";
      numeric_5.textAlign = 0;
      numeric_5.border_style = 0;
      numeric_5.precision = 0;
      numeric_5.units = "";
      numeric_5.caption = "0.0";
      tab_0.push(numeric_5);

      var numeric_6 = new CsiNumeric(421, 315, 75, 25, expressions[16]);
      numeric_6.font = "bold 8pt Arial";
      numeric_6.font_color = "#000000";
      numeric_6.displayVertically = false;
      numeric_6.transparent = true;
      numeric_6.background_color = "#FFFFFF";
      numeric_6.textAlign = 0;
      numeric_6.border_style = 0;
      numeric_6.precision = 2;
      numeric_6.units = "  m";
      numeric_6.caption = "0.0  m";
      tab_0.push(numeric_6);

      var numeric_7 = new CsiNumeric(543, 269, 75, 25, expressions[15]);
      numeric_7.font = "bold 8pt Arial";
      numeric_7.font_color = "#000000";
      numeric_7.displayVertically = false;
      numeric_7.transparent = true;
      numeric_7.background_color = "#FFFFFF";
      numeric_7.textAlign = 0;
      numeric_7.border_style = 0;
      numeric_7.precision = 0;
      numeric_7.units = "";
      numeric_7.caption = "0.0";
      tab_0.push(numeric_7);

      var numeric_8 = new CsiNumeric(543, 316, 75, 25, expressions[14]);
      numeric_8.font = "bold 8pt Arial";
      numeric_8.font_color = "#000000";
      numeric_8.displayVertically = false;
      numeric_8.transparent = true;
      numeric_8.background_color = "#FFFFFF";
      numeric_8.textAlign = 0;
      numeric_8.border_style = 0;
      numeric_8.precision = 0;
      numeric_8.units = "";
      numeric_8.caption = "0.0";
      tab_0.push(numeric_8);

      var numeric_9 = new CsiNumeric(421, 345, 75, 25, expressions[13]);
      numeric_9.font = "bold 8pt Arial";
      numeric_9.font_color = "#000000";
      numeric_9.displayVertically = false;
      numeric_9.transparent = true;
      numeric_9.background_color = "#FFFFFF";
      numeric_9.textAlign = 0;
      numeric_9.border_style = 0;
      numeric_9.precision = 2;
      numeric_9.units = "  V";
      numeric_9.caption = "0.0  V";
      tab_0.push(numeric_9);

      var numeric_10 = new CsiNumeric(543, 301, 75, 25, expressions[12]);
      numeric_10.font = "bold 8pt Arial";
      numeric_10.font_color = "#000000";
      numeric_10.displayVertically = false;
      numeric_10.transparent = true;
      numeric_10.background_color = "#FFFFFF";
      numeric_10.textAlign = 0;
      numeric_10.border_style = 0;
      numeric_10.precision = 0;
      numeric_10.units = "";
      numeric_10.caption = "0.0";
      tab_0.push(numeric_10);

      var numeric_11 = new CsiNumeric(543, 331, 75, 25, expressions[11]);
      numeric_11.font = "bold 8pt Arial";
      numeric_11.font_color = "#000000";
      numeric_11.displayVertically = false;
      numeric_11.transparent = true;
      numeric_11.background_color = "#FFFFFF";
      numeric_11.textAlign = 0;
      numeric_11.border_style = 0;
      numeric_11.precision = 0;
      numeric_11.units = "";
      numeric_11.caption = "0.0";
      tab_0.push(numeric_11);

      var numeric_12 = new CsiNumeric(421, 330, 75, 25, expressions[10]);
      numeric_12.font = "bold 8pt Arial";
      numeric_12.font_color = "#000000";
      numeric_12.displayVertically = false;
      numeric_12.transparent = true;
      numeric_12.background_color = "#FFFFFF";
      numeric_12.textAlign = 0;
      numeric_12.border_style = 0;
      numeric_12.precision = 2;
      numeric_12.units = "  m";
      numeric_12.caption = "0.0  m";
      tab_0.push(numeric_12);

      var label_7 = new CsiLabel(69, 242, 171, 25, "PARAMETRO DE MEDICION:");
      label_7.font = "bold 8pt Arial";
      label_7.font_color = "#008000";
      label_7.displayVertically = false;
      label_7.transparent = true;
      label_7.background_color = "#FFFFFF";
      label_7.textAlign = 0;
      label_7.border_style = 0;
      label_7.word_wrap = false;
      label_7.border_style = 0;
      tab_0.push(label_7);

      var image_3 = new CsiImageComponent(246, 11, 197, 52, 'image_3.png', 0, 0, '', 0);
      tab_0.push(image_3);

      var label_8 = new CsiLabel(75, 100, 543, 93, "REPORTE ESTACION \"QUIJOS DJ OYACACHI\"\r\n\r\nTIPO: RADAR\r\n\r\nC\u00d3DIGO: H0719");
      label_8.font = "bold 12pt Arial";
      label_8.font_color = "#0000C0";
      label_8.displayVertically = false;
      label_8.transparent = true;
      label_8.background_color = "#0000FF";
      label_8.textAlign = 1;
      label_8.border_style = 0;
      label_8.word_wrap = true;
      label_8.border_style = 0;
      tab_0.push(label_8);

      var label_9 = new CsiLabel(507, 241, 75, 27, "CALIDAD DE\r\nDATO");
      label_9.font = "bold 8pt Arial";
      label_9.font_color = "#008000";
      label_9.displayVertically = false;
      label_9.transparent = true;
      label_9.background_color = "#FFFFFF";
      label_9.textAlign = 1;
      label_9.border_style = 0;
      label_9.word_wrap = false;
      label_9.border_style = 0;
      tab_0.push(label_9);

      var label_10 = new CsiLabel(67, 265, 184, 25, "Fecha y hora");
      label_10.font = "bold 8pt Arial";
      label_10.font_color = "#000000";
      label_10.displayVertically = false;
      label_10.transparent = true;
      label_10.background_color = "#FFFFFF";
      label_10.textAlign = 0;
      label_10.border_style = 0;
      label_10.word_wrap = false;
      label_10.border_style = 0;
      tab_0.push(label_10);

      var label_11 = new CsiLabel(68, 341, 263, 25, "Nivel de Agua Desviaci\u00f3n Est\u00e1ndar");
      label_11.font = "bold 8pt Arial";
      label_11.font_color = "#000000";
      label_11.displayVertically = false;
      label_11.transparent = true;
      label_11.background_color = "#FFFFFF";
      label_11.textAlign = 0;
      label_11.border_style = 0;
      label_11.word_wrap = false;
      label_11.border_style = 0;
      tab_0.push(label_11);

      var label_12 = new CsiLabel(68, 356, 187, 25, "Voltaje de la Bater\u00eda Instant\u00e1nea");
      label_12.font = "bold 8pt Arial";
      label_12.font_color = "#000000";
      label_12.displayVertically = false;
      label_12.transparent = true;
      label_12.background_color = "#FFFFFF";
      label_12.textAlign = 0;
      label_12.border_style = 0;
      label_12.word_wrap = false;
      label_12.border_style = 0;
      tab_0.push(label_12);

      var numeric_13 = new CsiNumeric(375, 255, 115, 25, expressions[9]);
      numeric_13.font = "bold 8pt Arial";
      numeric_13.font_color = "#000000";
      numeric_13.displayVertically = false;
      numeric_13.transparent = true;
      numeric_13.background_color = "#FFFFFF";
      numeric_13.textAlign = 1;
      numeric_13.border_style = 0;
      numeric_13.precision = 0;
      numeric_13.units = " ";
      numeric_13.caption = "0.0 ";
      tab_0.push(numeric_13);

      var gauge_1 = new CsiGauge(757, 336, 250, 157);
      gauge_1.scale_max = 5;
      gauge_1.scale_min = 0;
      gauge_1.major_tick_count = 11;
      gauge_1.tick_label_precision = 1;
      gauge_1.font_color = "#000000";
      gauge_1.bg_outer_color = "#C0C0C0";
      gauge_1.the_font = "11pt Arial";
      gauge_1.draw_range = 320;
      gauge_1.start_angle = 145;
      gauge_1.transparent_rim = false;
      gauge_1.hub_size_percent = 0.08;
      gauge_1.logarithmic = false;
      var gauge_1_Pointer_1 = gauge_1.createPointer(expressions[8]);
      gauge_1_Pointer_1.length_percent = 1;
      gauge_1_Pointer_1.width_percent = 0.07;
      gauge_1_Pointer_1.margin = 0;
      gauge_1_Pointer_1.style = 0;
      gauge_1_Pointer_1.line_start = 8;
      gauge_1_Pointer_1.line_end = 6;
      gauge_1_Pointer_1.color = "#FF0000";
      gauge_1_Pointer_1.track = 0;
      gauge_1.border_style = 0;
      gauge_1.ends_margin = 0;
      gauge_1.show_scale_labels = true;
      gauge_1.auto_label = false;
      gauge_1.show_tick_axis = true;
      gauge_1.show_major_ticks = true;
      gauge_1.show_minor_ticks = true;
      gauge_1.minor_tick_count = 4;
      gauge_1.major_tick_length = 15;
      gauge_1.minor_tick_length = 5;
      gauge_1.tick_orientation = 1;
      gauge_1.major_tick_color = "#000000";
      gauge_1.minor_tick_color = "#000000";
      gauge_1.minor_tick_alignment = 1;
      gauge_1.show_tick_axis = true;
      gauge_1.tick_label_margin = 1;
      gauge_1.tick_margin = 0;
      gauge_1.show_hub = true;
      gauge_1.transparent = true;
      gauge_1.background_color = "#C0C0C0";
      gauge_1.hub_color = "#C0C0C0";
      gauge_1.hub_on_top = true;
      gauge_1.show_inner_arc = false;
      gauge_1.show_outer_arc = false;
      gauge_1.reverse_scale = false;
      gauge_1.rim_color = "#A9A9A9";
      gauge_1.bg_inner_color = "#FFFFFF";
      gauge_1.createColoredSection(4, 5, 'RGBA(255, 0, 0, 1)');
      gauge_1.createColoredSection(2.7, 4, 'RGBA(255, 255, 0, 1)');
      gauge_1.createColoredSection(0, 2.7, 'RGBA(0, 255, 0, 1)');
      tab_0.push(gauge_1);

      var label_13 = new CsiLabel(807, 504, 150, 30, "Nivel de Agua (m)");
      label_13.font = "12pt Arial Rounded MT Bold";
      label_13.font_color = "#000000";
      label_13.displayVertically = false;
      label_13.transparent = false;
      label_13.background_color = "#FFFFFF";
      label_13.textAlign = 1;
      label_13.border_style = 0;
      label_13.word_wrap = false;
      label_13.border_style = 0;
      tab_0.push(label_13);

      var alarmState_1 = new CsiImageAlarm(725, 375, 50, 50, 'image_4.gif', null);
      alarmState_1.set_identifier("2a9c09fc-2eb2-4b82-a159-e18243911e84");
      var alarmState_1_State_1 = alarmState_1.createImageAlarmState('image_5.gif', 'sound_1.wav', 'sound_1.mp3', 'sound_1.ogg');
      alarmState_1_State_1.audioInterval = 1200000;
      alarmState_1_State_1.stateName = "Warning";
      var alarmState_1_State_2 = alarmState_1.createImageAlarmState('image_6.gif', 'sound_2.wav', 'sound_2.mp3', 'sound_2.ogg');
      alarmState_1_State_2.audioInterval = 600000;
      alarmState_1_State_2.stateName = "Critical";
      tab_0.push(alarmState_1);

      var table_1 = new CsiTable(175, 1150, 900, 525, expressions[3]);
      table_1.createColumnExpressionComp('Calidad(1)', expressions[4]);
      table_1.createColumnExpressionComp('Calidad(2)', expressions[5]);
      table_1.createColumnExpressionComp('Calidad(3)', expressions[6]);
      table_1.createColumnExpressionComp('Calidad(4)', expressions[7]);
      table_1.maxRecords = 720;
      table_1.timestampFormat = "%c";
      table_1.timeOffset = -1.8e+007;
      table_1.newDataAtTop = true;
      table_1.showRecordNumber = false;
      table_1.showAllColumns = false;
      table_1.fontHeading = "12pt Arial";
      table_1.fontContents = "12pt Arial";
      table_1.fontColorHeading = "#000000";
      table_1.fontColorContents = "#000000";
      table_1.tableFilter = ['nivelMax', 'nivelMin', 'nivelSmp', 'nivelAvg', 'Calidad(1)', 'Calidad(2)', 'Calidad(3)', 'Calidad(4)'];
      table_1.customHeadings = {'Calidad(1)': "CaudalMax ", 'Calidad(2)': "CaudalMin", 'Calidad(3)': "CaudalPrm", 'Calidad(4)': "CaudalIns"};
      table_1.customPrecisions = {'Calidad(1)': "1", 'Calidad(2)': "1", 'Calidad(3)': "1", 'Calidad(4)': "1"};
      tab_0.push(table_1);

      var graph_1 = new CsiGraph(50, 575, 1107, 558);
      graph_1.graphWidth = 259200000;
      graph_1.plot_area_transparent = 0;
      graph_1.plot_area_color = "#EFEFEF";
      graph_1.plot_area_gradient.visible = 0;
      graph_1.plot_area_gradient.startColor = "#C0C0C0";
      graph_1.plot_area_gradient.midColor = "#FFFFFF";
      graph_1.plot_area_gradient.endColor = "#808080";
      graph_1.plot_area_gradient.direction = Enum.GRADIENT_DIRECTION.BottomTop;
      graph_1.background_gradient.visible = 0;
      graph_1.background_gradient.startColor = "#C0C0C0";
      graph_1.background_gradient.midColor = "#FFFFFF";
      graph_1.background_gradient.endColor = "#808080";
      graph_1.background_gradient.direction = Enum.GRADIENT_DIRECTION.BottomTop;
      graph_1.background_color = "#FFFFFF";
      graph_1.background_transparent = false;
      graph_1.title = " GRAFICA DE CAUDAL DE AGUA";
      graph_1.title_font = "bold 8pt Arial";
      graph_1.title_font_color = "#000000";
      graph_1.legend_visible = true;
      graph_1.legend_font = "bold 8pt Arial";
      graph_1.legend_font_color = "#000000";
      graph_1.leftAxis.time_format = "%d/%m %H:%M";
      graph_1.leftAxis.title_caption = "CAUDAL (m3/S.)";
      graph_1.leftAxis.title_font = "bold 8pt Arial";
      graph_1.leftAxis.title_color = "#000000";
      graph_1.leftAxis.title_angle = 270;
      graph_1.leftAxis.inverted = 0;
      graph_1.leftAxis.logarithmic = 0;
      graph_1.leftAxis.log_base = 10;
      graph_1.leftAxis.labels_visible = 1;
      graph_1.leftAxis.labels_font = "bold 8pt Arial";
      graph_1.leftAxis.labels_color = "#000000";
      graph_1.leftAxis.label_angle = 0;
      graph_1.leftAxis.label_size = 0;
      graph_1.leftAxis.decimal_places = 2;
      graph_1.leftAxis.auto_label = false;
      graph_1.leftAxis.fixed_decimals = true;
      graph_1.leftAxis.min = 0;
      graph_1.leftAxis.min_offset = 0;
      graph_1.leftAxis.max = 0;
      graph_1.leftAxis.max_offset = 0;
      graph_1.leftAxis.auto_min = 1;
      graph_1.leftAxis.auto_max = 1;
      graph_1.leftAxis.increment = 0;
      graph_1.leftAxis.minor_tick_count = 3;
      graph_1.leftAxis.major_grid_pen_visible = 1;
      graph_1.leftAxis.major_grid_pen_style = 2;
      graph_1.leftAxis.major_grid_pen_color = "#000000";
      graph_1.leftAxis.major_grid_pen_width = 1;
      graph_1.leftAxis.major_grid_pen_end_style = 0;
      graph_1.leftAxis.major_grid_pen_small_space = 0;
      graph_1.leftAxis.minor_grid_pen_visible = 0;
      graph_1.leftAxis.minor_grid_pen_style = 0;
      graph_1.leftAxis.minor_grid_pen_color = "#000000";
      graph_1.leftAxis.minor_grid_pen_width = 1;
      graph_1.leftAxis.minor_grid_pen_end_style = 0;
      graph_1.leftAxis.minor_grid_pen_small_space = 0;
      graph_1.leftAxis.major_ticks_pen_visible = 1;
      graph_1.leftAxis.major_ticks_pen_style = 0;
      graph_1.leftAxis.major_ticks_pen_color = "#000000";
      graph_1.leftAxis.major_ticks_pen_width = 1;
      graph_1.leftAxis.major_ticks_pen_end_style = 0;
      graph_1.leftAxis.major_ticks_pen_small_space = 0;
      graph_1.leftAxis.minor_ticks_pen_visible = 1;
      graph_1.leftAxis.minor_ticks_pen_style = 0;
      graph_1.leftAxis.minor_ticks_pen_color = "#000000";
      graph_1.leftAxis.minor_ticks_pen_width = 1;
      graph_1.leftAxis.minor_ticks_pen_end_style = 0;
      graph_1.leftAxis.minor_ticks_pen_small_space = 0;
      graph_1.leftAxis.axis_pen_visible = 1;
      graph_1.leftAxis.axis_pen_style = 0;
      graph_1.leftAxis.axis_pen_color = "#000000";
      graph_1.leftAxis.axis_pen_width = 2;
      graph_1.leftAxis.axis_pen_end_style = 0;
      graph_1.leftAxis.axis_pen_small_space = 0;
      graph_1.rightAxis.time_format = "%d/%m %H:%M";
      graph_1.rightAxis.title_caption = "Caudal (m3/s)";
      graph_1.rightAxis.title_font = "bold 8pt Arial";
      graph_1.rightAxis.title_color = "#000000";
      graph_1.rightAxis.title_angle = 270;
      graph_1.rightAxis.inverted = 0;
      graph_1.rightAxis.logarithmic = 0;
      graph_1.rightAxis.log_base = 10;
      graph_1.rightAxis.labels_visible = 1;
      graph_1.rightAxis.labels_font = "bold 8pt Arial";
      graph_1.rightAxis.labels_color = "#000000";
      graph_1.rightAxis.label_angle = 0;
      graph_1.rightAxis.label_size = 0;
      graph_1.rightAxis.decimal_places = 0;
      graph_1.rightAxis.auto_label = true;
      graph_1.rightAxis.fixed_decimals = false;
      graph_1.rightAxis.min = 0;
      graph_1.rightAxis.min_offset = 0;
      graph_1.rightAxis.max = 0;
      graph_1.rightAxis.max_offset = 0;
      graph_1.rightAxis.auto_min = 1;
      graph_1.rightAxis.auto_max = 1;
      graph_1.rightAxis.increment = 0;
      graph_1.rightAxis.minor_tick_count = 3;
      graph_1.rightAxis.major_grid_pen_visible = 0;
      graph_1.rightAxis.major_grid_pen_style = 2;
      graph_1.rightAxis.major_grid_pen_color = "#000000";
      graph_1.rightAxis.major_grid_pen_width = 1;
      graph_1.rightAxis.major_grid_pen_end_style = 0;
      graph_1.rightAxis.major_grid_pen_small_space = 0;
      graph_1.rightAxis.minor_grid_pen_visible = 0;
      graph_1.rightAxis.minor_grid_pen_style = 0;
      graph_1.rightAxis.minor_grid_pen_color = "#000000";
      graph_1.rightAxis.minor_grid_pen_width = 1;
      graph_1.rightAxis.minor_grid_pen_end_style = 0;
      graph_1.rightAxis.minor_grid_pen_small_space = 0;
      graph_1.rightAxis.major_ticks_pen_visible = 1;
      graph_1.rightAxis.major_ticks_pen_style = 0;
      graph_1.rightAxis.major_ticks_pen_color = "#000000";
      graph_1.rightAxis.major_ticks_pen_width = 1;
      graph_1.rightAxis.major_ticks_pen_end_style = 0;
      graph_1.rightAxis.major_ticks_pen_small_space = 0;
      graph_1.rightAxis.minor_ticks_pen_visible = 1;
      graph_1.rightAxis.minor_ticks_pen_style = 0;
      graph_1.rightAxis.minor_ticks_pen_color = "#000000";
      graph_1.rightAxis.minor_ticks_pen_width = 1;
      graph_1.rightAxis.minor_ticks_pen_end_style = 0;
      graph_1.rightAxis.minor_ticks_pen_small_space = 0;
      graph_1.rightAxis.axis_pen_visible = 1;
      graph_1.rightAxis.axis_pen_style = 0;
      graph_1.rightAxis.axis_pen_color = "#000000";
      graph_1.rightAxis.axis_pen_width = 2;
      graph_1.rightAxis.axis_pen_end_style = 0;
      graph_1.rightAxis.axis_pen_small_space = 0;
      graph_1.bottomAxis.time_format = "%d/%m %H:%M";
      graph_1.bottomAxis.title_caption = "Fecha-Hora";
      graph_1.bottomAxis.title_font = "bold 8pt Arial";
      graph_1.bottomAxis.title_color = "#000000";
      graph_1.bottomAxis.title_angle = 0;
      graph_1.bottomAxis.inverted = 0;
      graph_1.bottomAxis.logarithmic = 0;
      graph_1.bottomAxis.log_base = 10;
      graph_1.bottomAxis.labels_visible = 1;
      graph_1.bottomAxis.labels_font = "8pt Arial";
      graph_1.bottomAxis.labels_color = "#000000";
      graph_1.bottomAxis.label_angle = 270;
      graph_1.bottomAxis.label_size = 0;
      graph_1.bottomAxis.decimal_places = 0;
      graph_1.bottomAxis.auto_label = true;
      graph_1.bottomAxis.fixed_decimals = false;
      graph_1.bottomAxis.min = 32871;
      graph_1.bottomAxis.min_offset = 0;
      graph_1.bottomAxis.max = 32874;
      graph_1.bottomAxis.max_offset = 0;
      graph_1.bottomAxis.auto_min = false;
      graph_1.bottomAxis.auto_max = false;
      graph_1.bottomAxis.increment = 0;
      graph_1.bottomAxis.minor_tick_count = 3;
      graph_1.bottomAxis.major_grid_pen_visible = 1;
      graph_1.bottomAxis.major_grid_pen_style = 2;
      graph_1.bottomAxis.major_grid_pen_color = "#000000";
      graph_1.bottomAxis.major_grid_pen_width = 1;
      graph_1.bottomAxis.major_grid_pen_end_style = 0;
      graph_1.bottomAxis.major_grid_pen_small_space = 0;
      graph_1.bottomAxis.minor_grid_pen_visible = 0;
      graph_1.bottomAxis.minor_grid_pen_style = 0;
      graph_1.bottomAxis.minor_grid_pen_color = "#000000";
      graph_1.bottomAxis.minor_grid_pen_width = 1;
      graph_1.bottomAxis.minor_grid_pen_end_style = 0;
      graph_1.bottomAxis.minor_grid_pen_small_space = 0;
      graph_1.bottomAxis.major_ticks_pen_visible = 1;
      graph_1.bottomAxis.major_ticks_pen_style = 0;
      graph_1.bottomAxis.major_ticks_pen_color = "#000000";
      graph_1.bottomAxis.major_ticks_pen_width = 1;
      graph_1.bottomAxis.major_ticks_pen_end_style = 0;
      graph_1.bottomAxis.major_ticks_pen_small_space = 0;
      graph_1.bottomAxis.minor_ticks_pen_visible = 1;
      graph_1.bottomAxis.minor_ticks_pen_style = 0;
      graph_1.bottomAxis.minor_ticks_pen_color = "#000000";
      graph_1.bottomAxis.minor_ticks_pen_width = 1;
      graph_1.bottomAxis.minor_ticks_pen_end_style = 0;
      graph_1.bottomAxis.minor_ticks_pen_small_space = 0;
      graph_1.bottomAxis.axis_pen_visible = 1;
      graph_1.bottomAxis.axis_pen_style = 0;
      graph_1.bottomAxis.axis_pen_color = "#000000";
      graph_1.bottomAxis.axis_pen_width = 2;
      graph_1.bottomAxis.axis_pen_end_style = 0;
      graph_1.bottomAxis.axis_pen_small_space = 0;
      graph_1.bar_count = 0;
      var graph_1_Series_1 = graph_1.createSeries(expressions[0], 0);
      graph_1_Series_1.label = "Promedio";
      graph_1_Series_1.series_type = 0;
      graph_1_Series_1.line_type = 0;
      graph_1_Series_1.line_color = "#008000";
      graph_1_Series_1.line_width = 1;
      graph_1_Series_1.use_stairs = false;
      graph_1_Series_1.point_type = 1;
      graph_1_Series_1.point_color = "#008000";
      graph_1_Series_1.point_size = 2;
      graph_1_Series_1.timeOffset = -1.8e+007;
      var graph_1_Series_2 = graph_1.createSeries(expressions[1], 0);
      graph_1_Series_2.label = "M\u00e1ximo";
      graph_1_Series_2.series_type = 0;
      graph_1_Series_2.line_type = 0;
      graph_1_Series_2.line_color = "#FF0000";
      graph_1_Series_2.line_width = 1;
      graph_1_Series_2.use_stairs = false;
      graph_1_Series_2.point_type = 0;
      graph_1_Series_2.point_color = "#FF0000";
      graph_1_Series_2.point_size = 2;
      graph_1_Series_2.timeOffset = -1.8e+007;
      var graph_1_Series_3 = graph_1.createSeries(expressions[2], 0);
      graph_1_Series_3.label = "M\u00ednimo";
      graph_1_Series_3.series_type = 0;
      graph_1_Series_3.line_type = 0;
      graph_1_Series_3.line_color = "#0000FF";
      graph_1_Series_3.line_width = 1;
      graph_1_Series_3.use_stairs = false;
      graph_1_Series_3.point_type = 2;
      graph_1_Series_3.point_color = "#0000FF";
      graph_1_Series_3.point_size = 2;
      graph_1_Series_3.timeOffset = -1.8e+007;
      graph_1.displayWidth = 259200000;
      graph_1.use_pc_time = false;
      graph_1.legend_visible = 1;
      graph_1.legend_transparent = 1;
      graph_1.legend_back_color = "#FFFFFF";
      graph_1.legend_shadow_color = "#000000";
      graph_1.legend_position = 2;
      graph_1.legend_position_offset = 0;
      graph_1.legend_font = "bold 8pt Arial";
      graph_1.legend_gradient.visible = 0;
      graph_1.legend_gradient.startColor = "#C0C0C0";
      graph_1.legend_gradient.midColor = null;
      graph_1.legend_gradient.endColor = "#FFFFFF";
      graph_1.legend_gradient.direction = Enum.GRADIENT_DIRECTION.LeftRight;
      graph_1.enable_3d = 0;
      graph_1.percent_3d = 15;
      graph_1.zoom_3d = 100;
      graph_1.rotation = 345;
      graph_1.elevation = 345;
      graph_1.orthogonal = 1;
      graph_1.ortho_angle = 45;
      graph_1.plot_border_visible = 1;
      graph_1.plot_border_style = 0;
      graph_1.plot_border_color = "#000000";
      graph_1.plot_border_width = 1;
      tab_0.push(graph_1);

      var alarm_1 = new CsiImageAlarm(500, 400, 125, 75, 'resource_1.png');
      alarm_1.set_identifier("ef69f11d-9c54-472a-b0c7-ce9d1f03ec07");
      var alarm_1_onState = alarm_1.createImageAlarmState('resource_2.png', '', '', '');
      alarm_1_onState.audioInterval = 10000;
      alarm_1_onState.stateName = "Basic Alarm: nivelMax";
      tab_0.push(alarm_1);

      graphicsManager.addTab(tab_0);

      var tab_1 = new RTMCScreen();
      tab_1.background_color = "#FFFFFF";
      var label_14 = new CsiLabel(675, 254, 140, 64, "UBICACION:\r\n\r\nLat:\t        0\u00ba 19' 5\" S\r\nLong:    77\u00ba 47' 23\" O\r\nAltura:  \t1469 msnm");
      label_14.font = "italic bold 8pt Arial";
      label_14.font_color = "#FFFBF0";
      label_14.displayVertically = false;
      label_14.transparent = true;
      label_14.background_color = "#FFFFFF";
      label_14.textAlign = 0;
      label_14.border_style = 0;
      label_14.word_wrap = false;
      label_14.border_style = 0;
      tab_1.push(label_14);

      var label_15 = new CsiLabel(73, 378, 171, 25, "Caudal  Instant\u00e1neo Horario");
      label_15.font = "bold 8pt Arial";
      label_15.font_color = "#000000";
      label_15.displayVertically = false;
      label_15.transparent = true;
      label_15.background_color = "#FFFFFF";
      label_15.textAlign = 0;
      label_15.border_style = 0;
      label_15.word_wrap = false;
      label_15.border_style = 0;
      tab_1.push(label_15);

      var numeric_14 = new CsiNumeric(350, 302, 73, 25, expressions[34]);
      numeric_14.font = "bold 8pt Arial";
      numeric_14.font_color = "#000000";
      numeric_14.displayVertically = false;
      numeric_14.transparent = true;
      numeric_14.background_color = "#FFFFFF";
      numeric_14.textAlign = 0;
      numeric_14.border_style = 0;
      numeric_14.precision = 1;
      numeric_14.units = "  m3/s";
      numeric_14.caption = "0.0  m3/s";
      tab_1.push(numeric_14);

      var numeric_15 = new CsiNumeric(350, 326, 75, 25, expressions[33]);
      numeric_15.font = "bold 8pt Arial";
      numeric_15.font_color = "#000000";
      numeric_15.displayVertically = false;
      numeric_15.transparent = true;
      numeric_15.background_color = "#FFFFFF";
      numeric_15.textAlign = 0;
      numeric_15.border_style = 0;
      numeric_15.precision = 1;
      numeric_15.units = "  m3/s";
      numeric_15.caption = "0.0  m3/s";
      tab_1.push(numeric_15);

      var numeric_16 = new CsiNumeric(350, 351, 75, 25, expressions[32]);
      numeric_16.font = "bold 8pt Arial";
      numeric_16.font_color = "#000000";
      numeric_16.displayVertically = false;
      numeric_16.transparent = true;
      numeric_16.background_color = "#FFFFFF";
      numeric_16.textAlign = 0;
      numeric_16.border_style = 0;
      numeric_16.precision = 1;
      numeric_16.units = "  m3/s";
      numeric_16.caption = "0.0  m3/s";
      tab_1.push(numeric_16);

      var numeric_17 = new CsiNumeric(350, 378, 75, 25, expressions[31]);
      numeric_17.font = "bold 8pt Arial";
      numeric_17.font_color = "#000000";
      numeric_17.displayVertically = false;
      numeric_17.transparent = true;
      numeric_17.background_color = "#FFFFFF";
      numeric_17.textAlign = 0;
      numeric_17.border_style = 0;
      numeric_17.precision = 1;
      numeric_17.units = "  m3/s";
      numeric_17.caption = "0.0  m3/s";
      tab_1.push(numeric_17);

      var image_4 = new CsiImageComponent(246, 14, 254, 98, 'image_3.png', 0, 0, '', 0);
      tab_1.push(image_4);

      var label_16 = new CsiLabel(75, 133, 543, 93, "PRONOSTICO CAUDALES DE INGRESO A LA CAPTACION\r\n\r\nCENTRAL HIDROELECTRICA COCA CODO SINCLAIR\r\n\r\nPROYECTO CELEC EP - INAMHI");
      label_16.font = "bold 12pt Arial";
      label_16.font_color = "#0000C0";
      label_16.displayVertically = false;
      label_16.transparent = true;
      label_16.background_color = "#0000FF";
      label_16.textAlign = 1;
      label_16.border_style = 0;
      label_16.word_wrap = true;
      label_16.border_style = 0;
      tab_1.push(label_16);

      var numeric_18 = new CsiNumeric(319, 278, 115, 25, expressions[30]);
      numeric_18.font = "bold 8pt Arial";
      numeric_18.font_color = "#000000";
      numeric_18.displayVertically = false;
      numeric_18.transparent = true;
      numeric_18.background_color = "#FFFFFF";
      numeric_18.textAlign = 1;
      numeric_18.border_style = 0;
      numeric_18.precision = 0;
      numeric_18.units = " ";
      numeric_18.caption = "0.0 ";
      tab_1.push(numeric_18);

      var label_17 = new CsiLabel(493, 444, 275, 75, "RESULTADOS PRELIMINARES\r\nSUJETOS A MODIFICACIONES");
      label_17.font = "bold 12pt Arial";
      label_17.font_color = "#FF0000";
      label_17.displayVertically = false;
      label_17.transparent = false;
      label_17.background_color = "#FFFFFF";
      label_17.textAlign = 1;
      label_17.border_style = 0;
      label_17.word_wrap = false;
      label_17.border_style = 0;
      tab_1.push(label_17);

      var table_2 = new CsiTable(150, 1101, 1000, 675, expressions[25]);
      table_2.createColumnExpressionComp('Calidad(1)', expressions[26]);
      table_2.createColumnExpressionComp('Calidad(2)', expressions[27]);
      table_2.createColumnExpressionComp('Calidad(3)', expressions[28]);
      table_2.createColumnExpressionComp('Calidad(4)', expressions[29]);
      table_2.maxRecords = 100;
      table_2.timestampFormat = "%c";
      table_2.timeOffset = -1.08e+007;
      table_2.newDataAtTop = true;
      table_2.showRecordNumber = false;
      table_2.showAllColumns = false;
      table_2.fontHeading = "12pt Arial";
      table_2.fontContents = "12pt Arial";
      table_2.fontColorHeading = "#000000";
      table_2.fontColorContents = "#000000";
      table_2.tableFilter = ['Calidad(1)', 'Calidad(2)', 'Calidad(3)', 'Calidad(4)'];
      table_2.customHeadings = {'Calidad(1)': "CaudalMax ", 'Calidad(2)': "CaudalMin", 'Calidad(3)': "CaudalPrm", 'Calidad(4)': "CaudalIns"};
      table_2.customPrecisions = {'Calidad(1)': "1", 'Calidad(2)': "1", 'Calidad(3)': "1", 'Calidad(4)': "1"};
      tab_1.push(table_2);

      var graph_2 = new CsiGraph(75, 523, 1107, 558);
      graph_2.graphWidth = 259200000;
      graph_2.plot_area_transparent = 0;
      graph_2.plot_area_color = "#EFEFEF";
      graph_2.plot_area_gradient.visible = 0;
      graph_2.plot_area_gradient.startColor = "#C0C0C0";
      graph_2.plot_area_gradient.midColor = "#FFFFFF";
      graph_2.plot_area_gradient.endColor = "#808080";
      graph_2.plot_area_gradient.direction = Enum.GRADIENT_DIRECTION.BottomTop;
      graph_2.background_gradient.visible = 0;
      graph_2.background_gradient.startColor = "#C0C0C0";
      graph_2.background_gradient.midColor = "#FFFFFF";
      graph_2.background_gradient.endColor = "#808080";
      graph_2.background_gradient.direction = Enum.GRADIENT_DIRECTION.BottomTop;
      graph_2.background_color = "#FFFFFF";
      graph_2.background_transparent = false;
      graph_2.title = "PRONOSTICO DE CAUDAL DE INGRESO CAPTACI\u00d3N";
      graph_2.title_font = "bold 8pt Arial";
      graph_2.title_font_color = "#000000";
      graph_2.legend_visible = true;
      graph_2.legend_font = "bold 8pt Arial";
      graph_2.legend_font_color = "#000000";
      graph_2.leftAxis.time_format = "%d/%m %H:%M";
      graph_2.leftAxis.title_caption = "CAUDAL (m3/S.)";
      graph_2.leftAxis.title_font = "bold 8pt Arial";
      graph_2.leftAxis.title_color = "#000000";
      graph_2.leftAxis.title_angle = 270;
      graph_2.leftAxis.inverted = 0;
      graph_2.leftAxis.logarithmic = 0;
      graph_2.leftAxis.log_base = 10;
      graph_2.leftAxis.labels_visible = 1;
      graph_2.leftAxis.labels_font = "bold 8pt Arial";
      graph_2.leftAxis.labels_color = "#000000";
      graph_2.leftAxis.label_angle = 0;
      graph_2.leftAxis.label_size = 0;
      graph_2.leftAxis.decimal_places = 2;
      graph_2.leftAxis.auto_label = false;
      graph_2.leftAxis.fixed_decimals = true;
      graph_2.leftAxis.min = 0;
      graph_2.leftAxis.min_offset = 0;
      graph_2.leftAxis.max = 0;
      graph_2.leftAxis.max_offset = 0;
      graph_2.leftAxis.auto_min = 1;
      graph_2.leftAxis.auto_max = 1;
      graph_2.leftAxis.increment = 0;
      graph_2.leftAxis.minor_tick_count = 3;
      graph_2.leftAxis.major_grid_pen_visible = 1;
      graph_2.leftAxis.major_grid_pen_style = 2;
      graph_2.leftAxis.major_grid_pen_color = "#000000";
      graph_2.leftAxis.major_grid_pen_width = 1;
      graph_2.leftAxis.major_grid_pen_end_style = 0;
      graph_2.leftAxis.major_grid_pen_small_space = 0;
      graph_2.leftAxis.minor_grid_pen_visible = 0;
      graph_2.leftAxis.minor_grid_pen_style = 0;
      graph_2.leftAxis.minor_grid_pen_color = "#000000";
      graph_2.leftAxis.minor_grid_pen_width = 1;
      graph_2.leftAxis.minor_grid_pen_end_style = 0;
      graph_2.leftAxis.minor_grid_pen_small_space = 0;
      graph_2.leftAxis.major_ticks_pen_visible = 1;
      graph_2.leftAxis.major_ticks_pen_style = 0;
      graph_2.leftAxis.major_ticks_pen_color = "#000000";
      graph_2.leftAxis.major_ticks_pen_width = 1;
      graph_2.leftAxis.major_ticks_pen_end_style = 0;
      graph_2.leftAxis.major_ticks_pen_small_space = 0;
      graph_2.leftAxis.minor_ticks_pen_visible = 1;
      graph_2.leftAxis.minor_ticks_pen_style = 0;
      graph_2.leftAxis.minor_ticks_pen_color = "#000000";
      graph_2.leftAxis.minor_ticks_pen_width = 1;
      graph_2.leftAxis.minor_ticks_pen_end_style = 0;
      graph_2.leftAxis.minor_ticks_pen_small_space = 0;
      graph_2.leftAxis.axis_pen_visible = 1;
      graph_2.leftAxis.axis_pen_style = 0;
      graph_2.leftAxis.axis_pen_color = "#000000";
      graph_2.leftAxis.axis_pen_width = 2;
      graph_2.leftAxis.axis_pen_end_style = 0;
      graph_2.leftAxis.axis_pen_small_space = 0;
      graph_2.rightAxis.time_format = "%d/%m %H:%M";
      graph_2.rightAxis.title_caption = "Caudal (m3/s)";
      graph_2.rightAxis.title_font = "bold 8pt Arial";
      graph_2.rightAxis.title_color = "#000000";
      graph_2.rightAxis.title_angle = 270;
      graph_2.rightAxis.inverted = 0;
      graph_2.rightAxis.logarithmic = 0;
      graph_2.rightAxis.log_base = 10;
      graph_2.rightAxis.labels_visible = 1;
      graph_2.rightAxis.labels_font = "bold 8pt Arial";
      graph_2.rightAxis.labels_color = "#000000";
      graph_2.rightAxis.label_angle = 0;
      graph_2.rightAxis.label_size = 0;
      graph_2.rightAxis.decimal_places = 0;
      graph_2.rightAxis.auto_label = true;
      graph_2.rightAxis.fixed_decimals = false;
      graph_2.rightAxis.min = 0;
      graph_2.rightAxis.min_offset = 0;
      graph_2.rightAxis.max = 0;
      graph_2.rightAxis.max_offset = 0;
      graph_2.rightAxis.auto_min = 1;
      graph_2.rightAxis.auto_max = 1;
      graph_2.rightAxis.increment = 0;
      graph_2.rightAxis.minor_tick_count = 3;
      graph_2.rightAxis.major_grid_pen_visible = 0;
      graph_2.rightAxis.major_grid_pen_style = 2;
      graph_2.rightAxis.major_grid_pen_color = "#000000";
      graph_2.rightAxis.major_grid_pen_width = 1;
      graph_2.rightAxis.major_grid_pen_end_style = 0;
      graph_2.rightAxis.major_grid_pen_small_space = 0;
      graph_2.rightAxis.minor_grid_pen_visible = 0;
      graph_2.rightAxis.minor_grid_pen_style = 0;
      graph_2.rightAxis.minor_grid_pen_color = "#000000";
      graph_2.rightAxis.minor_grid_pen_width = 1;
      graph_2.rightAxis.minor_grid_pen_end_style = 0;
      graph_2.rightAxis.minor_grid_pen_small_space = 0;
      graph_2.rightAxis.major_ticks_pen_visible = 1;
      graph_2.rightAxis.major_ticks_pen_style = 0;
      graph_2.rightAxis.major_ticks_pen_color = "#000000";
      graph_2.rightAxis.major_ticks_pen_width = 1;
      graph_2.rightAxis.major_ticks_pen_end_style = 0;
      graph_2.rightAxis.major_ticks_pen_small_space = 0;
      graph_2.rightAxis.minor_ticks_pen_visible = 1;
      graph_2.rightAxis.minor_ticks_pen_style = 0;
      graph_2.rightAxis.minor_ticks_pen_color = "#000000";
      graph_2.rightAxis.minor_ticks_pen_width = 1;
      graph_2.rightAxis.minor_ticks_pen_end_style = 0;
      graph_2.rightAxis.minor_ticks_pen_small_space = 0;
      graph_2.rightAxis.axis_pen_visible = 1;
      graph_2.rightAxis.axis_pen_style = 0;
      graph_2.rightAxis.axis_pen_color = "#000000";
      graph_2.rightAxis.axis_pen_width = 2;
      graph_2.rightAxis.axis_pen_end_style = 0;
      graph_2.rightAxis.axis_pen_small_space = 0;
      graph_2.bottomAxis.time_format = "%d/%m %H:%M";
      graph_2.bottomAxis.title_caption = "Fecha-Hora";
      graph_2.bottomAxis.title_font = "bold 8pt Arial";
      graph_2.bottomAxis.title_color = "#000000";
      graph_2.bottomAxis.title_angle = 0;
      graph_2.bottomAxis.inverted = 0;
      graph_2.bottomAxis.logarithmic = 0;
      graph_2.bottomAxis.log_base = 10;
      graph_2.bottomAxis.labels_visible = 1;
      graph_2.bottomAxis.labels_font = "8pt Arial";
      graph_2.bottomAxis.labels_color = "#000000";
      graph_2.bottomAxis.label_angle = 270;
      graph_2.bottomAxis.label_size = 0;
      graph_2.bottomAxis.decimal_places = 0;
      graph_2.bottomAxis.auto_label = true;
      graph_2.bottomAxis.fixed_decimals = false;
      graph_2.bottomAxis.min = 32871;
      graph_2.bottomAxis.min_offset = 0;
      graph_2.bottomAxis.max = 32874;
      graph_2.bottomAxis.max_offset = 0;
      graph_2.bottomAxis.auto_min = false;
      graph_2.bottomAxis.auto_max = false;
      graph_2.bottomAxis.increment = 0;
      graph_2.bottomAxis.minor_tick_count = 3;
      graph_2.bottomAxis.major_grid_pen_visible = 1;
      graph_2.bottomAxis.major_grid_pen_style = 2;
      graph_2.bottomAxis.major_grid_pen_color = "#000000";
      graph_2.bottomAxis.major_grid_pen_width = 1;
      graph_2.bottomAxis.major_grid_pen_end_style = 0;
      graph_2.bottomAxis.major_grid_pen_small_space = 0;
      graph_2.bottomAxis.minor_grid_pen_visible = 0;
      graph_2.bottomAxis.minor_grid_pen_style = 0;
      graph_2.bottomAxis.minor_grid_pen_color = "#000000";
      graph_2.bottomAxis.minor_grid_pen_width = 1;
      graph_2.bottomAxis.minor_grid_pen_end_style = 0;
      graph_2.bottomAxis.minor_grid_pen_small_space = 0;
      graph_2.bottomAxis.major_ticks_pen_visible = 1;
      graph_2.bottomAxis.major_ticks_pen_style = 0;
      graph_2.bottomAxis.major_ticks_pen_color = "#000000";
      graph_2.bottomAxis.major_ticks_pen_width = 1;
      graph_2.bottomAxis.major_ticks_pen_end_style = 0;
      graph_2.bottomAxis.major_ticks_pen_small_space = 0;
      graph_2.bottomAxis.minor_ticks_pen_visible = 1;
      graph_2.bottomAxis.minor_ticks_pen_style = 0;
      graph_2.bottomAxis.minor_ticks_pen_color = "#000000";
      graph_2.bottomAxis.minor_ticks_pen_width = 1;
      graph_2.bottomAxis.minor_ticks_pen_end_style = 0;
      graph_2.bottomAxis.minor_ticks_pen_small_space = 0;
      graph_2.bottomAxis.axis_pen_visible = 1;
      graph_2.bottomAxis.axis_pen_style = 0;
      graph_2.bottomAxis.axis_pen_color = "#000000";
      graph_2.bottomAxis.axis_pen_width = 2;
      graph_2.bottomAxis.axis_pen_end_style = 0;
      graph_2.bottomAxis.axis_pen_small_space = 0;
      graph_2.bar_count = 0;
      var graph_2_Series_4 = graph_2.createSeries(expressions[22], 0);
      graph_2_Series_4.label = "Promedio";
      graph_2_Series_4.series_type = 0;
      graph_2_Series_4.line_type = 0;
      graph_2_Series_4.line_color = "#008000";
      graph_2_Series_4.line_width = 1;
      graph_2_Series_4.use_stairs = false;
      graph_2_Series_4.point_type = 1;
      graph_2_Series_4.point_color = "#008000";
      graph_2_Series_4.point_size = 2;
      graph_2_Series_4.timeOffset = -1.08e+007;
      var graph_2_Series_5 = graph_2.createSeries(expressions[23], 0);
      graph_2_Series_5.label = "M\u00e1ximo";
      graph_2_Series_5.series_type = 0;
      graph_2_Series_5.line_type = 0;
      graph_2_Series_5.line_color = "#FF0000";
      graph_2_Series_5.line_width = 1;
      graph_2_Series_5.use_stairs = false;
      graph_2_Series_5.point_type = 0;
      graph_2_Series_5.point_color = "#FF0000";
      graph_2_Series_5.point_size = 2;
      graph_2_Series_5.timeOffset = -1.08e+007;
      var graph_2_Series_6 = graph_2.createSeries(expressions[24], 0);
      graph_2_Series_6.label = "M\u00ednimo";
      graph_2_Series_6.series_type = 0;
      graph_2_Series_6.line_type = 0;
      graph_2_Series_6.line_color = "#0000FF";
      graph_2_Series_6.line_width = 1;
      graph_2_Series_6.use_stairs = false;
      graph_2_Series_6.point_type = 2;
      graph_2_Series_6.point_color = "#0000FF";
      graph_2_Series_6.point_size = 2;
      graph_2_Series_6.timeOffset = -1.08e+007;
      graph_2.displayWidth = 259200000;
      graph_2.use_pc_time = false;
      graph_2.legend_visible = 1;
      graph_2.legend_transparent = 1;
      graph_2.legend_back_color = "#FFFFFF";
      graph_2.legend_shadow_color = "#000000";
      graph_2.legend_position = 2;
      graph_2.legend_position_offset = 0;
      graph_2.legend_font = "bold 8pt Arial";
      graph_2.legend_gradient.visible = 0;
      graph_2.legend_gradient.startColor = "#C0C0C0";
      graph_2.legend_gradient.midColor = null;
      graph_2.legend_gradient.endColor = "#FFFFFF";
      graph_2.legend_gradient.direction = Enum.GRADIENT_DIRECTION.LeftRight;
      graph_2.enable_3d = 0;
      graph_2.percent_3d = 15;
      graph_2.zoom_3d = 100;
      graph_2.rotation = 345;
      graph_2.elevation = 345;
      graph_2.orthogonal = 1;
      graph_2.ortho_angle = 45;
      graph_2.plot_border_visible = 1;
      graph_2.plot_border_style = 0;
      graph_2.plot_border_color = "#000000";
      graph_2.plot_border_width = 1;
      tab_1.push(graph_2);

      var label_18 = new CsiLabel(77, 300, 184, 25, "Caudal M\u00e1ximo Horario");
      label_18.font = "bold 8pt Arial";
      label_18.font_color = "#000000";
      label_18.displayVertically = false;
      label_18.transparent = true;
      label_18.background_color = "#FFFFFF";
      label_18.textAlign = 0;
      label_18.border_style = 0;
      label_18.word_wrap = false;
      label_18.border_style = 0;
      tab_1.push(label_18);

      var label_19 = new CsiLabel(77, 324, 192, 25, "Caudal M\u00ednimo Horario");
      label_19.font = "bold 8pt Arial";
      label_19.font_color = "#000000";
      label_19.displayVertically = false;
      label_19.transparent = true;
      label_19.background_color = "#FFFFFF";
      label_19.textAlign = 0;
      label_19.border_style = 0;
      label_19.word_wrap = false;
      label_19.border_style = 0;
      tab_1.push(label_19);

      var label_20 = new CsiLabel(75, 350, 195, 25, "Caudal Promedio Horario");
      label_20.font = "bold 8pt Arial";
      label_20.font_color = "#000000";
      label_20.displayVertically = false;
      label_20.transparent = true;
      label_20.background_color = "#FFFFFF";
      label_20.textAlign = 0;
      label_20.border_style = 0;
      label_20.word_wrap = false;
      label_20.border_style = 0;
      tab_1.push(label_20);

      var label_21 = new CsiLabel(354, 259, 68, 11, "MEDICI\u00d3N");
      label_21.font = "bold 8pt Arial";
      label_21.font_color = "#008000";
      label_21.displayVertically = false;
      label_21.transparent = true;
      label_21.background_color = "#FFFFFF";
      label_21.textAlign = 0;
      label_21.border_style = 0;
      label_21.word_wrap = false;
      label_21.border_style = 0;
      tab_1.push(label_21);

      var label_22 = new CsiLabel(79, 252, 171, 25, "PARAMETRO DE MEDICION:");
      label_22.font = "bold 8pt Arial";
      label_22.font_color = "#008000";
      label_22.displayVertically = false;
      label_22.transparent = true;
      label_22.background_color = "#FFFFFF";
      label_22.textAlign = 0;
      label_22.border_style = 0;
      label_22.word_wrap = false;
      label_22.border_style = 0;
      tab_1.push(label_22);

      var label_23 = new CsiLabel(77, 275, 184, 25, "Fecha y hora");
      label_23.font = "bold 8pt Arial";
      label_23.font_color = "#000000";
      label_23.displayVertically = false;
      label_23.transparent = true;
      label_23.background_color = "#FFFFFF";
      label_23.textAlign = 0;
      label_23.border_style = 0;
      label_23.word_wrap = false;
      label_23.border_style = 0;
      tab_1.push(label_23);

      var image_5 = new CsiImageComponent(625, 125, 500, 300, 'image_7.JPG', 0, 0, '', 0);
      tab_1.push(image_5);

      var image_6 = new CsiImageComponent(745, 0, 251, 120, 'image_8.png', 0, 0, '', 0);
      tab_1.push(image_6);

      graphicsManager.addTab(tab_1);

      var tab_2 = new RTMCScreen();
      tab_2.background_color = "#FFFFFF";
      var label_24 = new CsiLabel(73, 451, 171, 25, "Caudal  Instant\u00e1neo Horario");
      label_24.font = "bold 8pt Arial";
      label_24.font_color = "#000000";
      label_24.displayVertically = false;
      label_24.transparent = true;
      label_24.background_color = "#FFFFFF";
      label_24.textAlign = 0;
      label_24.border_style = 0;
      label_24.word_wrap = false;
      label_24.border_style = 0;
      tab_2.push(label_24);

      var numeric_19 = new CsiNumeric(350, 376, 73, 25, expressions[39]);
      numeric_19.font = "bold 8pt Arial";
      numeric_19.font_color = "#000000";
      numeric_19.displayVertically = false;
      numeric_19.transparent = true;
      numeric_19.background_color = "#FFFFFF";
      numeric_19.textAlign = 0;
      numeric_19.border_style = 0;
      numeric_19.precision = 1;
      numeric_19.units = "  m3/s";
      numeric_19.caption = "0.0  m3/s";
      tab_2.push(numeric_19);

      var numeric_20 = new CsiNumeric(350, 401, 75, 25, expressions[38]);
      numeric_20.font = "bold 8pt Arial";
      numeric_20.font_color = "#000000";
      numeric_20.displayVertically = false;
      numeric_20.transparent = true;
      numeric_20.background_color = "#FFFFFF";
      numeric_20.textAlign = 0;
      numeric_20.border_style = 0;
      numeric_20.precision = 1;
      numeric_20.units = "  m3/s";
      numeric_20.caption = "0.0  m3/s";
      tab_2.push(numeric_20);

      var numeric_21 = new CsiNumeric(350, 426, 75, 25, expressions[37]);
      numeric_21.font = "bold 8pt Arial";
      numeric_21.font_color = "#000000";
      numeric_21.displayVertically = false;
      numeric_21.transparent = true;
      numeric_21.background_color = "#FFFFFF";
      numeric_21.textAlign = 0;
      numeric_21.border_style = 0;
      numeric_21.precision = 1;
      numeric_21.units = "  m3/s";
      numeric_21.caption = "0.0  m3/s";
      tab_2.push(numeric_21);

      var numeric_22 = new CsiNumeric(350, 451, 75, 25, expressions[36]);
      numeric_22.font = "bold 8pt Arial";
      numeric_22.font_color = "#000000";
      numeric_22.displayVertically = false;
      numeric_22.transparent = true;
      numeric_22.background_color = "#FFFFFF";
      numeric_22.textAlign = 0;
      numeric_22.border_style = 0;
      numeric_22.precision = 1;
      numeric_22.units = "  m3/s";
      numeric_22.caption = "0.0  m3/s";
      tab_2.push(numeric_22);

      var image_7 = new CsiImageComponent(246, 14, 254, 98, 'image_3.png', 0, 0, '', 0);
      tab_2.push(image_7);

      var label_25 = new CsiLabel(50, 133, 568, 167, "PRONOSTICO METEOROL\u00d3GICO\r\n\r\nRESULTADOS PRELIMINARES DEL MODELO NUMERICO WRF\r\n\r\nPRODUCTOS EN FASE DE PRUEBA\r\n\r\nPROYECTO CELEC EP - INAMHI");
      label_25.font = "bold 12pt Arial";
      label_25.font_color = "#0000C0";
      label_25.displayVertically = false;
      label_25.transparent = true;
      label_25.background_color = "#0000FF";
      label_25.textAlign = 1;
      label_25.border_style = 0;
      label_25.word_wrap = true;
      label_25.border_style = 0;
      tab_2.push(label_25);

      var numeric_23 = new CsiNumeric(319, 350, 115, 25, expressions[35]);
      numeric_23.font = "bold 8pt Arial";
      numeric_23.font_color = "#000000";
      numeric_23.displayVertically = false;
      numeric_23.transparent = true;
      numeric_23.background_color = "#FFFFFF";
      numeric_23.textAlign = 1;
      numeric_23.border_style = 0;
      numeric_23.precision = 0;
      numeric_23.units = " ";
      numeric_23.caption = "0.0 ";
      tab_2.push(numeric_23);

      var label_26 = new CsiLabel(75, 376, 184, 25, "Caudal M\u00e1ximo Horario");
      label_26.font = "bold 8pt Arial";
      label_26.font_color = "#000000";
      label_26.displayVertically = false;
      label_26.transparent = true;
      label_26.background_color = "#FFFFFF";
      label_26.textAlign = 0;
      label_26.border_style = 0;
      label_26.word_wrap = false;
      label_26.border_style = 0;
      tab_2.push(label_26);

      var label_27 = new CsiLabel(77, 401, 192, 25, "Caudal M\u00ednimo Horario");
      label_27.font = "bold 8pt Arial";
      label_27.font_color = "#000000";
      label_27.displayVertically = false;
      label_27.transparent = true;
      label_27.background_color = "#FFFFFF";
      label_27.textAlign = 0;
      label_27.border_style = 0;
      label_27.word_wrap = false;
      label_27.border_style = 0;
      tab_2.push(label_27);

      var label_28 = new CsiLabel(75, 426, 195, 25, "Caudal Promedio Horario");
      label_28.font = "bold 8pt Arial";
      label_28.font_color = "#000000";
      label_28.displayVertically = false;
      label_28.transparent = true;
      label_28.background_color = "#FFFFFF";
      label_28.textAlign = 0;
      label_28.border_style = 0;
      label_28.word_wrap = false;
      label_28.border_style = 0;
      tab_2.push(label_28);

      var label_29 = new CsiLabel(354, 335, 68, 11, "MEDICI\u00d3N");
      label_29.font = "bold 8pt Arial";
      label_29.font_color = "#008000";
      label_29.displayVertically = false;
      label_29.transparent = true;
      label_29.background_color = "#FFFFFF";
      label_29.textAlign = 0;
      label_29.border_style = 0;
      label_29.word_wrap = false;
      label_29.border_style = 0;
      tab_2.push(label_29);

      var label_30 = new CsiLabel(79, 325, 171, 25, "PARAMETRO DE MEDICION:");
      label_30.font = "bold 8pt Arial";
      label_30.font_color = "#008000";
      label_30.displayVertically = false;
      label_30.transparent = true;
      label_30.background_color = "#FFFFFF";
      label_30.textAlign = 0;
      label_30.border_style = 0;
      label_30.word_wrap = false;
      label_30.border_style = 0;
      tab_2.push(label_30);

      var label_31 = new CsiLabel(77, 350, 184, 25, "Fecha y hora");
      label_31.font = "bold 8pt Arial";
      label_31.font_color = "#000000";
      label_31.displayVertically = false;
      label_31.transparent = true;
      label_31.background_color = "#FFFFFF";
      label_31.textAlign = 0;
      label_31.border_style = 0;
      label_31.word_wrap = false;
      label_31.border_style = 0;
      tab_2.push(label_31);

      var image_8 = new CsiImageComponent(625, 125, 500, 300, 'image_7.JPG', 0, 0, '', 0);
      tab_2.push(image_8);

      var image_9 = new CsiImageComponent(745, 0, 251, 120, 'image_8.png', 0, 0, '', 0);
      tab_2.push(image_9);

      var image_10 = new CsiImageComponent(28, 529, 400, 400, 'image_9.png', 0, 0, '', 0);
      tab_2.push(image_10);

      var image_11 = new CsiImageComponent(437, 529, 400, 400, 'image_10.png', 0, 0, '', 0);
      tab_2.push(image_11);

      var image_12 = new CsiImageComponent(850, 529, 400, 400, 'image_11.png', 0, 0, '', 0);
      tab_2.push(image_12);

      var label_32 = new CsiLabel(128, 950, 171, 25, "PRIMER DIA");
      label_32.font = "bold 12pt Arial Black";
      label_32.font_color = "#FF0000";
      label_32.displayVertically = false;
      label_32.transparent = true;
      label_32.background_color = "#FFFFFF";
      label_32.textAlign = 1;
      label_32.border_style = 0;
      label_32.word_wrap = false;
      label_32.border_style = 0;
      tab_2.push(label_32);

      var label_33 = new CsiLabel(563, 950, 171, 25, "SEGUNDO DIA");
      label_33.font = "bold 12pt Arial Black";
      label_33.font_color = "#FF0000";
      label_33.displayVertically = false;
      label_33.transparent = true;
      label_33.background_color = "#FFFFFF";
      label_33.textAlign = 1;
      label_33.border_style = 0;
      label_33.word_wrap = false;
      label_33.border_style = 0;
      tab_2.push(label_33);

      var label_34 = new CsiLabel(975, 950, 171, 25, "TERCER DIA");
      label_34.font = "bold 12pt Arial Black";
      label_34.font_color = "#FF0000";
      label_34.displayVertically = false;
      label_34.transparent = true;
      label_34.background_color = "#FFFFFF";
      label_34.textAlign = 1;
      label_34.border_style = 0;
      label_34.word_wrap = false;
      label_34.border_style = 0;
      tab_2.push(label_34);

      var image_13 = new CsiImageComponent(400, 1000, 500, 475, 'image_12.gif', 0, 0, '', 0);
      tab_2.push(image_13);

      graphicsManager.addTab(tab_2);

      var tab_3 = new RTMCScreen();
      tab_3.background_color = "#FFFFFF";
      var image_14 = new CsiImageComponent(54, 235, 554, 372, 'image_1.png', 0, 0, '', 0);
      tab_3.push(image_14);

      var image_15 = new CsiImageComponent(673, 50, 408, 272, 'image_13.JPG', 0, 0, '', 0);
      tab_3.push(image_15);

      var label_35 = new CsiLabel(675, 254, 140, 64, "UBICACION:\r\n\r\nLat:\t        1\u00ba 3' 39\" S\r\nLong:    77\u00ba 32' 45\" O\r\nAltura:  \t370 msnm");
      label_35.font = "italic bold 8pt Arial";
      label_35.font_color = "#FFFBF0";
      label_35.displayVertically = false;
      label_35.transparent = true;
      label_35.background_color = "#FFFFFF";
      label_35.textAlign = 0;
      label_35.border_style = 0;
      label_35.word_wrap = false;
      label_35.border_style = 0;
      tab_3.push(label_35);

      var label_36 = new CsiLabel(67, 281, 184, 25, "Nivel de Agua M\u00e1ximo");
      label_36.font = "bold 8pt Arial";
      label_36.font_color = "#000000";
      label_36.displayVertically = false;
      label_36.transparent = true;
      label_36.background_color = "#FFFFFF";
      label_36.textAlign = 0;
      label_36.border_style = 0;
      label_36.word_wrap = false;
      label_36.border_style = 0;
      tab_3.push(label_36);

      var label_37 = new CsiLabel(67, 295, 192, 25, "Nivel de Agua M\u00ednimo");
      label_37.font = "bold 8pt Arial";
      label_37.font_color = "#000000";
      label_37.displayVertically = false;
      label_37.transparent = true;
      label_37.background_color = "#FFFFFF";
      label_37.textAlign = 0;
      label_37.border_style = 0;
      label_37.word_wrap = false;
      label_37.border_style = 0;
      tab_3.push(label_37);

      var label_38 = new CsiLabel(67, 326, 171, 25, "Nivel de Agua Instant\u00e1neo");
      label_38.font = "bold 8pt Arial";
      label_38.font_color = "#000000";
      label_38.displayVertically = false;
      label_38.transparent = true;
      label_38.background_color = "#FFFFFF";
      label_38.textAlign = 0;
      label_38.border_style = 0;
      label_38.word_wrap = false;
      label_38.border_style = 0;
      tab_3.push(label_38);

      var label_39 = new CsiLabel(67, 310, 195, 25, "Nivel de Agua Promedio");
      label_39.font = "bold 8pt Arial";
      label_39.font_color = "#000000";
      label_39.displayVertically = false;
      label_39.transparent = true;
      label_39.background_color = "#FFFFFF";
      label_39.textAlign = 0;
      label_39.border_style = 0;
      label_39.word_wrap = false;
      label_39.border_style = 0;
      tab_3.push(label_39);

      var label_40 = new CsiLabel(404, 241, 68, 11, "MEDICI\u00d3N");
      label_40.font = "bold 8pt Arial";
      label_40.font_color = "#008000";
      label_40.displayVertically = false;
      label_40.transparent = true;
      label_40.background_color = "#FFFFFF";
      label_40.textAlign = 0;
      label_40.border_style = 0;
      label_40.word_wrap = false;
      label_40.border_style = 0;
      tab_3.push(label_40);

      var numeric_24 = new CsiNumeric(421, 281, 75, 25, expressions[57]);
      numeric_24.font = "bold 8pt Arial";
      numeric_24.font_color = "#000000";
      numeric_24.displayVertically = false;
      numeric_24.transparent = true;
      numeric_24.background_color = "#FFFFFF";
      numeric_24.textAlign = 0;
      numeric_24.border_style = 0;
      numeric_24.precision = 2;
      numeric_24.units = "  m";
      numeric_24.caption = "0.0  m";
      tab_3.push(numeric_24);

      var numeric_25 = new CsiNumeric(543, 356, 75, 25, expressions[56]);
      numeric_25.font = "bold 8pt Arial";
      numeric_25.font_color = "#000000";
      numeric_25.displayVertically = false;
      numeric_25.transparent = true;
      numeric_25.background_color = "#FFFFFF";
      numeric_25.textAlign = 0;
      numeric_25.border_style = 0;
      numeric_25.precision = 0;
      numeric_25.units = " ";
      numeric_25.caption = "0.0 ";
      tab_3.push(numeric_25);

      var numeric_26 = new CsiNumeric(421, 295, 75, 25, expressions[55]);
      numeric_26.font = "bold 8pt Arial";
      numeric_26.font_color = "#000000";
      numeric_26.displayVertically = false;
      numeric_26.transparent = true;
      numeric_26.background_color = "#FFFFFF";
      numeric_26.textAlign = 0;
      numeric_26.border_style = 0;
      numeric_26.precision = 2;
      numeric_26.units = "  m";
      numeric_26.caption = "0.0  m";
      tab_3.push(numeric_26);

      var numeric_27 = new CsiNumeric(421, 310, 75, 25, expressions[54]);
      numeric_27.font = "bold 8pt Arial";
      numeric_27.font_color = "#000000";
      numeric_27.displayVertically = false;
      numeric_27.transparent = true;
      numeric_27.background_color = "#FFFFFF";
      numeric_27.textAlign = 0;
      numeric_27.border_style = 0;
      numeric_27.precision = 2;
      numeric_27.units = "  m";
      numeric_27.caption = "0.0  m";
      tab_3.push(numeric_27);

      var numeric_28 = new CsiNumeric(543, 295, 75, 25, expressions[53]);
      numeric_28.font = "bold 8pt Arial";
      numeric_28.font_color = "#000000";
      numeric_28.displayVertically = false;
      numeric_28.transparent = true;
      numeric_28.background_color = "#FFFFFF";
      numeric_28.textAlign = 0;
      numeric_28.border_style = 0;
      numeric_28.precision = 0;
      numeric_28.units = "";
      numeric_28.caption = "0.0";
      tab_3.push(numeric_28);

      var numeric_29 = new CsiNumeric(421, 325, 75, 25, expressions[52]);
      numeric_29.font = "bold 8pt Arial";
      numeric_29.font_color = "#000000";
      numeric_29.displayVertically = false;
      numeric_29.transparent = true;
      numeric_29.background_color = "#FFFFFF";
      numeric_29.textAlign = 0;
      numeric_29.border_style = 0;
      numeric_29.precision = 2;
      numeric_29.units = "  m";
      numeric_29.caption = "0.0  m";
      tab_3.push(numeric_29);

      var numeric_30 = new CsiNumeric(543, 280, 75, 25, expressions[51]);
      numeric_30.font = "bold 8pt Arial";
      numeric_30.font_color = "#000000";
      numeric_30.displayVertically = false;
      numeric_30.transparent = true;
      numeric_30.background_color = "#FFFFFF";
      numeric_30.textAlign = 0;
      numeric_30.border_style = 0;
      numeric_30.precision = 0;
      numeric_30.units = "";
      numeric_30.caption = "0.0";
      tab_3.push(numeric_30);

      var numeric_31 = new CsiNumeric(543, 326, 75, 25, expressions[50]);
      numeric_31.font = "bold 8pt Arial";
      numeric_31.font_color = "#000000";
      numeric_31.displayVertically = false;
      numeric_31.transparent = true;
      numeric_31.background_color = "#FFFFFF";
      numeric_31.textAlign = 0;
      numeric_31.border_style = 0;
      numeric_31.precision = 0;
      numeric_31.units = "";
      numeric_31.caption = "0.0";
      tab_3.push(numeric_31);

      var numeric_32 = new CsiNumeric(421, 356, 75, 25, expressions[49]);
      numeric_32.font = "bold 8pt Arial";
      numeric_32.font_color = "#000000";
      numeric_32.displayVertically = false;
      numeric_32.transparent = true;
      numeric_32.background_color = "#FFFFFF";
      numeric_32.textAlign = 0;
      numeric_32.border_style = 0;
      numeric_32.precision = 2;
      numeric_32.units = "  V";
      numeric_32.caption = "0.0  V";
      tab_3.push(numeric_32);

      var numeric_33 = new CsiNumeric(543, 310, 75, 25, expressions[48]);
      numeric_33.font = "bold 8pt Arial";
      numeric_33.font_color = "#000000";
      numeric_33.displayVertically = false;
      numeric_33.transparent = true;
      numeric_33.background_color = "#FFFFFF";
      numeric_33.textAlign = 0;
      numeric_33.border_style = 0;
      numeric_33.precision = 0;
      numeric_33.units = "";
      numeric_33.caption = "0.0";
      tab_3.push(numeric_33);

      var numeric_34 = new CsiNumeric(543, 341, 75, 25, expressions[47]);
      numeric_34.font = "bold 8pt Arial";
      numeric_34.font_color = "#000000";
      numeric_34.displayVertically = false;
      numeric_34.transparent = true;
      numeric_34.background_color = "#FFFFFF";
      numeric_34.textAlign = 0;
      numeric_34.border_style = 0;
      numeric_34.precision = 0;
      numeric_34.units = "";
      numeric_34.caption = "0.0";
      tab_3.push(numeric_34);

      var numeric_35 = new CsiNumeric(421, 340, 75, 25, expressions[46]);
      numeric_35.font = "bold 8pt Arial";
      numeric_35.font_color = "#000000";
      numeric_35.displayVertically = false;
      numeric_35.transparent = true;
      numeric_35.background_color = "#FFFFFF";
      numeric_35.textAlign = 0;
      numeric_35.border_style = 0;
      numeric_35.precision = 2;
      numeric_35.units = "  m";
      numeric_35.caption = "0.0  m";
      tab_3.push(numeric_35);

      var label_41 = new CsiLabel(69, 242, 171, 25, "PARAMETRO DE MEDICION:");
      label_41.font = "bold 8pt Arial";
      label_41.font_color = "#008000";
      label_41.displayVertically = false;
      label_41.transparent = true;
      label_41.background_color = "#FFFFFF";
      label_41.textAlign = 0;
      label_41.border_style = 0;
      label_41.word_wrap = false;
      label_41.border_style = 0;
      tab_3.push(label_41);

      var image_16 = new CsiImageComponent(246, 11, 197, 52, 'image_3.png', 0, 0, '', 0);
      tab_3.push(image_16);

      var label_42 = new CsiLabel(67, 91, 543, 93, "REPORTE ESTACION \"NAPO EN AHUANO\"\r\n\r\nTIPO: RADAR\r\n\r\nC\u00d3DIGO: H1156");
      label_42.font = "bold 12pt Arial";
      label_42.font_color = "#0000C0";
      label_42.displayVertically = false;
      label_42.transparent = true;
      label_42.background_color = "#0000FF";
      label_42.textAlign = 1;
      label_42.border_style = 0;
      label_42.word_wrap = true;
      label_42.border_style = 0;
      tab_3.push(label_42);

      var graph_3 = new CsiGraph(20, 479, 1107, 558);
      graph_3.graphWidth = 259200000;
      graph_3.plot_area_transparent = 0;
      graph_3.plot_area_color = "#EFEFEF";
      graph_3.plot_area_gradient.visible = 0;
      graph_3.plot_area_gradient.startColor = "#C0C0C0";
      graph_3.plot_area_gradient.midColor = "#FFFFFF";
      graph_3.plot_area_gradient.endColor = "#808080";
      graph_3.plot_area_gradient.direction = Enum.GRADIENT_DIRECTION.BottomTop;
      graph_3.background_gradient.visible = 0;
      graph_3.background_gradient.startColor = "#C0C0C0";
      graph_3.background_gradient.midColor = "#FFFFFF";
      graph_3.background_gradient.endColor = "#808080";
      graph_3.background_gradient.direction = Enum.GRADIENT_DIRECTION.BottomTop;
      graph_3.background_color = "#FFFFFF";
      graph_3.background_transparent = false;
      graph_3.title = "GRAFICAS DE NIVEL DE AGUA";
      graph_3.title_font = "bold 8pt Arial";
      graph_3.title_font_color = "#000000";
      graph_3.legend_visible = true;
      graph_3.legend_font = "bold 8pt Arial";
      graph_3.legend_font_color = "#000000";
      graph_3.leftAxis.time_format = "%d/%m %H:%M";
      graph_3.leftAxis.title_caption = "NIVEL (m)";
      graph_3.leftAxis.title_font = "bold 8pt Arial";
      graph_3.leftAxis.title_color = "#000000";
      graph_3.leftAxis.title_angle = 270;
      graph_3.leftAxis.inverted = 0;
      graph_3.leftAxis.logarithmic = 0;
      graph_3.leftAxis.log_base = 10;
      graph_3.leftAxis.labels_visible = 1;
      graph_3.leftAxis.labels_font = "bold 8pt Arial";
      graph_3.leftAxis.labels_color = "#000000";
      graph_3.leftAxis.label_angle = 0;
      graph_3.leftAxis.label_size = 0;
      graph_3.leftAxis.decimal_places = 2;
      graph_3.leftAxis.auto_label = false;
      graph_3.leftAxis.fixed_decimals = true;
      graph_3.leftAxis.min = 0;
      graph_3.leftAxis.min_offset = 0;
      graph_3.leftAxis.max = 0;
      graph_3.leftAxis.max_offset = 0;
      graph_3.leftAxis.auto_min = 1;
      graph_3.leftAxis.auto_max = 1;
      graph_3.leftAxis.increment = 0;
      graph_3.leftAxis.minor_tick_count = 3;
      graph_3.leftAxis.major_grid_pen_visible = 1;
      graph_3.leftAxis.major_grid_pen_style = 2;
      graph_3.leftAxis.major_grid_pen_color = "#000000";
      graph_3.leftAxis.major_grid_pen_width = 1;
      graph_3.leftAxis.major_grid_pen_end_style = 0;
      graph_3.leftAxis.major_grid_pen_small_space = 0;
      graph_3.leftAxis.minor_grid_pen_visible = 0;
      graph_3.leftAxis.minor_grid_pen_style = 0;
      graph_3.leftAxis.minor_grid_pen_color = "#000000";
      graph_3.leftAxis.minor_grid_pen_width = 1;
      graph_3.leftAxis.minor_grid_pen_end_style = 0;
      graph_3.leftAxis.minor_grid_pen_small_space = 0;
      graph_3.leftAxis.major_ticks_pen_visible = 1;
      graph_3.leftAxis.major_ticks_pen_style = 0;
      graph_3.leftAxis.major_ticks_pen_color = "#000000";
      graph_3.leftAxis.major_ticks_pen_width = 1;
      graph_3.leftAxis.major_ticks_pen_end_style = 0;
      graph_3.leftAxis.major_ticks_pen_small_space = 0;
      graph_3.leftAxis.minor_ticks_pen_visible = 1;
      graph_3.leftAxis.minor_ticks_pen_style = 0;
      graph_3.leftAxis.minor_ticks_pen_color = "#000000";
      graph_3.leftAxis.minor_ticks_pen_width = 1;
      graph_3.leftAxis.minor_ticks_pen_end_style = 0;
      graph_3.leftAxis.minor_ticks_pen_small_space = 0;
      graph_3.leftAxis.axis_pen_visible = 1;
      graph_3.leftAxis.axis_pen_style = 0;
      graph_3.leftAxis.axis_pen_color = "#000000";
      graph_3.leftAxis.axis_pen_width = 2;
      graph_3.leftAxis.axis_pen_end_style = 0;
      graph_3.leftAxis.axis_pen_small_space = 0;
      graph_3.rightAxis.time_format = "%d/%m %H:%M";
      graph_3.rightAxis.title_caption = "Caudal (m3/s)";
      graph_3.rightAxis.title_font = "bold 8pt Arial";
      graph_3.rightAxis.title_color = "#000000";
      graph_3.rightAxis.title_angle = 270;
      graph_3.rightAxis.inverted = 0;
      graph_3.rightAxis.logarithmic = 0;
      graph_3.rightAxis.log_base = 10;
      graph_3.rightAxis.labels_visible = 1;
      graph_3.rightAxis.labels_font = "bold 8pt Arial";
      graph_3.rightAxis.labels_color = "#000000";
      graph_3.rightAxis.label_angle = 0;
      graph_3.rightAxis.label_size = 0;
      graph_3.rightAxis.decimal_places = 0;
      graph_3.rightAxis.auto_label = true;
      graph_3.rightAxis.fixed_decimals = false;
      graph_3.rightAxis.min = 0;
      graph_3.rightAxis.min_offset = 0;
      graph_3.rightAxis.max = 0;
      graph_3.rightAxis.max_offset = 0;
      graph_3.rightAxis.auto_min = 1;
      graph_3.rightAxis.auto_max = 1;
      graph_3.rightAxis.increment = 0;
      graph_3.rightAxis.minor_tick_count = 3;
      graph_3.rightAxis.major_grid_pen_visible = 0;
      graph_3.rightAxis.major_grid_pen_style = 2;
      graph_3.rightAxis.major_grid_pen_color = "#000000";
      graph_3.rightAxis.major_grid_pen_width = 1;
      graph_3.rightAxis.major_grid_pen_end_style = 0;
      graph_3.rightAxis.major_grid_pen_small_space = 0;
      graph_3.rightAxis.minor_grid_pen_visible = 0;
      graph_3.rightAxis.minor_grid_pen_style = 0;
      graph_3.rightAxis.minor_grid_pen_color = "#000000";
      graph_3.rightAxis.minor_grid_pen_width = 1;
      graph_3.rightAxis.minor_grid_pen_end_style = 0;
      graph_3.rightAxis.minor_grid_pen_small_space = 0;
      graph_3.rightAxis.major_ticks_pen_visible = 1;
      graph_3.rightAxis.major_ticks_pen_style = 0;
      graph_3.rightAxis.major_ticks_pen_color = "#000000";
      graph_3.rightAxis.major_ticks_pen_width = 1;
      graph_3.rightAxis.major_ticks_pen_end_style = 0;
      graph_3.rightAxis.major_ticks_pen_small_space = 0;
      graph_3.rightAxis.minor_ticks_pen_visible = 1;
      graph_3.rightAxis.minor_ticks_pen_style = 0;
      graph_3.rightAxis.minor_ticks_pen_color = "#000000";
      graph_3.rightAxis.minor_ticks_pen_width = 1;
      graph_3.rightAxis.minor_ticks_pen_end_style = 0;
      graph_3.rightAxis.minor_ticks_pen_small_space = 0;
      graph_3.rightAxis.axis_pen_visible = 1;
      graph_3.rightAxis.axis_pen_style = 0;
      graph_3.rightAxis.axis_pen_color = "#000000";
      graph_3.rightAxis.axis_pen_width = 2;
      graph_3.rightAxis.axis_pen_end_style = 0;
      graph_3.rightAxis.axis_pen_small_space = 0;
      graph_3.bottomAxis.time_format = "%d/%m %H:%M";
      graph_3.bottomAxis.title_caption = "Fecha-Hora";
      graph_3.bottomAxis.title_font = "bold 8pt Arial";
      graph_3.bottomAxis.title_color = "#000000";
      graph_3.bottomAxis.title_angle = 0;
      graph_3.bottomAxis.inverted = 0;
      graph_3.bottomAxis.logarithmic = 0;
      graph_3.bottomAxis.log_base = 10;
      graph_3.bottomAxis.labels_visible = 1;
      graph_3.bottomAxis.labels_font = "8pt Arial";
      graph_3.bottomAxis.labels_color = "#000000";
      graph_3.bottomAxis.label_angle = 270;
      graph_3.bottomAxis.label_size = 0;
      graph_3.bottomAxis.decimal_places = 3;
      graph_3.bottomAxis.auto_label = false;
      graph_3.bottomAxis.fixed_decimals = false;
      graph_3.bottomAxis.min = 42077.5;
      graph_3.bottomAxis.min_offset = 0;
      graph_3.bottomAxis.max = 42080.5;
      graph_3.bottomAxis.max_offset = 0;
      graph_3.bottomAxis.auto_min = false;
      graph_3.bottomAxis.auto_max = false;
      graph_3.bottomAxis.increment = 0;
      graph_3.bottomAxis.minor_tick_count = 3;
      graph_3.bottomAxis.major_grid_pen_visible = 1;
      graph_3.bottomAxis.major_grid_pen_style = 2;
      graph_3.bottomAxis.major_grid_pen_color = "#000000";
      graph_3.bottomAxis.major_grid_pen_width = 1;
      graph_3.bottomAxis.major_grid_pen_end_style = 0;
      graph_3.bottomAxis.major_grid_pen_small_space = 0;
      graph_3.bottomAxis.minor_grid_pen_visible = 0;
      graph_3.bottomAxis.minor_grid_pen_style = 0;
      graph_3.bottomAxis.minor_grid_pen_color = "#000000";
      graph_3.bottomAxis.minor_grid_pen_width = 1;
      graph_3.bottomAxis.minor_grid_pen_end_style = 0;
      graph_3.bottomAxis.minor_grid_pen_small_space = 0;
      graph_3.bottomAxis.major_ticks_pen_visible = 1;
      graph_3.bottomAxis.major_ticks_pen_style = 0;
      graph_3.bottomAxis.major_ticks_pen_color = "#000000";
      graph_3.bottomAxis.major_ticks_pen_width = 1;
      graph_3.bottomAxis.major_ticks_pen_end_style = 0;
      graph_3.bottomAxis.major_ticks_pen_small_space = 0;
      graph_3.bottomAxis.minor_ticks_pen_visible = 1;
      graph_3.bottomAxis.minor_ticks_pen_style = 0;
      graph_3.bottomAxis.minor_ticks_pen_color = "#000000";
      graph_3.bottomAxis.minor_ticks_pen_width = 1;
      graph_3.bottomAxis.minor_ticks_pen_end_style = 0;
      graph_3.bottomAxis.minor_ticks_pen_small_space = 0;
      graph_3.bottomAxis.axis_pen_visible = 1;
      graph_3.bottomAxis.axis_pen_style = 0;
      graph_3.bottomAxis.axis_pen_color = "#000000";
      graph_3.bottomAxis.axis_pen_width = 2;
      graph_3.bottomAxis.axis_pen_end_style = 0;
      graph_3.bottomAxis.axis_pen_small_space = 0;
      graph_3.bar_count = 0;
      var graph_3_Series_7 = graph_3.createSeries(expressions[43], 0);
      graph_3_Series_7.label = "Promedio";
      graph_3_Series_7.series_type = 0;
      graph_3_Series_7.line_type = 0;
      graph_3_Series_7.line_color = "#008000";
      graph_3_Series_7.line_width = 1;
      graph_3_Series_7.use_stairs = false;
      graph_3_Series_7.point_type = 1;
      graph_3_Series_7.point_color = "#008000";
      graph_3_Series_7.point_size = 2;
      graph_3_Series_7.timeOffset = -1.8e+007;
      var graph_3_Series_8 = graph_3.createSeries(expressions[44], 0);
      graph_3_Series_8.label = "M\u00e1ximo";
      graph_3_Series_8.series_type = 0;
      graph_3_Series_8.line_type = 0;
      graph_3_Series_8.line_color = "#FF0000";
      graph_3_Series_8.line_width = 1;
      graph_3_Series_8.use_stairs = false;
      graph_3_Series_8.point_type = 0;
      graph_3_Series_8.point_color = "#FF0000";
      graph_3_Series_8.point_size = 2;
      graph_3_Series_8.timeOffset = -1.8e+007;
      var graph_3_Series_9 = graph_3.createSeries(expressions[45], 0);
      graph_3_Series_9.label = "M\u00ednimo";
      graph_3_Series_9.series_type = 0;
      graph_3_Series_9.line_type = 0;
      graph_3_Series_9.line_color = "#0000FF";
      graph_3_Series_9.line_width = 1;
      graph_3_Series_9.use_stairs = false;
      graph_3_Series_9.point_type = 2;
      graph_3_Series_9.point_color = "#0000FF";
      graph_3_Series_9.point_size = 2;
      graph_3_Series_9.timeOffset = -1.8e+007;
      graph_3.displayWidth = 259200000;
      graph_3.use_pc_time = false;
      graph_3.legend_visible = 1;
      graph_3.legend_transparent = 1;
      graph_3.legend_back_color = "#FFFFFF";
      graph_3.legend_shadow_color = "#000000";
      graph_3.legend_position = 2;
      graph_3.legend_position_offset = 0;
      graph_3.legend_font = "bold 8pt Arial";
      graph_3.legend_gradient.visible = 0;
      graph_3.legend_gradient.startColor = "#C0C0C0";
      graph_3.legend_gradient.midColor = null;
      graph_3.legend_gradient.endColor = "#FFFFFF";
      graph_3.legend_gradient.direction = Enum.GRADIENT_DIRECTION.LeftRight;
      graph_3.enable_3d = 0;
      graph_3.percent_3d = 15;
      graph_3.zoom_3d = 100;
      graph_3.rotation = 345;
      graph_3.elevation = 345;
      graph_3.orthogonal = 1;
      graph_3.ortho_angle = 45;
      graph_3.plot_border_visible = 1;
      graph_3.plot_border_style = 0;
      graph_3.plot_border_color = "#000000";
      graph_3.plot_border_width = 1;
      tab_3.push(graph_3);

      var label_43 = new CsiLabel(507, 241, 75, 27, "CALIDAD DE\r\nDATO");
      label_43.font = "bold 8pt Arial";
      label_43.font_color = "#008000";
      label_43.displayVertically = false;
      label_43.transparent = true;
      label_43.background_color = "#FFFFFF";
      label_43.textAlign = 1;
      label_43.border_style = 0;
      label_43.word_wrap = false;
      label_43.border_style = 0;
      tab_3.push(label_43);

      var label_44 = new CsiLabel(67, 265, 184, 25, "Fecha y hora");
      label_44.font = "bold 8pt Arial";
      label_44.font_color = "#000000";
      label_44.displayVertically = false;
      label_44.transparent = true;
      label_44.background_color = "#FFFFFF";
      label_44.textAlign = 0;
      label_44.border_style = 0;
      label_44.word_wrap = false;
      label_44.border_style = 0;
      tab_3.push(label_44);

      var label_45 = new CsiLabel(68, 341, 263, 25, "Nivel de Agua Desviaci\u00f3n Est\u00e1ndar");
      label_45.font = "bold 8pt Arial";
      label_45.font_color = "#000000";
      label_45.displayVertically = false;
      label_45.transparent = true;
      label_45.background_color = "#FFFFFF";
      label_45.textAlign = 0;
      label_45.border_style = 0;
      label_45.word_wrap = false;
      label_45.border_style = 0;
      tab_3.push(label_45);

      var label_46 = new CsiLabel(68, 356, 187, 25, "Voltaje de la Bater\u00eda Instant\u00e1nea");
      label_46.font = "bold 8pt Arial";
      label_46.font_color = "#000000";
      label_46.displayVertically = false;
      label_46.transparent = true;
      label_46.background_color = "#FFFFFF";
      label_46.textAlign = 0;
      label_46.border_style = 0;
      label_46.word_wrap = false;
      label_46.border_style = 0;
      tab_3.push(label_46);

      var numeric_36 = new CsiNumeric(388, 265, 115, 25, expressions[42]);
      numeric_36.font = "bold 8pt Arial";
      numeric_36.font_color = "#000000";
      numeric_36.displayVertically = false;
      numeric_36.transparent = true;
      numeric_36.background_color = "#FFFFFF";
      numeric_36.textAlign = 1;
      numeric_36.border_style = 0;
      numeric_36.precision = 0;
      numeric_36.units = " ";
      numeric_36.caption = "0.0 ";
      tab_3.push(numeric_36);

      var table_3 = new CsiTable(300, 1050, 552, 131, expressions[41]);
      table_3.maxRecords = 100;
      table_3.timestampFormat = "%c";
      table_3.timeOffset = 0;
      table_3.newDataAtTop = false;
      table_3.showRecordNumber = false;
      table_3.showAllColumns = false;
      table_3.fontHeading = "12pt Arial";
      table_3.fontContents = "12pt Arial";
      table_3.fontColorHeading = "#000000";
      table_3.fontColorContents = "#000000";
      table_3.tableFilter = ['nivelMax', 'nivelMin', 'nivelAvg', 'nivelSmp', 'battVolt'];
      tab_3.push(table_3);

      var gauge_2 = new CsiGauge(750, 325, 250, 157);
      gauge_2.scale_max = 5;
      gauge_2.scale_min = 0;
      gauge_2.major_tick_count = 11;
      gauge_2.tick_label_precision = 1;
      gauge_2.font_color = "#000000";
      gauge_2.bg_outer_color = "#C0C0C0";
      gauge_2.the_font = "11pt Arial";
      gauge_2.draw_range = 320;
      gauge_2.start_angle = 145;
      gauge_2.transparent_rim = false;
      gauge_2.hub_size_percent = 0.08;
      gauge_2.logarithmic = false;
      var gauge_2_Pointer_2 = gauge_2.createPointer(expressions[40]);
      gauge_2_Pointer_2.length_percent = 1;
      gauge_2_Pointer_2.width_percent = 0.07;
      gauge_2_Pointer_2.margin = 0;
      gauge_2_Pointer_2.style = 0;
      gauge_2_Pointer_2.line_start = 8;
      gauge_2_Pointer_2.line_end = 6;
      gauge_2_Pointer_2.color = "#FF0000";
      gauge_2_Pointer_2.track = 0;
      gauge_2.border_style = 0;
      gauge_2.ends_margin = 0;
      gauge_2.show_scale_labels = true;
      gauge_2.auto_label = false;
      gauge_2.show_tick_axis = true;
      gauge_2.show_major_ticks = true;
      gauge_2.show_minor_ticks = true;
      gauge_2.minor_tick_count = 4;
      gauge_2.major_tick_length = 15;
      gauge_2.minor_tick_length = 5;
      gauge_2.tick_orientation = 1;
      gauge_2.major_tick_color = "#000000";
      gauge_2.minor_tick_color = "#000000";
      gauge_2.minor_tick_alignment = 1;
      gauge_2.show_tick_axis = true;
      gauge_2.tick_label_margin = 1;
      gauge_2.tick_margin = 0;
      gauge_2.show_hub = true;
      gauge_2.transparent = true;
      gauge_2.background_color = "#C0C0C0";
      gauge_2.hub_color = "#C0C0C0";
      gauge_2.hub_on_top = true;
      gauge_2.show_inner_arc = false;
      gauge_2.show_outer_arc = false;
      gauge_2.reverse_scale = false;
      gauge_2.rim_color = "#A9A9A9";
      gauge_2.bg_inner_color = "#FFFFFF";
      gauge_2.createColoredSection(4, 5, 'RGBA(255, 0, 0, 1)');
      gauge_2.createColoredSection(2.5, 4, 'RGBA(255, 255, 0, 1)');
      gauge_2.createColoredSection(0, 2.5, 'RGBA(0, 255, 0, 1)');
      tab_3.push(gauge_2);

      var label_47 = new CsiLabel(807, 504, 150, 30, "Nivel de Agua (m)");
      label_47.font = "12pt Arial Rounded MT Bold";
      label_47.font_color = "#000000";
      label_47.displayVertically = false;
      label_47.transparent = false;
      label_47.background_color = "#FFFFFF";
      label_47.textAlign = 1;
      label_47.border_style = 0;
      label_47.word_wrap = false;
      label_47.border_style = 0;
      tab_3.push(label_47);

      var alarmState_2 = new CsiImageAlarm(725, 375, 50, 50, 'image_4.gif', null);
      alarmState_2.set_identifier("929c33b6-a2c5-42ac-9428-1130ad4b3f8a");
      var alarmState_2_State_1 = alarmState_2.createImageAlarmState('image_5.gif', 'sound_1.wav', 'sound_1.mp3', 'sound_1.ogg');
      alarmState_2_State_1.audioInterval = 1200000;
      alarmState_2_State_1.stateName = "Warning";
      var alarmState_2_State_2 = alarmState_2.createImageAlarmState('image_6.gif', 'sound_2.wav', 'sound_2.mp3', 'sound_2.ogg');
      alarmState_2_State_2.audioInterval = 600000;
      alarmState_2_State_2.stateName = "Critical";
      tab_3.push(alarmState_2);

      graphicsManager.addTab(tab_3);

      var tab_4 = new RTMCScreen();
      tab_4.background_color = "#FFFFFF";
      var image_17 = new CsiImageComponent(54, 235, 554, 372, 'image_1.png', 0, 0, '', 0);
      tab_4.push(image_17);

      var image_18 = new CsiImageComponent(673, 50, 408, 272, 'image_14.JPG', 0, 0, '', 0);
      tab_4.push(image_18);

      var label_48 = new CsiLabel(675, 254, 140, 64, "UBICACION:\r\n\r\nLat:\t        1\u00ba 5' 12\" S\r\nLong:    77\u00ba 55' 15\" O\r\nAltura:  \t547 msnm");
      label_48.font = "italic bold 8pt Arial";
      label_48.font_color = "#FFFBF0";
      label_48.displayVertically = false;
      label_48.transparent = true;
      label_48.background_color = "#FFFFFF";
      label_48.textAlign = 0;
      label_48.border_style = 0;
      label_48.word_wrap = false;
      label_48.border_style = 0;
      tab_4.push(label_48);

      var label_49 = new CsiLabel(67, 281, 184, 25, "Nivel de Agua M\u00e1ximo");
      label_49.font = "bold 8pt Arial";
      label_49.font_color = "#000000";
      label_49.displayVertically = false;
      label_49.transparent = true;
      label_49.background_color = "#FFFFFF";
      label_49.textAlign = 0;
      label_49.border_style = 0;
      label_49.word_wrap = false;
      label_49.border_style = 0;
      tab_4.push(label_49);

      var label_50 = new CsiLabel(67, 295, 192, 25, "Nivel de Agua M\u00ednimo");
      label_50.font = "bold 8pt Arial";
      label_50.font_color = "#000000";
      label_50.displayVertically = false;
      label_50.transparent = true;
      label_50.background_color = "#FFFFFF";
      label_50.textAlign = 0;
      label_50.border_style = 0;
      label_50.word_wrap = false;
      label_50.border_style = 0;
      tab_4.push(label_50);

      var label_51 = new CsiLabel(67, 326, 171, 25, "Nivel de Agua Instant\u00e1neo");
      label_51.font = "bold 8pt Arial";
      label_51.font_color = "#000000";
      label_51.displayVertically = false;
      label_51.transparent = true;
      label_51.background_color = "#FFFFFF";
      label_51.textAlign = 0;
      label_51.border_style = 0;
      label_51.word_wrap = false;
      label_51.border_style = 0;
      tab_4.push(label_51);

      var label_52 = new CsiLabel(67, 310, 195, 25, "Nivel de Agua Promedio");
      label_52.font = "bold 8pt Arial";
      label_52.font_color = "#000000";
      label_52.displayVertically = false;
      label_52.transparent = true;
      label_52.background_color = "#FFFFFF";
      label_52.textAlign = 0;
      label_52.border_style = 0;
      label_52.word_wrap = false;
      label_52.border_style = 0;
      tab_4.push(label_52);

      var label_53 = new CsiLabel(404, 241, 68, 11, "MEDICI\u00d3N");
      label_53.font = "bold 8pt Arial";
      label_53.font_color = "#008000";
      label_53.displayVertically = false;
      label_53.transparent = true;
      label_53.background_color = "#FFFFFF";
      label_53.textAlign = 0;
      label_53.border_style = 0;
      label_53.word_wrap = false;
      label_53.border_style = 0;
      tab_4.push(label_53);

      var numeric_37 = new CsiNumeric(421, 281, 75, 25, expressions[74]);
      numeric_37.font = "bold 8pt Arial";
      numeric_37.font_color = "#000000";
      numeric_37.displayVertically = false;
      numeric_37.transparent = true;
      numeric_37.background_color = "#FFFFFF";
      numeric_37.textAlign = 0;
      numeric_37.border_style = 0;
      numeric_37.precision = 2;
      numeric_37.units = "  m";
      numeric_37.caption = "0.0  m";
      tab_4.push(numeric_37);

      var numeric_38 = new CsiNumeric(543, 356, 75, 25, expressions[73]);
      numeric_38.font = "bold 8pt Arial";
      numeric_38.font_color = "#000000";
      numeric_38.displayVertically = false;
      numeric_38.transparent = true;
      numeric_38.background_color = "#FFFFFF";
      numeric_38.textAlign = 0;
      numeric_38.border_style = 0;
      numeric_38.precision = 0;
      numeric_38.units = " ";
      numeric_38.caption = "0.0 ";
      tab_4.push(numeric_38);

      var numeric_39 = new CsiNumeric(421, 295, 75, 25, expressions[72]);
      numeric_39.font = "bold 8pt Arial";
      numeric_39.font_color = "#000000";
      numeric_39.displayVertically = false;
      numeric_39.transparent = true;
      numeric_39.background_color = "#FFFFFF";
      numeric_39.textAlign = 0;
      numeric_39.border_style = 0;
      numeric_39.precision = 2;
      numeric_39.units = "  m";
      numeric_39.caption = "0.0  m";
      tab_4.push(numeric_39);

      var numeric_40 = new CsiNumeric(421, 310, 75, 25, expressions[71]);
      numeric_40.font = "bold 8pt Arial";
      numeric_40.font_color = "#000000";
      numeric_40.displayVertically = false;
      numeric_40.transparent = true;
      numeric_40.background_color = "#FFFFFF";
      numeric_40.textAlign = 0;
      numeric_40.border_style = 0;
      numeric_40.precision = 2;
      numeric_40.units = "  m";
      numeric_40.caption = "0.0  m";
      tab_4.push(numeric_40);

      var numeric_41 = new CsiNumeric(543, 295, 75, 25, expressions[70]);
      numeric_41.font = "bold 8pt Arial";
      numeric_41.font_color = "#000000";
      numeric_41.displayVertically = false;
      numeric_41.transparent = true;
      numeric_41.background_color = "#FFFFFF";
      numeric_41.textAlign = 0;
      numeric_41.border_style = 0;
      numeric_41.precision = 0;
      numeric_41.units = "";
      numeric_41.caption = "0.0";
      tab_4.push(numeric_41);

      var numeric_42 = new CsiNumeric(421, 325, 75, 25, expressions[69]);
      numeric_42.font = "bold 8pt Arial";
      numeric_42.font_color = "#000000";
      numeric_42.displayVertically = false;
      numeric_42.transparent = true;
      numeric_42.background_color = "#FFFFFF";
      numeric_42.textAlign = 0;
      numeric_42.border_style = 0;
      numeric_42.precision = 2;
      numeric_42.units = "  m";
      numeric_42.caption = "0.0  m";
      tab_4.push(numeric_42);

      var numeric_43 = new CsiNumeric(543, 280, 75, 25, expressions[68]);
      numeric_43.font = "bold 8pt Arial";
      numeric_43.font_color = "#000000";
      numeric_43.displayVertically = false;
      numeric_43.transparent = true;
      numeric_43.background_color = "#FFFFFF";
      numeric_43.textAlign = 0;
      numeric_43.border_style = 0;
      numeric_43.precision = 0;
      numeric_43.units = "";
      numeric_43.caption = "0.0";
      tab_4.push(numeric_43);

      var numeric_44 = new CsiNumeric(543, 326, 75, 25, expressions[67]);
      numeric_44.font = "bold 8pt Arial";
      numeric_44.font_color = "#000000";
      numeric_44.displayVertically = false;
      numeric_44.transparent = true;
      numeric_44.background_color = "#FFFFFF";
      numeric_44.textAlign = 0;
      numeric_44.border_style = 0;
      numeric_44.precision = 0;
      numeric_44.units = "";
      numeric_44.caption = "0.0";
      tab_4.push(numeric_44);

      var numeric_45 = new CsiNumeric(421, 356, 75, 25, expressions[66]);
      numeric_45.font = "bold 8pt Arial";
      numeric_45.font_color = "#000000";
      numeric_45.displayVertically = false;
      numeric_45.transparent = true;
      numeric_45.background_color = "#FFFFFF";
      numeric_45.textAlign = 0;
      numeric_45.border_style = 0;
      numeric_45.precision = 2;
      numeric_45.units = "  V";
      numeric_45.caption = "0.0  V";
      tab_4.push(numeric_45);

      var numeric_46 = new CsiNumeric(543, 310, 75, 25, expressions[65]);
      numeric_46.font = "bold 8pt Arial";
      numeric_46.font_color = "#000000";
      numeric_46.displayVertically = false;
      numeric_46.transparent = true;
      numeric_46.background_color = "#FFFFFF";
      numeric_46.textAlign = 0;
      numeric_46.border_style = 0;
      numeric_46.precision = 0;
      numeric_46.units = "";
      numeric_46.caption = "0.0";
      tab_4.push(numeric_46);

      var numeric_47 = new CsiNumeric(543, 341, 75, 25, expressions[64]);
      numeric_47.font = "bold 8pt Arial";
      numeric_47.font_color = "#000000";
      numeric_47.displayVertically = false;
      numeric_47.transparent = true;
      numeric_47.background_color = "#FFFFFF";
      numeric_47.textAlign = 0;
      numeric_47.border_style = 0;
      numeric_47.precision = 0;
      numeric_47.units = "";
      numeric_47.caption = "0.0";
      tab_4.push(numeric_47);

      var numeric_48 = new CsiNumeric(421, 340, 75, 25, expressions[63]);
      numeric_48.font = "bold 8pt Arial";
      numeric_48.font_color = "#000000";
      numeric_48.displayVertically = false;
      numeric_48.transparent = true;
      numeric_48.background_color = "#FFFFFF";
      numeric_48.textAlign = 0;
      numeric_48.border_style = 0;
      numeric_48.precision = 2;
      numeric_48.units = "  m";
      numeric_48.caption = "0.0  m";
      tab_4.push(numeric_48);

      var label_54 = new CsiLabel(69, 242, 171, 25, "PARAMETRO DE MEDICION:");
      label_54.font = "bold 8pt Arial";
      label_54.font_color = "#008000";
      label_54.displayVertically = false;
      label_54.transparent = true;
      label_54.background_color = "#FFFFFF";
      label_54.textAlign = 0;
      label_54.border_style = 0;
      label_54.word_wrap = false;
      label_54.border_style = 0;
      tab_4.push(label_54);

      var image_19 = new CsiImageComponent(246, 11, 197, 52, 'image_3.png', 0, 0, '', 0);
      tab_4.push(image_19);


      var graph_4 = new CsiGraph(25, 475, 1107, 558);
      graph_4.graphWidth = 259200000;
      graph_4.plot_area_transparent = 0;
      graph_4.plot_area_color = "#EFEFEF";
      graph_4.plot_area_gradient.visible = 0;
      graph_4.plot_area_gradient.startColor = "#C0C0C0";
      graph_4.plot_area_gradient.midColor = "#FFFFFF";
      graph_4.plot_area_gradient.endColor = "#808080";
      graph_4.plot_area_gradient.direction = Enum.GRADIENT_DIRECTION.BottomTop;
      graph_4.background_gradient.visible = 0;
      graph_4.background_gradient.startColor = "#C0C0C0";
      graph_4.background_gradient.midColor = "#FFFFFF";
      graph_4.background_gradient.endColor = "#808080";
      graph_4.background_gradient.direction = Enum.GRADIENT_DIRECTION.BottomTop;
      graph_4.background_color = "#FFFFFF";
      graph_4.background_transparent = false;
      graph_4.title = "GRAFICAS DE NIVEL DE AGUA";
      graph_4.title_font = "bold 8pt Arial";
      graph_4.title_font_color = "#000000";
      graph_4.legend_visible = true;
      graph_4.legend_font = "bold 8pt Arial";
      graph_4.legend_font_color = "#000000";
      graph_4.leftAxis.time_format = "%d/%m %H:%M";
      graph_4.leftAxis.title_caption = "NIVEL (m)";
      graph_4.leftAxis.title_font = "bold 8pt Arial";
      graph_4.leftAxis.title_color = "#000000";
      graph_4.leftAxis.title_angle = 270;
      graph_4.leftAxis.inverted = 0;
      graph_4.leftAxis.logarithmic = 0;
      graph_4.leftAxis.log_base = 10;
      graph_4.leftAxis.labels_visible = 1;
      graph_4.leftAxis.labels_font = "bold 8pt Arial";
      graph_4.leftAxis.labels_color = "#000000";
      graph_4.leftAxis.label_angle = 0;
      graph_4.leftAxis.label_size = 0;
      graph_4.leftAxis.decimal_places = 2;
      graph_4.leftAxis.auto_label = false;
      graph_4.leftAxis.fixed_decimals = true;
      graph_4.leftAxis.min = 0;
      graph_4.leftAxis.min_offset = 0;
      graph_4.leftAxis.max = 0;
      graph_4.leftAxis.max_offset = 0;
      graph_4.leftAxis.auto_min = 1;
      graph_4.leftAxis.auto_max = 1;
      graph_4.leftAxis.increment = 0;
      graph_4.leftAxis.minor_tick_count = 3;
      graph_4.leftAxis.major_grid_pen_visible = 1;
      graph_4.leftAxis.major_grid_pen_style = 2;
      graph_4.leftAxis.major_grid_pen_color = "#000000";
      graph_4.leftAxis.major_grid_pen_width = 1;
      graph_4.leftAxis.major_grid_pen_end_style = 0;
      graph_4.leftAxis.major_grid_pen_small_space = 0;
      graph_4.leftAxis.minor_grid_pen_visible = 0;
      graph_4.leftAxis.minor_grid_pen_style = 0;
      graph_4.leftAxis.minor_grid_pen_color = "#000000";
      graph_4.leftAxis.minor_grid_pen_width = 1;
      graph_4.leftAxis.minor_grid_pen_end_style = 0;
      graph_4.leftAxis.minor_grid_pen_small_space = 0;
      graph_4.leftAxis.major_ticks_pen_visible = 1;
      graph_4.leftAxis.major_ticks_pen_style = 0;
      graph_4.leftAxis.major_ticks_pen_color = "#000000";
      graph_4.leftAxis.major_ticks_pen_width = 1;
      graph_4.leftAxis.major_ticks_pen_end_style = 0;
      graph_4.leftAxis.major_ticks_pen_small_space = 0;
      graph_4.leftAxis.minor_ticks_pen_visible = 1;
      graph_4.leftAxis.minor_ticks_pen_style = 0;
      graph_4.leftAxis.minor_ticks_pen_color = "#000000";
      graph_4.leftAxis.minor_ticks_pen_width = 1;
      graph_4.leftAxis.minor_ticks_pen_end_style = 0;
      graph_4.leftAxis.minor_ticks_pen_small_space = 0;
      graph_4.leftAxis.axis_pen_visible = 1;
      graph_4.leftAxis.axis_pen_style = 0;
      graph_4.leftAxis.axis_pen_color = "#000000";
      graph_4.leftAxis.axis_pen_width = 2;
      graph_4.leftAxis.axis_pen_end_style = 0;
      graph_4.leftAxis.axis_pen_small_space = 0;
      graph_4.rightAxis.time_format = "%d/%m %H:%M";
      graph_4.rightAxis.title_caption = "Caudal (m3/s)";
      graph_4.rightAxis.title_font = "bold 8pt Arial";
      graph_4.rightAxis.title_color = "#000000";
      graph_4.rightAxis.title_angle = 270;
      graph_4.rightAxis.inverted = 0;
      graph_4.rightAxis.logarithmic = 0;
      graph_4.rightAxis.log_base = 10;
      graph_4.rightAxis.labels_visible = 1;
      graph_4.rightAxis.labels_font = "bold 8pt Arial";
      graph_4.rightAxis.labels_color = "#000000";
      graph_4.rightAxis.label_angle = 0;
      graph_4.rightAxis.label_size = 0;
      graph_4.rightAxis.decimal_places = 0;
      graph_4.rightAxis.auto_label = true;
      graph_4.rightAxis.fixed_decimals = false;
      graph_4.rightAxis.min = 0;
      graph_4.rightAxis.min_offset = 0;
      graph_4.rightAxis.max = 0;
      graph_4.rightAxis.max_offset = 0;
      graph_4.rightAxis.auto_min = 1;
      graph_4.rightAxis.auto_max = 1;
      graph_4.rightAxis.increment = 0;
      graph_4.rightAxis.minor_tick_count = 3;
      graph_4.rightAxis.major_grid_pen_visible = 0;
      graph_4.rightAxis.major_grid_pen_style = 2;
      graph_4.rightAxis.major_grid_pen_color = "#000000";
      graph_4.rightAxis.major_grid_pen_width = 1;
      graph_4.rightAxis.major_grid_pen_end_style = 0;
      graph_4.rightAxis.major_grid_pen_small_space = 0;
      graph_4.rightAxis.minor_grid_pen_visible = 0;
      graph_4.rightAxis.minor_grid_pen_style = 0;
      graph_4.rightAxis.minor_grid_pen_color = "#000000";
      graph_4.rightAxis.minor_grid_pen_width = 1;
      graph_4.rightAxis.minor_grid_pen_end_style = 0;
      graph_4.rightAxis.minor_grid_pen_small_space = 0;
      graph_4.rightAxis.major_ticks_pen_visible = 1;
      graph_4.rightAxis.major_ticks_pen_style = 0;
      graph_4.rightAxis.major_ticks_pen_color = "#000000";
      graph_4.rightAxis.major_ticks_pen_width = 1;
      graph_4.rightAxis.major_ticks_pen_end_style = 0;
      graph_4.rightAxis.major_ticks_pen_small_space = 0;
      graph_4.rightAxis.minor_ticks_pen_visible = 1;
      graph_4.rightAxis.minor_ticks_pen_style = 0;
      graph_4.rightAxis.minor_ticks_pen_color = "#000000";
      graph_4.rightAxis.minor_ticks_pen_width = 1;
      graph_4.rightAxis.minor_ticks_pen_end_style = 0;
      graph_4.rightAxis.minor_ticks_pen_small_space = 0;
      graph_4.rightAxis.axis_pen_visible = 1;
      graph_4.rightAxis.axis_pen_style = 0;
      graph_4.rightAxis.axis_pen_color = "#000000";
      graph_4.rightAxis.axis_pen_width = 2;
      graph_4.rightAxis.axis_pen_end_style = 0;
      graph_4.rightAxis.axis_pen_small_space = 0;
      graph_4.bottomAxis.time_format = "%d/%m %H:%M";
      graph_4.bottomAxis.title_caption = "Fecha-Hora";
      graph_4.bottomAxis.title_font = "bold 8pt Arial";
      graph_4.bottomAxis.title_color = "#000000";
      graph_4.bottomAxis.title_angle = 0;
      graph_4.bottomAxis.inverted = 0;
      graph_4.bottomAxis.logarithmic = 0;
      graph_4.bottomAxis.log_base = 10;
      graph_4.bottomAxis.labels_visible = 1;
      graph_4.bottomAxis.labels_font = "8pt Arial";
      graph_4.bottomAxis.labels_color = "#000000";
      graph_4.bottomAxis.label_angle = 270;
      graph_4.bottomAxis.label_size = 0;
      graph_4.bottomAxis.decimal_places = 3;
      graph_4.bottomAxis.auto_label = false;
      graph_4.bottomAxis.fixed_decimals = false;
      graph_4.bottomAxis.min = 32871;
      graph_4.bottomAxis.min_offset = 0;
      graph_4.bottomAxis.max = 32874;
      graph_4.bottomAxis.max_offset = 0;
      graph_4.bottomAxis.auto_min = false;
      graph_4.bottomAxis.auto_max = false;
      graph_4.bottomAxis.increment = 0;
      graph_4.bottomAxis.minor_tick_count = 3;
      graph_4.bottomAxis.major_grid_pen_visible = 1;
      graph_4.bottomAxis.major_grid_pen_style = 2;
      graph_4.bottomAxis.major_grid_pen_color = "#000000";
      graph_4.bottomAxis.major_grid_pen_width = 1;
      graph_4.bottomAxis.major_grid_pen_end_style = 0;
      graph_4.bottomAxis.major_grid_pen_small_space = 0;
      graph_4.bottomAxis.minor_grid_pen_visible = 0;
      graph_4.bottomAxis.minor_grid_pen_style = 0;
      graph_4.bottomAxis.minor_grid_pen_color = "#000000";
      graph_4.bottomAxis.minor_grid_pen_width = 1;
      graph_4.bottomAxis.minor_grid_pen_end_style = 0;
      graph_4.bottomAxis.minor_grid_pen_small_space = 0;
      graph_4.bottomAxis.major_ticks_pen_visible = 1;
      graph_4.bottomAxis.major_ticks_pen_style = 0;
      graph_4.bottomAxis.major_ticks_pen_color = "#000000";
      graph_4.bottomAxis.major_ticks_pen_width = 1;
      graph_4.bottomAxis.major_ticks_pen_end_style = 0;
      graph_4.bottomAxis.major_ticks_pen_small_space = 0;
      graph_4.bottomAxis.minor_ticks_pen_visible = 1;
      graph_4.bottomAxis.minor_ticks_pen_style = 0;
      graph_4.bottomAxis.minor_ticks_pen_color = "#000000";
      graph_4.bottomAxis.minor_ticks_pen_width = 1;
      graph_4.bottomAxis.minor_ticks_pen_end_style = 0;
      graph_4.bottomAxis.minor_ticks_pen_small_space = 0;
      graph_4.bottomAxis.axis_pen_visible = 1;
      graph_4.bottomAxis.axis_pen_style = 0;
      graph_4.bottomAxis.axis_pen_color = "#000000";
      graph_4.bottomAxis.axis_pen_width = 2;
      graph_4.bottomAxis.axis_pen_end_style = 0;
      graph_4.bottomAxis.axis_pen_small_space = 0;
      graph_4.bar_count = 0;
      var graph_4_Series_10 = graph_4.createSeries(expressions[60], 0);
      graph_4_Series_10.label = "Promedio";
      graph_4_Series_10.series_type = 0;
      graph_4_Series_10.line_type = 0;
      graph_4_Series_10.line_color = "#008000";
      graph_4_Series_10.line_width = 1;
      graph_4_Series_10.use_stairs = false;
      graph_4_Series_10.point_type = 1;
      graph_4_Series_10.point_color = "#008000";
      graph_4_Series_10.point_size = 2;
      graph_4_Series_10.timeOffset = -1.8e+007;
      var graph_4_Series_11 = graph_4.createSeries(expressions[61], 0);
      graph_4_Series_11.label = "M\u00e1ximo";
      graph_4_Series_11.series_type = 0;
      graph_4_Series_11.line_type = 0;
      graph_4_Series_11.line_color = "#FF0000";
      graph_4_Series_11.line_width = 1;
      graph_4_Series_11.use_stairs = false;
      graph_4_Series_11.point_type = 0;
      graph_4_Series_11.point_color = "#FF0000";
      graph_4_Series_11.point_size = 2;
      graph_4_Series_11.timeOffset = -1.8e+007;
      var graph_4_Series_12 = graph_4.createSeries(expressions[62], 0);
      graph_4_Series_12.label = "M\u00ednimo";
      graph_4_Series_12.series_type = 0;
      graph_4_Series_12.line_type = 0;
      graph_4_Series_12.line_color = "#0000FF";
      graph_4_Series_12.line_width = 1;
      graph_4_Series_12.use_stairs = false;
      graph_4_Series_12.point_type = 2;
      graph_4_Series_12.point_color = "#0000FF";
      graph_4_Series_12.point_size = 2;
      graph_4_Series_12.timeOffset = -1.8e+007;
      graph_4.displayWidth = 259200000;
      graph_4.use_pc_time = false;
      graph_4.legend_visible = 1;
      graph_4.legend_transparent = 1;
      graph_4.legend_back_color = "#FFFFFF";
      graph_4.legend_shadow_color = "#000000";
      graph_4.legend_position = 2;
      graph_4.legend_position_offset = 0;
      graph_4.legend_font = "bold 8pt Arial";
      graph_4.legend_gradient.visible = 0;
      graph_4.legend_gradient.startColor = "#C0C0C0";
      graph_4.legend_gradient.midColor = null;
      graph_4.legend_gradient.endColor = "#FFFFFF";
      graph_4.legend_gradient.direction = Enum.GRADIENT_DIRECTION.LeftRight;
      graph_4.enable_3d = 0;
      graph_4.percent_3d = 15;
      graph_4.zoom_3d = 100;
      graph_4.rotation = 345;
      graph_4.elevation = 345;
      graph_4.orthogonal = 1;
      graph_4.ortho_angle = 45;
      graph_4.plot_border_visible = 1;
      graph_4.plot_border_style = 0;
      graph_4.plot_border_color = "#000000";
      graph_4.plot_border_width = 1;
      tab_4.push(graph_4);

      var label_56 = new CsiLabel(507, 241, 75, 27, "CALIDAD DE\r\nDATO");
      label_56.font = "bold 8pt Arial";
      label_56.font_color = "#008000";
      label_56.displayVertically = false;
      label_56.transparent = true;
      label_56.background_color = "#FFFFFF";
      label_56.textAlign = 1;
      label_56.border_style = 0;
      label_56.word_wrap = false;
      label_56.border_style = 0;
      tab_4.push(label_56);

      var label_57 = new CsiLabel(67, 265, 184, 25, "Fecha y hora");
      label_57.font = "bold 8pt Arial";
      label_57.font_color = "#000000";
      label_57.displayVertically = false;
      label_57.transparent = true;
      label_57.background_color = "#FFFFFF";
      label_57.textAlign = 0;
      label_57.border_style = 0;
      label_57.word_wrap = false;
      label_57.border_style = 0;
      tab_4.push(label_57);

      var label_58 = new CsiLabel(68, 341, 263, 25, "Nivel de Agua Desviaci\u00f3n Est\u00e1ndar");
      label_58.font = "bold 8pt Arial";
      label_58.font_color = "#000000";
      label_58.displayVertically = false;
      label_58.transparent = true;
      label_58.background_color = "#FFFFFF";
      label_58.textAlign = 0;
      label_58.border_style = 0;
      label_58.word_wrap = false;
      label_58.border_style = 0;
      tab_4.push(label_58);

      var label_59 = new CsiLabel(68, 356, 187, 25, "Voltaje de la Bater\u00eda Instant\u00e1nea");
      label_59.font = "bold 8pt Arial";
      label_59.font_color = "#000000";
      label_59.displayVertically = false;
      label_59.transparent = true;
      label_59.background_color = "#FFFFFF";
      label_59.textAlign = 0;
      label_59.border_style = 0;
      label_59.word_wrap = false;
      label_59.border_style = 0;
      tab_4.push(label_59);

      var numeric_49 = new CsiNumeric(388, 265, 115, 25, expressions[59]);
      numeric_49.font = "bold 8pt Arial";
      numeric_49.font_color = "#000000";
      numeric_49.displayVertically = false;
      numeric_49.transparent = true;
      numeric_49.background_color = "#FFFFFF";
      numeric_49.textAlign = 1;
      numeric_49.border_style = 0;
      numeric_49.precision = 0;
      numeric_49.units = " ";
      numeric_49.caption = "0.0 ";
      tab_4.push(numeric_49);

      var gauge_3 = new CsiGauge(750, 325, 250, 157);
      gauge_3.scale_max = 6;
      gauge_3.scale_min = 0;
      gauge_3.major_tick_count = 11;
      gauge_3.tick_label_precision = 1;
      gauge_3.font_color = "#000000";
      gauge_3.bg_outer_color = "#C0C0C0";
      gauge_3.the_font = "11pt Arial";
      gauge_3.draw_range = 320;
      gauge_3.start_angle = 145;
      gauge_3.transparent_rim = false;
      gauge_3.hub_size_percent = 0.08;
      gauge_3.logarithmic = false;
      var gauge_3_Pointer_3 = gauge_3.createPointer(expressions[58]);
      gauge_3_Pointer_3.length_percent = 1;
      gauge_3_Pointer_3.width_percent = 0.07;
      gauge_3_Pointer_3.margin = 0;
      gauge_3_Pointer_3.style = 0;
      gauge_3_Pointer_3.line_start = 8;
      gauge_3_Pointer_3.line_end = 6;
      gauge_3_Pointer_3.color = "#FF0000";
      gauge_3_Pointer_3.track = 0;
      gauge_3.border_style = 0;
      gauge_3.ends_margin = 0;
      gauge_3.show_scale_labels = true;
      gauge_3.auto_label = false;
      gauge_3.show_tick_axis = true;
      gauge_3.show_major_ticks = true;
      gauge_3.show_minor_ticks = true;
      gauge_3.minor_tick_count = 4;
      gauge_3.major_tick_length = 15;
      gauge_3.minor_tick_length = 5;
      gauge_3.tick_orientation = 1;
      gauge_3.major_tick_color = "#000000";
      gauge_3.minor_tick_color = "#000000";
      gauge_3.minor_tick_alignment = 1;
      gauge_3.show_tick_axis = true;
      gauge_3.tick_label_margin = 1;
      gauge_3.tick_margin = 0;
      gauge_3.show_hub = true;
      gauge_3.transparent = true;
      gauge_3.background_color = "#C0C0C0";
      gauge_3.hub_color = "#C0C0C0";
      gauge_3.hub_on_top = true;
      gauge_3.show_inner_arc = false;
      gauge_3.show_outer_arc = false;
      gauge_3.reverse_scale = false;
      gauge_3.rim_color = "#A9A9A9";
      gauge_3.bg_inner_color = "#FFFFFF";
      gauge_3.createColoredSection(4.8, 6, 'RGBA(255, 0, 0, 1)');
      gauge_3.createColoredSection(3.1, 4.8, 'RGBA(255, 255, 0, 1)');
      gauge_3.createColoredSection(0, 3.1, 'RGBA(0, 255, 0, 1)');
      tab_4.push(gauge_3);

      var label_60 = new CsiLabel(807, 504, 150, 30, "Nivel de Agua (m)");
      label_60.font = "12pt Arial Rounded MT Bold";
      label_60.font_color = "#000000";
      label_60.displayVertically = false;
      label_60.transparent = false;
      label_60.background_color = "#FFFFFF";
      label_60.textAlign = 1;
      label_60.border_style = 0;
      label_60.word_wrap = false;
      label_60.border_style = 0;
      tab_4.push(label_60);

      var alarmState_3 = new CsiImageAlarm(725, 375, 50, 50, 'image_4.gif', null);
      alarmState_3.set_identifier("3c707b60-a0bc-4b8e-914b-1898d811e29f");
      var alarmState_3_State_1 = alarmState_3.createImageAlarmState('image_5.gif', 'sound_1.wav', 'sound_1.mp3', 'sound_1.ogg');
      alarmState_3_State_1.audioInterval = 1200000;
      alarmState_3_State_1.stateName = "Warning";
      var alarmState_3_State_2 = alarmState_3.createImageAlarmState('image_6.gif', 'sound_2.wav', 'sound_2.mp3', 'sound_2.ogg');
      alarmState_3_State_2.audioInterval = 600000;
      alarmState_3_State_2.stateName = "Critical";
      tab_4.push(alarmState_3);

      graphicsManager.addTab(tab_4);

      var tab_5 = new RTMCScreen();
      tab_5.background_color = "#FFFFFF";
      var image_20 = new CsiImageComponent(54, 235, 554, 372, 'image_1.png', 0, 0, '', 0);
      tab_5.push(image_20);

      var image_21 = new CsiImageComponent(673, 50, 408, 272, 'image_15.JPG', 0, 0, '', 0);
      tab_5.push(image_21);

      var label_61 = new CsiLabel(675, 254, 140, 64, "UBICACION:\r\n\r\nLat:\t        0\u00ba 32' 21.49\" S\r\nLong:    77\u00ba 1' 41.23\" O\r\nAltura:  \t281 msnm");
      label_61.font = "italic bold 8pt Arial";
      label_61.font_color = "#FFFBF0";
      label_61.displayVertically = false;
      label_61.transparent = true;
      label_61.background_color = "#FFFFFF";
      label_61.textAlign = 0;
      label_61.border_style = 0;
      label_61.word_wrap = false;
      label_61.border_style = 0;
      tab_5.push(label_61);

      var label_62 = new CsiLabel(67, 281, 184, 25, "Nivel de Agua M\u00e1ximo");
      label_62.font = "bold 8pt Arial";
      label_62.font_color = "#000000";
      label_62.displayVertically = false;
      label_62.transparent = true;
      label_62.background_color = "#FFFFFF";
      label_62.textAlign = 0;
      label_62.border_style = 0;
      label_62.word_wrap = false;
      label_62.border_style = 0;
      tab_5.push(label_62);

      var label_63 = new CsiLabel(67, 295, 192, 25, "Nivel de Agua M\u00ednimo");
      label_63.font = "bold 8pt Arial";
      label_63.font_color = "#000000";
      label_63.displayVertically = false;
      label_63.transparent = true;
      label_63.background_color = "#FFFFFF";
      label_63.textAlign = 0;
      label_63.border_style = 0;
      label_63.word_wrap = false;
      label_63.border_style = 0;
      tab_5.push(label_63);

      var label_64 = new CsiLabel(67, 326, 171, 25, "Nivel de Agua Instant\u00e1neo");
      label_64.font = "bold 8pt Arial";
      label_64.font_color = "#000000";
      label_64.displayVertically = false;
      label_64.transparent = true;
      label_64.background_color = "#FFFFFF";
      label_64.textAlign = 0;
      label_64.border_style = 0;
      label_64.word_wrap = false;
      label_64.border_style = 0;
      tab_5.push(label_64);

      var label_65 = new CsiLabel(67, 310, 195, 25, "Nivel de Agua Promedio");
      label_65.font = "bold 8pt Arial";
      label_65.font_color = "#000000";
      label_65.displayVertically = false;
      label_65.transparent = true;
      label_65.background_color = "#FFFFFF";
      label_65.textAlign = 0;
      label_65.border_style = 0;
      label_65.word_wrap = false;
      label_65.border_style = 0;
      tab_5.push(label_65);

      var label_66 = new CsiLabel(404, 241, 68, 11, "MEDICI\u00d3N");
      label_66.font = "bold 8pt Arial";
      label_66.font_color = "#008000";
      label_66.displayVertically = false;
      label_66.transparent = true;
      label_66.background_color = "#FFFFFF";
      label_66.textAlign = 0;
      label_66.border_style = 0;
      label_66.word_wrap = false;
      label_66.border_style = 0;
      tab_5.push(label_66);

      var numeric_50 = new CsiNumeric(421, 281, 75, 25, expressions[91]);
      numeric_50.font = "bold 8pt Arial";
      numeric_50.font_color = "#000000";
      numeric_50.displayVertically = false;
      numeric_50.transparent = true;
      numeric_50.background_color = "#FFFFFF";
      numeric_50.textAlign = 0;
      numeric_50.border_style = 0;
      numeric_50.precision = 2;
      numeric_50.units = "  m";
      numeric_50.caption = "0.0  m";
      tab_5.push(numeric_50);

      var numeric_51 = new CsiNumeric(543, 356, 75, 25, expressions[90]);
      numeric_51.font = "bold 8pt Arial";
      numeric_51.font_color = "#000000";
      numeric_51.displayVertically = false;
      numeric_51.transparent = true;
      numeric_51.background_color = "#FFFFFF";
      numeric_51.textAlign = 0;
      numeric_51.border_style = 0;
      numeric_51.precision = 0;
      numeric_51.units = " ";
      numeric_51.caption = "0.0 ";
      tab_5.push(numeric_51);

      var numeric_52 = new CsiNumeric(421, 295, 75, 25, expressions[89]);
      numeric_52.font = "bold 8pt Arial";
      numeric_52.font_color = "#000000";
      numeric_52.displayVertically = false;
      numeric_52.transparent = true;
      numeric_52.background_color = "#FFFFFF";
      numeric_52.textAlign = 0;
      numeric_52.border_style = 0;
      numeric_52.precision = 2;
      numeric_52.units = "  m";
      numeric_52.caption = "0.0  m";
      tab_5.push(numeric_52);

      var numeric_53 = new CsiNumeric(421, 310, 75, 25, expressions[88]);
      numeric_53.font = "bold 8pt Arial";
      numeric_53.font_color = "#000000";
      numeric_53.displayVertically = false;
      numeric_53.transparent = true;
      numeric_53.background_color = "#FFFFFF";
      numeric_53.textAlign = 0;
      numeric_53.border_style = 0;
      numeric_53.precision = 2;
      numeric_53.units = "  m";
      numeric_53.caption = "0.0  m";
      tab_5.push(numeric_53);

      var numeric_54 = new CsiNumeric(543, 295, 75, 25, expressions[87]);
      numeric_54.font = "bold 8pt Arial";
      numeric_54.font_color = "#000000";
      numeric_54.displayVertically = false;
      numeric_54.transparent = true;
      numeric_54.background_color = "#FFFFFF";
      numeric_54.textAlign = 0;
      numeric_54.border_style = 0;
      numeric_54.precision = 0;
      numeric_54.units = "";
      numeric_54.caption = "0.0";
      tab_5.push(numeric_54);

      var numeric_55 = new CsiNumeric(421, 325, 75, 25, expressions[86]);
      numeric_55.font = "bold 8pt Arial";
      numeric_55.font_color = "#000000";
      numeric_55.displayVertically = false;
      numeric_55.transparent = true;
      numeric_55.background_color = "#FFFFFF";
      numeric_55.textAlign = 0;
      numeric_55.border_style = 0;
      numeric_55.precision = 2;
      numeric_55.units = "  m";
      numeric_55.caption = "0.0  m";
      tab_5.push(numeric_55);

      var numeric_56 = new CsiNumeric(543, 280, 75, 25, expressions[85]);
      numeric_56.font = "bold 8pt Arial";
      numeric_56.font_color = "#000000";
      numeric_56.displayVertically = false;
      numeric_56.transparent = true;
      numeric_56.background_color = "#FFFFFF";
      numeric_56.textAlign = 0;
      numeric_56.border_style = 0;
      numeric_56.precision = 0;
      numeric_56.units = "";
      numeric_56.caption = "0.0";
      tab_5.push(numeric_56);

      var numeric_57 = new CsiNumeric(543, 326, 75, 25, expressions[84]);
      numeric_57.font = "bold 8pt Arial";
      numeric_57.font_color = "#000000";
      numeric_57.displayVertically = false;
      numeric_57.transparent = true;
      numeric_57.background_color = "#FFFFFF";
      numeric_57.textAlign = 0;
      numeric_57.border_style = 0;
      numeric_57.precision = 0;
      numeric_57.units = "";
      numeric_57.caption = "0.0";
      tab_5.push(numeric_57);

      var numeric_58 = new CsiNumeric(421, 356, 75, 25, expressions[83]);
      numeric_58.font = "bold 8pt Arial";
      numeric_58.font_color = "#000000";
      numeric_58.displayVertically = false;
      numeric_58.transparent = true;
      numeric_58.background_color = "#FFFFFF";
      numeric_58.textAlign = 0;
      numeric_58.border_style = 0;
      numeric_58.precision = 2;
      numeric_58.units = "  V";
      numeric_58.caption = "0.0  V";
      tab_5.push(numeric_58);

      var numeric_59 = new CsiNumeric(543, 310, 75, 25, expressions[82]);
      numeric_59.font = "bold 8pt Arial";
      numeric_59.font_color = "#000000";
      numeric_59.displayVertically = false;
      numeric_59.transparent = true;
      numeric_59.background_color = "#FFFFFF";
      numeric_59.textAlign = 0;
      numeric_59.border_style = 0;
      numeric_59.precision = 0;
      numeric_59.units = "";
      numeric_59.caption = "0.0";
      tab_5.push(numeric_59);

      var numeric_60 = new CsiNumeric(543, 341, 75, 25, expressions[81]);
      numeric_60.font = "bold 8pt Arial";
      numeric_60.font_color = "#000000";
      numeric_60.displayVertically = false;
      numeric_60.transparent = true;
      numeric_60.background_color = "#FFFFFF";
      numeric_60.textAlign = 0;
      numeric_60.border_style = 0;
      numeric_60.precision = 0;
      numeric_60.units = "";
      numeric_60.caption = "0.0";
      tab_5.push(numeric_60);

      var numeric_61 = new CsiNumeric(421, 340, 75, 25, expressions[80]);
      numeric_61.font = "bold 8pt Arial";
      numeric_61.font_color = "#000000";
      numeric_61.displayVertically = false;
      numeric_61.transparent = true;
      numeric_61.background_color = "#FFFFFF";
      numeric_61.textAlign = 0;
      numeric_61.border_style = 0;
      numeric_61.precision = 2;
      numeric_61.units = "  m";
      numeric_61.caption = "0.0  m";
      tab_5.push(numeric_61);

      var label_67 = new CsiLabel(69, 242, 171, 25, "PARAMETRO DE MEDICION:");
      label_67.font = "bold 8pt Arial";
      label_67.font_color = "#008000";
      label_67.displayVertically = false;
      label_67.transparent = true;
      label_67.background_color = "#FFFFFF";
      label_67.textAlign = 0;
      label_67.border_style = 0;
      label_67.word_wrap = false;
      label_67.border_style = 0;
      tab_5.push(label_67);

      var image_22 = new CsiImageComponent(246, 11, 197, 52, 'image_3.png', 0, 0, '', 0);
      tab_5.push(image_22);


      var graph_5 = new CsiGraph(20, 479, 1107, 558);
      graph_5.graphWidth = 259200000;
      graph_5.plot_area_transparent = 0;
      graph_5.plot_area_color = "#EFEFEF";
      graph_5.plot_area_gradient.visible = 0;
      graph_5.plot_area_gradient.startColor = "#C0C0C0";
      graph_5.plot_area_gradient.midColor = "#FFFFFF";
      graph_5.plot_area_gradient.endColor = "#808080";
      graph_5.plot_area_gradient.direction = Enum.GRADIENT_DIRECTION.BottomTop;
      graph_5.background_gradient.visible = 0;
      graph_5.background_gradient.startColor = "#C0C0C0";
      graph_5.background_gradient.midColor = "#FFFFFF";
      graph_5.background_gradient.endColor = "#808080";
      graph_5.background_gradient.direction = Enum.GRADIENT_DIRECTION.BottomTop;
      graph_5.background_color = "#FFFFFF";
      graph_5.background_transparent = false;
      graph_5.title = "GRAFICAS DE NIVEL DE AGUA";
      graph_5.title_font = "bold 8pt Arial";
      graph_5.title_font_color = "#000000";
      graph_5.legend_visible = true;
      graph_5.legend_font = "bold 8pt Arial";
      graph_5.legend_font_color = "#000000";
      graph_5.leftAxis.time_format = "%d/%m %H:%M";
      graph_5.leftAxis.title_caption = "NIVEL (m)";
      graph_5.leftAxis.title_font = "bold 8pt Arial";
      graph_5.leftAxis.title_color = "#000000";
      graph_5.leftAxis.title_angle = 270;
      graph_5.leftAxis.inverted = 0;
      graph_5.leftAxis.logarithmic = 0;
      graph_5.leftAxis.log_base = 10;
      graph_5.leftAxis.labels_visible = 1;
      graph_5.leftAxis.labels_font = "bold 8pt Arial";
      graph_5.leftAxis.labels_color = "#000000";
      graph_5.leftAxis.label_angle = 0;
      graph_5.leftAxis.label_size = 0;
      graph_5.leftAxis.decimal_places = 2;
      graph_5.leftAxis.auto_label = false;
      graph_5.leftAxis.fixed_decimals = true;
      graph_5.leftAxis.min = 0;
      graph_5.leftAxis.min_offset = 0;
      graph_5.leftAxis.max = 0;
      graph_5.leftAxis.max_offset = 0;
      graph_5.leftAxis.auto_min = 1;
      graph_5.leftAxis.auto_max = 1;
      graph_5.leftAxis.increment = 0;
      graph_5.leftAxis.minor_tick_count = 3;
      graph_5.leftAxis.major_grid_pen_visible = 1;
      graph_5.leftAxis.major_grid_pen_style = 2;
      graph_5.leftAxis.major_grid_pen_color = "#000000";
      graph_5.leftAxis.major_grid_pen_width = 1;
      graph_5.leftAxis.major_grid_pen_end_style = 0;
      graph_5.leftAxis.major_grid_pen_small_space = 0;
      graph_5.leftAxis.minor_grid_pen_visible = 0;
      graph_5.leftAxis.minor_grid_pen_style = 0;
      graph_5.leftAxis.minor_grid_pen_color = "#000000";
      graph_5.leftAxis.minor_grid_pen_width = 1;
      graph_5.leftAxis.minor_grid_pen_end_style = 0;
      graph_5.leftAxis.minor_grid_pen_small_space = 0;
      graph_5.leftAxis.major_ticks_pen_visible = 1;
      graph_5.leftAxis.major_ticks_pen_style = 0;
      graph_5.leftAxis.major_ticks_pen_color = "#000000";
      graph_5.leftAxis.major_ticks_pen_width = 1;
      graph_5.leftAxis.major_ticks_pen_end_style = 0;
      graph_5.leftAxis.major_ticks_pen_small_space = 0;
      graph_5.leftAxis.minor_ticks_pen_visible = 1;
      graph_5.leftAxis.minor_ticks_pen_style = 0;
      graph_5.leftAxis.minor_ticks_pen_color = "#000000";
      graph_5.leftAxis.minor_ticks_pen_width = 1;
      graph_5.leftAxis.minor_ticks_pen_end_style = 0;
      graph_5.leftAxis.minor_ticks_pen_small_space = 0;
      graph_5.leftAxis.axis_pen_visible = 1;
      graph_5.leftAxis.axis_pen_style = 0;
      graph_5.leftAxis.axis_pen_color = "#000000";
      graph_5.leftAxis.axis_pen_width = 2;
      graph_5.leftAxis.axis_pen_end_style = 0;
      graph_5.leftAxis.axis_pen_small_space = 0;
      graph_5.rightAxis.time_format = "%d/%m %H:%M";
      graph_5.rightAxis.title_caption = "Caudal (m3/s)";
      graph_5.rightAxis.title_font = "bold 8pt Arial";
      graph_5.rightAxis.title_color = "#000000";
      graph_5.rightAxis.title_angle = 270;
      graph_5.rightAxis.inverted = 0;
      graph_5.rightAxis.logarithmic = 0;
      graph_5.rightAxis.log_base = 10;
      graph_5.rightAxis.labels_visible = 1;
      graph_5.rightAxis.labels_font = "bold 8pt Arial";
      graph_5.rightAxis.labels_color = "#000000";
      graph_5.rightAxis.label_angle = 0;
      graph_5.rightAxis.label_size = 0;
      graph_5.rightAxis.decimal_places = 0;
      graph_5.rightAxis.auto_label = true;
      graph_5.rightAxis.fixed_decimals = false;
      graph_5.rightAxis.min = 0;
      graph_5.rightAxis.min_offset = 0;
      graph_5.rightAxis.max = 0;
      graph_5.rightAxis.max_offset = 0;
      graph_5.rightAxis.auto_min = 1;
      graph_5.rightAxis.auto_max = 1;
      graph_5.rightAxis.increment = 0;
      graph_5.rightAxis.minor_tick_count = 3;
      graph_5.rightAxis.major_grid_pen_visible = 0;
      graph_5.rightAxis.major_grid_pen_style = 2;
      graph_5.rightAxis.major_grid_pen_color = "#000000";
      graph_5.rightAxis.major_grid_pen_width = 1;
      graph_5.rightAxis.major_grid_pen_end_style = 0;
      graph_5.rightAxis.major_grid_pen_small_space = 0;
      graph_5.rightAxis.minor_grid_pen_visible = 0;
      graph_5.rightAxis.minor_grid_pen_style = 0;
      graph_5.rightAxis.minor_grid_pen_color = "#000000";
      graph_5.rightAxis.minor_grid_pen_width = 1;
      graph_5.rightAxis.minor_grid_pen_end_style = 0;
      graph_5.rightAxis.minor_grid_pen_small_space = 0;
      graph_5.rightAxis.major_ticks_pen_visible = 1;
      graph_5.rightAxis.major_ticks_pen_style = 0;
      graph_5.rightAxis.major_ticks_pen_color = "#000000";
      graph_5.rightAxis.major_ticks_pen_width = 1;
      graph_5.rightAxis.major_ticks_pen_end_style = 0;
      graph_5.rightAxis.major_ticks_pen_small_space = 0;
      graph_5.rightAxis.minor_ticks_pen_visible = 1;
      graph_5.rightAxis.minor_ticks_pen_style = 0;
      graph_5.rightAxis.minor_ticks_pen_color = "#000000";
      graph_5.rightAxis.minor_ticks_pen_width = 1;
      graph_5.rightAxis.minor_ticks_pen_end_style = 0;
      graph_5.rightAxis.minor_ticks_pen_small_space = 0;
      graph_5.rightAxis.axis_pen_visible = 1;
      graph_5.rightAxis.axis_pen_style = 0;
      graph_5.rightAxis.axis_pen_color = "#000000";
      graph_5.rightAxis.axis_pen_width = 2;
      graph_5.rightAxis.axis_pen_end_style = 0;
      graph_5.rightAxis.axis_pen_small_space = 0;
      graph_5.bottomAxis.time_format = "%d/%m %H:%M";
      graph_5.bottomAxis.title_caption = "Fecha-Hora";
      graph_5.bottomAxis.title_font = "bold 8pt Arial";
      graph_5.bottomAxis.title_color = "#000000";
      graph_5.bottomAxis.title_angle = 0;
      graph_5.bottomAxis.inverted = 0;
      graph_5.bottomAxis.logarithmic = 0;
      graph_5.bottomAxis.log_base = 10;
      graph_5.bottomAxis.labels_visible = 1;
      graph_5.bottomAxis.labels_font = "8pt Arial";
      graph_5.bottomAxis.labels_color = "#000000";
      graph_5.bottomAxis.label_angle = 270;
      graph_5.bottomAxis.label_size = 0;
      graph_5.bottomAxis.decimal_places = 3;
      graph_5.bottomAxis.auto_label = false;
      graph_5.bottomAxis.fixed_decimals = false;
      graph_5.bottomAxis.min = 42077.5;
      graph_5.bottomAxis.min_offset = 0;
      graph_5.bottomAxis.max = 42080.5;
      graph_5.bottomAxis.max_offset = 0;
      graph_5.bottomAxis.auto_min = false;
      graph_5.bottomAxis.auto_max = false;
      graph_5.bottomAxis.increment = 0;
      graph_5.bottomAxis.minor_tick_count = 3;
      graph_5.bottomAxis.major_grid_pen_visible = 1;
      graph_5.bottomAxis.major_grid_pen_style = 2;
      graph_5.bottomAxis.major_grid_pen_color = "#000000";
      graph_5.bottomAxis.major_grid_pen_width = 1;
      graph_5.bottomAxis.major_grid_pen_end_style = 0;
      graph_5.bottomAxis.major_grid_pen_small_space = 0;
      graph_5.bottomAxis.minor_grid_pen_visible = 0;
      graph_5.bottomAxis.minor_grid_pen_style = 0;
      graph_5.bottomAxis.minor_grid_pen_color = "#000000";
      graph_5.bottomAxis.minor_grid_pen_width = 1;
      graph_5.bottomAxis.minor_grid_pen_end_style = 0;
      graph_5.bottomAxis.minor_grid_pen_small_space = 0;
      graph_5.bottomAxis.major_ticks_pen_visible = 1;
      graph_5.bottomAxis.major_ticks_pen_style = 0;
      graph_5.bottomAxis.major_ticks_pen_color = "#000000";
      graph_5.bottomAxis.major_ticks_pen_width = 1;
      graph_5.bottomAxis.major_ticks_pen_end_style = 0;
      graph_5.bottomAxis.major_ticks_pen_small_space = 0;
      graph_5.bottomAxis.minor_ticks_pen_visible = 1;
      graph_5.bottomAxis.minor_ticks_pen_style = 0;
      graph_5.bottomAxis.minor_ticks_pen_color = "#000000";
      graph_5.bottomAxis.minor_ticks_pen_width = 1;
      graph_5.bottomAxis.minor_ticks_pen_end_style = 0;
      graph_5.bottomAxis.minor_ticks_pen_small_space = 0;
      graph_5.bottomAxis.axis_pen_visible = 1;
      graph_5.bottomAxis.axis_pen_style = 0;
      graph_5.bottomAxis.axis_pen_color = "#000000";
      graph_5.bottomAxis.axis_pen_width = 2;
      graph_5.bottomAxis.axis_pen_end_style = 0;
      graph_5.bottomAxis.axis_pen_small_space = 0;
      graph_5.bar_count = 0;
      var graph_5_Series_13 = graph_5.createSeries(expressions[77], 0);
      graph_5_Series_13.label = "Promedio";
      graph_5_Series_13.series_type = 0;
      graph_5_Series_13.line_type = 0;
      graph_5_Series_13.line_color = "#008000";
      graph_5_Series_13.line_width = 1;
      graph_5_Series_13.use_stairs = false;
      graph_5_Series_13.point_type = 1;
      graph_5_Series_13.point_color = "#008000";
      graph_5_Series_13.point_size = 2;
      graph_5_Series_13.timeOffset = -1.8e+007;
      var graph_5_Series_14 = graph_5.createSeries(expressions[78], 0);
      graph_5_Series_14.label = "M\u00e1ximo";
      graph_5_Series_14.series_type = 0;
      graph_5_Series_14.line_type = 0;
      graph_5_Series_14.line_color = "#FF0000";
      graph_5_Series_14.line_width = 1;
      graph_5_Series_14.use_stairs = false;
      graph_5_Series_14.point_type = 0;
      graph_5_Series_14.point_color = "#FF0000";
      graph_5_Series_14.point_size = 2;
      graph_5_Series_14.timeOffset = -1.8e+007;
      var graph_5_Series_15 = graph_5.createSeries(expressions[79], 0);
      graph_5_Series_15.label = "M\u00ednimo";
      graph_5_Series_15.series_type = 0;
      graph_5_Series_15.line_type = 0;
      graph_5_Series_15.line_color = "#0000FF";
      graph_5_Series_15.line_width = 1;
      graph_5_Series_15.use_stairs = false;
      graph_5_Series_15.point_type = 2;
      graph_5_Series_15.point_color = "#0000FF";
      graph_5_Series_15.point_size = 2;
      graph_5_Series_15.timeOffset = -1.8e+007;
      graph_5.displayWidth = 259200000;
      graph_5.use_pc_time = false;
      graph_5.legend_visible = 1;
      graph_5.legend_transparent = 1;
      graph_5.legend_back_color = "#FFFFFF";
      graph_5.legend_shadow_color = "#000000";
      graph_5.legend_position = 2;
      graph_5.legend_position_offset = 0;
      graph_5.legend_font = "bold 8pt Arial";
      graph_5.legend_gradient.visible = 0;
      graph_5.legend_gradient.startColor = "#C0C0C0";
      graph_5.legend_gradient.midColor = null;
      graph_5.legend_gradient.endColor = "#FFFFFF";
      graph_5.legend_gradient.direction = Enum.GRADIENT_DIRECTION.LeftRight;
      graph_5.enable_3d = 0;
      graph_5.percent_3d = 15;
      graph_5.zoom_3d = 100;
      graph_5.rotation = 345;
      graph_5.elevation = 345;
      graph_5.orthogonal = 1;
      graph_5.ortho_angle = 45;
      graph_5.plot_border_visible = 1;
      graph_5.plot_border_style = 0;
      graph_5.plot_border_color = "#000000";
      graph_5.plot_border_width = 1;
      tab_5.push(graph_5);

      var label_69 = new CsiLabel(507, 241, 75, 27, "CALIDAD DE\r\nDATO");
      label_69.font = "bold 8pt Arial";
      label_69.font_color = "#008000";
      label_69.displayVertically = false;
      label_69.transparent = true;
      label_69.background_color = "#FFFFFF";
      label_69.textAlign = 1;
      label_69.border_style = 0;
      label_69.word_wrap = false;
      label_69.border_style = 0;
      tab_5.push(label_69);

      var label_70 = new CsiLabel(67, 265, 184, 25, "Fecha y hora");
      label_70.font = "bold 8pt Arial";
      label_70.font_color = "#000000";
      label_70.displayVertically = false;
      label_70.transparent = true;
      label_70.background_color = "#FFFFFF";
      label_70.textAlign = 0;
      label_70.border_style = 0;
      label_70.word_wrap = false;
      label_70.border_style = 0;
      tab_5.push(label_70);

      var label_71 = new CsiLabel(68, 341, 263, 25, "Nivel de Agua Desviaci\u00f3n Est\u00e1ndar");
      label_71.font = "bold 8pt Arial";
      label_71.font_color = "#000000";
      label_71.displayVertically = false;
      label_71.transparent = true;
      label_71.background_color = "#FFFFFF";
      label_71.textAlign = 0;
      label_71.border_style = 0;
      label_71.word_wrap = false;
      label_71.border_style = 0;
      tab_5.push(label_71);

      var label_72 = new CsiLabel(68, 356, 187, 25, "Voltaje de la Bater\u00eda Instant\u00e1nea");
      label_72.font = "bold 8pt Arial";
      label_72.font_color = "#000000";
      label_72.displayVertically = false;
      label_72.transparent = true;
      label_72.background_color = "#FFFFFF";
      label_72.textAlign = 0;
      label_72.border_style = 0;
      label_72.word_wrap = false;
      label_72.border_style = 0;
      tab_5.push(label_72);

      var numeric_62 = new CsiNumeric(388, 265, 115, 25, expressions[76]);
      numeric_62.font = "bold 8pt Arial";
      numeric_62.font_color = "#000000";
      numeric_62.displayVertically = false;
      numeric_62.transparent = true;
      numeric_62.background_color = "#FFFFFF";
      numeric_62.textAlign = 1;
      numeric_62.border_style = 0;
      numeric_62.precision = 0;
      numeric_62.units = " ";
      numeric_62.caption = "0.0 ";
      tab_5.push(numeric_62);

      var label_73 = new CsiLabel(807, 504, 150, 30, "Nivel de Agua (m)");
      label_73.font = "12pt Arial Rounded MT Bold";
      label_73.font_color = "#000000";
      label_73.displayVertically = false;
      label_73.transparent = false;
      label_73.background_color = "#FFFFFF";
      label_73.textAlign = 1;
      label_73.border_style = 0;
      label_73.word_wrap = false;
      label_73.border_style = 0;
      tab_5.push(label_73);

      var gauge_4 = new CsiGauge(757, 336, 250, 157);
      gauge_4.scale_max = 6;
      gauge_4.scale_min = 0;
      gauge_4.major_tick_count = 11;
      gauge_4.tick_label_precision = 1;
      gauge_4.font_color = "#000000";
      gauge_4.bg_outer_color = "#C0C0C0";
      gauge_4.the_font = "11pt Arial";
      gauge_4.draw_range = 320;
      gauge_4.start_angle = 145;
      gauge_4.transparent_rim = false;
      gauge_4.hub_size_percent = 0.08;
      gauge_4.logarithmic = false;
      var gauge_4_Pointer_4 = gauge_4.createPointer(expressions[75]);
      gauge_4_Pointer_4.length_percent = 1;
      gauge_4_Pointer_4.width_percent = 0.07;
      gauge_4_Pointer_4.margin = 0;
      gauge_4_Pointer_4.style = 0;
      gauge_4_Pointer_4.line_start = 8;
      gauge_4_Pointer_4.line_end = 6;
      gauge_4_Pointer_4.color = "#FF0000";
      gauge_4_Pointer_4.track = 0;
      gauge_4.border_style = 0;
      gauge_4.ends_margin = 0;
      gauge_4.show_scale_labels = true;
      gauge_4.auto_label = false;
      gauge_4.show_tick_axis = true;
      gauge_4.show_major_ticks = true;
      gauge_4.show_minor_ticks = true;
      gauge_4.minor_tick_count = 4;
      gauge_4.major_tick_length = 15;
      gauge_4.minor_tick_length = 5;
      gauge_4.tick_orientation = 1;
      gauge_4.major_tick_color = "#000000";
      gauge_4.minor_tick_color = "#000000";
      gauge_4.minor_tick_alignment = 1;
      gauge_4.show_tick_axis = true;
      gauge_4.tick_label_margin = 1;
      gauge_4.tick_margin = 0;
      gauge_4.show_hub = true;
      gauge_4.transparent = true;
      gauge_4.background_color = "#C0C0C0";
      gauge_4.hub_color = "#C0C0C0";
      gauge_4.hub_on_top = true;
      gauge_4.show_inner_arc = false;
      gauge_4.show_outer_arc = false;
      gauge_4.reverse_scale = false;
      gauge_4.rim_color = "#A9A9A9";
      gauge_4.bg_inner_color = "#FFFFFF";
      gauge_4.createColoredSection(4.8, 6, 'RGBA(255, 0, 0, 1)');
      gauge_4.createColoredSection(3.3, 4.8, 'RGBA(255, 255, 0, 1)');
      gauge_4.createColoredSection(0, 3.3, 'RGBA(0, 255, 0, 1)');
      tab_5.push(gauge_4);

      var alarmState_4 = new CsiImageAlarm(730, 390, 50, 50, 'image_4.gif', null);
      alarmState_4.set_identifier("809858d7-ca27-41d0-ba7b-83154b948e8c");
      var alarmState_4_State_1 = alarmState_4.createImageAlarmState('image_5.gif', 'sound_1.wav', 'sound_1.mp3', 'sound_1.ogg');
      alarmState_4_State_1.audioInterval = 1200000;
      alarmState_4_State_1.stateName = "Warning";
      var alarmState_4_State_2 = alarmState_4.createImageAlarmState('image_6.gif', 'sound_2.wav', 'sound_2.mp3', 'sound_2.ogg');
      alarmState_4_State_2.audioInterval = 600000;
      alarmState_4_State_2.stateName = "Critical";
      tab_5.push(alarmState_4);

      graphicsManager.addTab(tab_5);

      var tab_6 = new RTMCScreen();
      tab_6.background_color = "#FFFFFF";
      var image_23 = new CsiImageComponent(54, 235, 554, 372, 'image_1.png', 0, 0, '', 0);
      tab_6.push(image_23);

      var image_24 = new CsiImageComponent(673, 50, 408, 272, 'image_16.jpg', 0, 0, '', 0);
      tab_6.push(image_24);

      var label_74 = new CsiLabel(675, 254, 140, 64, "UBICACION:\r\n\r\nLat:\t        0\u00ba 55' 13\" S\r\nLong:    75\u00ba 23' 54\" O\r\nAltura:  \t196 msnm");
      label_74.font = "italic bold 8pt Arial";
      label_74.font_color = "#FFFBF0";
      label_74.displayVertically = false;
      label_74.transparent = true;
      label_74.background_color = "#FFFFFF";
      label_74.textAlign = 0;
      label_74.border_style = 0;
      label_74.word_wrap = false;
      label_74.border_style = 0;
      tab_6.push(label_74);

      var label_75 = new CsiLabel(67, 281, 184, 25, "Nivel de Agua M\u00e1ximo");
      label_75.font = "bold 8pt Arial";
      label_75.font_color = "#000000";
      label_75.displayVertically = false;
      label_75.transparent = true;
      label_75.background_color = "#FFFFFF";
      label_75.textAlign = 0;
      label_75.border_style = 0;
      label_75.word_wrap = false;
      label_75.border_style = 0;
      tab_6.push(label_75);

      var label_76 = new CsiLabel(67, 295, 192, 25, "Nivel de Agua M\u00ednimo");
      label_76.font = "bold 8pt Arial";
      label_76.font_color = "#000000";
      label_76.displayVertically = false;
      label_76.transparent = true;
      label_76.background_color = "#FFFFFF";
      label_76.textAlign = 0;
      label_76.border_style = 0;
      label_76.word_wrap = false;
      label_76.border_style = 0;
      tab_6.push(label_76);

      var label_77 = new CsiLabel(67, 326, 171, 25, "Nivel de Agua Instant\u00e1neo");
      label_77.font = "bold 8pt Arial";
      label_77.font_color = "#000000";
      label_77.displayVertically = false;
      label_77.transparent = true;
      label_77.background_color = "#FFFFFF";
      label_77.textAlign = 0;
      label_77.border_style = 0;
      label_77.word_wrap = false;
      label_77.border_style = 0;
      tab_6.push(label_77);

      var label_78 = new CsiLabel(67, 310, 195, 25, "Nivel de Agua Promedio");
      label_78.font = "bold 8pt Arial";
      label_78.font_color = "#000000";
      label_78.displayVertically = false;
      label_78.transparent = true;
      label_78.background_color = "#FFFFFF";
      label_78.textAlign = 0;
      label_78.border_style = 0;
      label_78.word_wrap = false;
      label_78.border_style = 0;
      tab_6.push(label_78);

      var label_79 = new CsiLabel(404, 241, 68, 11, "MEDICI\u00d3N");
      label_79.font = "bold 8pt Arial";
      label_79.font_color = "#008000";
      label_79.displayVertically = false;
      label_79.transparent = true;
      label_79.background_color = "#FFFFFF";
      label_79.textAlign = 0;
      label_79.border_style = 0;
      label_79.word_wrap = false;
      label_79.border_style = 0;
      tab_6.push(label_79);

      var numeric_63 = new CsiNumeric(421, 281, 75, 25, expressions[108]);
      numeric_63.font = "bold 8pt Arial";
      numeric_63.font_color = "#000000";
      numeric_63.displayVertically = false;
      numeric_63.transparent = true;
      numeric_63.background_color = "#FFFFFF";
      numeric_63.textAlign = 0;
      numeric_63.border_style = 0;
      numeric_63.precision = 2;
      numeric_63.units = "  m";
      numeric_63.caption = "0.0  m";
      tab_6.push(numeric_63);

      var numeric_64 = new CsiNumeric(543, 356, 75, 25, expressions[107]);
      numeric_64.font = "bold 8pt Arial";
      numeric_64.font_color = "#000000";
      numeric_64.displayVertically = false;
      numeric_64.transparent = true;
      numeric_64.background_color = "#FFFFFF";
      numeric_64.textAlign = 0;
      numeric_64.border_style = 0;
      numeric_64.precision = 0;
      numeric_64.units = " ";
      numeric_64.caption = "0.0 ";
      tab_6.push(numeric_64);

      var numeric_65 = new CsiNumeric(421, 295, 75, 25, expressions[106]);
      numeric_65.font = "bold 8pt Arial";
      numeric_65.font_color = "#000000";
      numeric_65.displayVertically = false;
      numeric_65.transparent = true;
      numeric_65.background_color = "#FFFFFF";
      numeric_65.textAlign = 0;
      numeric_65.border_style = 0;
      numeric_65.precision = 2;
      numeric_65.units = "  m";
      numeric_65.caption = "0.0  m";
      tab_6.push(numeric_65);

      var numeric_66 = new CsiNumeric(421, 310, 75, 25, expressions[105]);
      numeric_66.font = "bold 8pt Arial";
      numeric_66.font_color = "#000000";
      numeric_66.displayVertically = false;
      numeric_66.transparent = true;
      numeric_66.background_color = "#FFFFFF";
      numeric_66.textAlign = 0;
      numeric_66.border_style = 0;
      numeric_66.precision = 2;
      numeric_66.units = "  m";
      numeric_66.caption = "0.0  m";
      tab_6.push(numeric_66);

      var numeric_67 = new CsiNumeric(543, 295, 75, 25, expressions[104]);
      numeric_67.font = "bold 8pt Arial";
      numeric_67.font_color = "#000000";
      numeric_67.displayVertically = false;
      numeric_67.transparent = true;
      numeric_67.background_color = "#FFFFFF";
      numeric_67.textAlign = 0;
      numeric_67.border_style = 0;
      numeric_67.precision = 0;
      numeric_67.units = "";
      numeric_67.caption = "0.0";
      tab_6.push(numeric_67);

      var numeric_68 = new CsiNumeric(421, 325, 75, 25, expressions[103]);
      numeric_68.font = "bold 8pt Arial";
      numeric_68.font_color = "#000000";
      numeric_68.displayVertically = false;
      numeric_68.transparent = true;
      numeric_68.background_color = "#FFFFFF";
      numeric_68.textAlign = 0;
      numeric_68.border_style = 0;
      numeric_68.precision = 2;
      numeric_68.units = "  m";
      numeric_68.caption = "0.0  m";
      tab_6.push(numeric_68);

      var numeric_69 = new CsiNumeric(543, 280, 75, 25, expressions[102]);
      numeric_69.font = "bold 8pt Arial";
      numeric_69.font_color = "#000000";
      numeric_69.displayVertically = false;
      numeric_69.transparent = true;
      numeric_69.background_color = "#FFFFFF";
      numeric_69.textAlign = 0;
      numeric_69.border_style = 0;
      numeric_69.precision = 0;
      numeric_69.units = "";
      numeric_69.caption = "0.0";
      tab_6.push(numeric_69);

      var numeric_70 = new CsiNumeric(543, 326, 75, 25, expressions[101]);
      numeric_70.font = "bold 8pt Arial";
      numeric_70.font_color = "#000000";
      numeric_70.displayVertically = false;
      numeric_70.transparent = true;
      numeric_70.background_color = "#FFFFFF";
      numeric_70.textAlign = 0;
      numeric_70.border_style = 0;
      numeric_70.precision = 0;
      numeric_70.units = "";
      numeric_70.caption = "0.0";
      tab_6.push(numeric_70);

      var numeric_71 = new CsiNumeric(421, 356, 75, 25, expressions[100]);
      numeric_71.font = "bold 8pt Arial";
      numeric_71.font_color = "#000000";
      numeric_71.displayVertically = false;
      numeric_71.transparent = true;
      numeric_71.background_color = "#FFFFFF";
      numeric_71.textAlign = 0;
      numeric_71.border_style = 0;
      numeric_71.precision = 2;
      numeric_71.units = "  V";
      numeric_71.caption = "0.0  V";
      tab_6.push(numeric_71);

      var numeric_72 = new CsiNumeric(543, 310, 75, 25, expressions[99]);
      numeric_72.font = "bold 8pt Arial";
      numeric_72.font_color = "#000000";
      numeric_72.displayVertically = false;
      numeric_72.transparent = true;
      numeric_72.background_color = "#FFFFFF";
      numeric_72.textAlign = 0;
      numeric_72.border_style = 0;
      numeric_72.precision = 0;
      numeric_72.units = "";
      numeric_72.caption = "0.0";
      tab_6.push(numeric_72);

      var numeric_73 = new CsiNumeric(543, 341, 75, 25, expressions[98]);
      numeric_73.font = "bold 8pt Arial";
      numeric_73.font_color = "#000000";
      numeric_73.displayVertically = false;
      numeric_73.transparent = true;
      numeric_73.background_color = "#FFFFFF";
      numeric_73.textAlign = 0;
      numeric_73.border_style = 0;
      numeric_73.precision = 0;
      numeric_73.units = "";
      numeric_73.caption = "0.0";
      tab_6.push(numeric_73);

      var numeric_74 = new CsiNumeric(421, 340, 75, 25, expressions[97]);
      numeric_74.font = "bold 8pt Arial";
      numeric_74.font_color = "#000000";
      numeric_74.displayVertically = false;
      numeric_74.transparent = true;
      numeric_74.background_color = "#FFFFFF";
      numeric_74.textAlign = 0;
      numeric_74.border_style = 0;
      numeric_74.precision = 2;
      numeric_74.units = "  m";
      numeric_74.caption = "0.0  m";
      tab_6.push(numeric_74);

      var label_80 = new CsiLabel(69, 242, 171, 25, "PARAMETRO DE MEDICION:");
      label_80.font = "bold 8pt Arial";
      label_80.font_color = "#008000";
      label_80.displayVertically = false;
      label_80.transparent = true;
      label_80.background_color = "#FFFFFF";
      label_80.textAlign = 0;
      label_80.border_style = 0;
      label_80.word_wrap = false;
      label_80.border_style = 0;
      tab_6.push(label_80);

      var image_25 = new CsiImageComponent(246, 11, 197, 52, 'image_3.png', 0, 0, '', 0);
      tab_6.push(image_25);


      var graph_6 = new CsiGraph(20, 479, 1107, 558);
      graph_6.graphWidth = 259200000;
      graph_6.plot_area_transparent = 0;
      graph_6.plot_area_color = "#EFEFEF";
      graph_6.plot_area_gradient.visible = 0;
      graph_6.plot_area_gradient.startColor = "#C0C0C0";
      graph_6.plot_area_gradient.midColor = "#FFFFFF";
      graph_6.plot_area_gradient.endColor = "#808080";
      graph_6.plot_area_gradient.direction = Enum.GRADIENT_DIRECTION.BottomTop;
      graph_6.background_gradient.visible = 0;
      graph_6.background_gradient.startColor = "#C0C0C0";
      graph_6.background_gradient.midColor = "#FFFFFF";
      graph_6.background_gradient.endColor = "#808080";
      graph_6.background_gradient.direction = Enum.GRADIENT_DIRECTION.BottomTop;
      graph_6.background_color = "#FFFFFF";
      graph_6.background_transparent = false;
      graph_6.title = "GRAFICAS DE NIVEL DE AGUA";
      graph_6.title_font = "bold 8pt Arial";
      graph_6.title_font_color = "#000000";
      graph_6.legend_visible = true;
      graph_6.legend_font = "bold 8pt Arial";
      graph_6.legend_font_color = "#000000";
      graph_6.leftAxis.time_format = "%d/%m %H:%M";
      graph_6.leftAxis.title_caption = "NIVEL (m)";
      graph_6.leftAxis.title_font = "bold 8pt Arial";
      graph_6.leftAxis.title_color = "#000000";
      graph_6.leftAxis.title_angle = 270;
      graph_6.leftAxis.inverted = 0;
      graph_6.leftAxis.logarithmic = 0;
      graph_6.leftAxis.log_base = 10;
      graph_6.leftAxis.labels_visible = 1;
      graph_6.leftAxis.labels_font = "bold 8pt Arial";
      graph_6.leftAxis.labels_color = "#000000";
      graph_6.leftAxis.label_angle = 0;
      graph_6.leftAxis.label_size = 0;
      graph_6.leftAxis.decimal_places = 2;
      graph_6.leftAxis.auto_label = false;
      graph_6.leftAxis.fixed_decimals = true;
      graph_6.leftAxis.min = 0;
      graph_6.leftAxis.min_offset = 0;
      graph_6.leftAxis.max = 0;
      graph_6.leftAxis.max_offset = 0;
      graph_6.leftAxis.auto_min = 1;
      graph_6.leftAxis.auto_max = 1;
      graph_6.leftAxis.increment = 0;
      graph_6.leftAxis.minor_tick_count = 3;
      graph_6.leftAxis.major_grid_pen_visible = 1;
      graph_6.leftAxis.major_grid_pen_style = 2;
      graph_6.leftAxis.major_grid_pen_color = "#000000";
      graph_6.leftAxis.major_grid_pen_width = 1;
      graph_6.leftAxis.major_grid_pen_end_style = 0;
      graph_6.leftAxis.major_grid_pen_small_space = 0;
      graph_6.leftAxis.minor_grid_pen_visible = 0;
      graph_6.leftAxis.minor_grid_pen_style = 0;
      graph_6.leftAxis.minor_grid_pen_color = "#000000";
      graph_6.leftAxis.minor_grid_pen_width = 1;
      graph_6.leftAxis.minor_grid_pen_end_style = 0;
      graph_6.leftAxis.minor_grid_pen_small_space = 0;
      graph_6.leftAxis.major_ticks_pen_visible = 1;
      graph_6.leftAxis.major_ticks_pen_style = 0;
      graph_6.leftAxis.major_ticks_pen_color = "#000000";
      graph_6.leftAxis.major_ticks_pen_width = 1;
      graph_6.leftAxis.major_ticks_pen_end_style = 0;
      graph_6.leftAxis.major_ticks_pen_small_space = 0;
      graph_6.leftAxis.minor_ticks_pen_visible = 1;
      graph_6.leftAxis.minor_ticks_pen_style = 0;
      graph_6.leftAxis.minor_ticks_pen_color = "#000000";
      graph_6.leftAxis.minor_ticks_pen_width = 1;
      graph_6.leftAxis.minor_ticks_pen_end_style = 0;
      graph_6.leftAxis.minor_ticks_pen_small_space = 0;
      graph_6.leftAxis.axis_pen_visible = 1;
      graph_6.leftAxis.axis_pen_style = 0;
      graph_6.leftAxis.axis_pen_color = "#000000";
      graph_6.leftAxis.axis_pen_width = 2;
      graph_6.leftAxis.axis_pen_end_style = 0;
      graph_6.leftAxis.axis_pen_small_space = 0;
      graph_6.rightAxis.time_format = "%d/%m %H:%M";
      graph_6.rightAxis.title_caption = "Caudal (m3/s)";
      graph_6.rightAxis.title_font = "bold 8pt Arial";
      graph_6.rightAxis.title_color = "#000000";
      graph_6.rightAxis.title_angle = 270;
      graph_6.rightAxis.inverted = 0;
      graph_6.rightAxis.logarithmic = 0;
      graph_6.rightAxis.log_base = 10;
      graph_6.rightAxis.labels_visible = 1;
      graph_6.rightAxis.labels_font = "bold 8pt Arial";
      graph_6.rightAxis.labels_color = "#000000";
      graph_6.rightAxis.label_angle = 0;
      graph_6.rightAxis.label_size = 0;
      graph_6.rightAxis.decimal_places = 0;
      graph_6.rightAxis.auto_label = true;
      graph_6.rightAxis.fixed_decimals = false;
      graph_6.rightAxis.min = 0;
      graph_6.rightAxis.min_offset = 0;
      graph_6.rightAxis.max = 0;
      graph_6.rightAxis.max_offset = 0;
      graph_6.rightAxis.auto_min = 1;
      graph_6.rightAxis.auto_max = 1;
      graph_6.rightAxis.increment = 0;
      graph_6.rightAxis.minor_tick_count = 3;
      graph_6.rightAxis.major_grid_pen_visible = 0;
      graph_6.rightAxis.major_grid_pen_style = 2;
      graph_6.rightAxis.major_grid_pen_color = "#000000";
      graph_6.rightAxis.major_grid_pen_width = 1;
      graph_6.rightAxis.major_grid_pen_end_style = 0;
      graph_6.rightAxis.major_grid_pen_small_space = 0;
      graph_6.rightAxis.minor_grid_pen_visible = 0;
      graph_6.rightAxis.minor_grid_pen_style = 0;
      graph_6.rightAxis.minor_grid_pen_color = "#000000";
      graph_6.rightAxis.minor_grid_pen_width = 1;
      graph_6.rightAxis.minor_grid_pen_end_style = 0;
      graph_6.rightAxis.minor_grid_pen_small_space = 0;
      graph_6.rightAxis.major_ticks_pen_visible = 1;
      graph_6.rightAxis.major_ticks_pen_style = 0;
      graph_6.rightAxis.major_ticks_pen_color = "#000000";
      graph_6.rightAxis.major_ticks_pen_width = 1;
      graph_6.rightAxis.major_ticks_pen_end_style = 0;
      graph_6.rightAxis.major_ticks_pen_small_space = 0;
      graph_6.rightAxis.minor_ticks_pen_visible = 1;
      graph_6.rightAxis.minor_ticks_pen_style = 0;
      graph_6.rightAxis.minor_ticks_pen_color = "#000000";
      graph_6.rightAxis.minor_ticks_pen_width = 1;
      graph_6.rightAxis.minor_ticks_pen_end_style = 0;
      graph_6.rightAxis.minor_ticks_pen_small_space = 0;
      graph_6.rightAxis.axis_pen_visible = 1;
      graph_6.rightAxis.axis_pen_style = 0;
      graph_6.rightAxis.axis_pen_color = "#000000";
      graph_6.rightAxis.axis_pen_width = 2;
      graph_6.rightAxis.axis_pen_end_style = 0;
      graph_6.rightAxis.axis_pen_small_space = 0;
      graph_6.bottomAxis.time_format = "%d/%m %H:%M";
      graph_6.bottomAxis.title_caption = "Fecha-Hora";
      graph_6.bottomAxis.title_font = "bold 8pt Arial";
      graph_6.bottomAxis.title_color = "#000000";
      graph_6.bottomAxis.title_angle = 0;
      graph_6.bottomAxis.inverted = 0;
      graph_6.bottomAxis.logarithmic = 0;
      graph_6.bottomAxis.log_base = 10;
      graph_6.bottomAxis.labels_visible = 1;
      graph_6.bottomAxis.labels_font = "8pt Arial";
      graph_6.bottomAxis.labels_color = "#000000";
      graph_6.bottomAxis.label_angle = 270;
      graph_6.bottomAxis.label_size = 0;
      graph_6.bottomAxis.decimal_places = 3;
      graph_6.bottomAxis.auto_label = false;
      graph_6.bottomAxis.fixed_decimals = false;
      graph_6.bottomAxis.min = 42077.5;
      graph_6.bottomAxis.min_offset = 0;
      graph_6.bottomAxis.max = 42080.5;
      graph_6.bottomAxis.max_offset = 0;
      graph_6.bottomAxis.auto_min = false;
      graph_6.bottomAxis.auto_max = false;
      graph_6.bottomAxis.increment = 0;
      graph_6.bottomAxis.minor_tick_count = 3;
      graph_6.bottomAxis.major_grid_pen_visible = 1;
      graph_6.bottomAxis.major_grid_pen_style = 2;
      graph_6.bottomAxis.major_grid_pen_color = "#000000";
      graph_6.bottomAxis.major_grid_pen_width = 1;
      graph_6.bottomAxis.major_grid_pen_end_style = 0;
      graph_6.bottomAxis.major_grid_pen_small_space = 0;
      graph_6.bottomAxis.minor_grid_pen_visible = 0;
      graph_6.bottomAxis.minor_grid_pen_style = 0;
      graph_6.bottomAxis.minor_grid_pen_color = "#000000";
      graph_6.bottomAxis.minor_grid_pen_width = 1;
      graph_6.bottomAxis.minor_grid_pen_end_style = 0;
      graph_6.bottomAxis.minor_grid_pen_small_space = 0;
      graph_6.bottomAxis.major_ticks_pen_visible = 1;
      graph_6.bottomAxis.major_ticks_pen_style = 0;
      graph_6.bottomAxis.major_ticks_pen_color = "#000000";
      graph_6.bottomAxis.major_ticks_pen_width = 1;
      graph_6.bottomAxis.major_ticks_pen_end_style = 0;
      graph_6.bottomAxis.major_ticks_pen_small_space = 0;
      graph_6.bottomAxis.minor_ticks_pen_visible = 1;
      graph_6.bottomAxis.minor_ticks_pen_style = 0;
      graph_6.bottomAxis.minor_ticks_pen_color = "#000000";
      graph_6.bottomAxis.minor_ticks_pen_width = 1;
      graph_6.bottomAxis.minor_ticks_pen_end_style = 0;
      graph_6.bottomAxis.minor_ticks_pen_small_space = 0;
      graph_6.bottomAxis.axis_pen_visible = 1;
      graph_6.bottomAxis.axis_pen_style = 0;
      graph_6.bottomAxis.axis_pen_color = "#000000";
      graph_6.bottomAxis.axis_pen_width = 2;
      graph_6.bottomAxis.axis_pen_end_style = 0;
      graph_6.bottomAxis.axis_pen_small_space = 0;
      graph_6.bar_count = 0;
      var graph_6_Series_16 = graph_6.createSeries(expressions[94], 0);
      graph_6_Series_16.label = "Promedio";
      graph_6_Series_16.series_type = 0;
      graph_6_Series_16.line_type = 0;
      graph_6_Series_16.line_color = "#008000";
      graph_6_Series_16.line_width = 1;
      graph_6_Series_16.use_stairs = false;
      graph_6_Series_16.point_type = 1;
      graph_6_Series_16.point_color = "#008000";
      graph_6_Series_16.point_size = 2;
      graph_6_Series_16.timeOffset = -1.8e+007;
      var graph_6_Series_17 = graph_6.createSeries(expressions[95], 0);
      graph_6_Series_17.label = "M\u00e1ximo";
      graph_6_Series_17.series_type = 0;
      graph_6_Series_17.line_type = 0;
      graph_6_Series_17.line_color = "#FF0000";
      graph_6_Series_17.line_width = 1;
      graph_6_Series_17.use_stairs = false;
      graph_6_Series_17.point_type = 0;
      graph_6_Series_17.point_color = "#FF0000";
      graph_6_Series_17.point_size = 2;
      graph_6_Series_17.timeOffset = -1.8e+007;
      var graph_6_Series_18 = graph_6.createSeries(expressions[96], 0);
      graph_6_Series_18.label = "M\u00ednimo";
      graph_6_Series_18.series_type = 0;
      graph_6_Series_18.line_type = 0;
      graph_6_Series_18.line_color = "#0000FF";
      graph_6_Series_18.line_width = 1;
      graph_6_Series_18.use_stairs = false;
      graph_6_Series_18.point_type = 2;
      graph_6_Series_18.point_color = "#0000FF";
      graph_6_Series_18.point_size = 2;
      graph_6_Series_18.timeOffset = -1.8e+007;
      graph_6.displayWidth = 259200000;
      graph_6.use_pc_time = false;
      graph_6.legend_visible = 1;
      graph_6.legend_transparent = 1;
      graph_6.legend_back_color = "#FFFFFF";
      graph_6.legend_shadow_color = "#000000";
      graph_6.legend_position = 2;
      graph_6.legend_position_offset = 0;
      graph_6.legend_font = "bold 8pt Arial";
      graph_6.legend_gradient.visible = 0;
      graph_6.legend_gradient.startColor = "#C0C0C0";
      graph_6.legend_gradient.midColor = null;
      graph_6.legend_gradient.endColor = "#FFFFFF";
      graph_6.legend_gradient.direction = Enum.GRADIENT_DIRECTION.LeftRight;
      graph_6.enable_3d = 0;
      graph_6.percent_3d = 15;
      graph_6.zoom_3d = 100;
      graph_6.rotation = 345;
      graph_6.elevation = 345;
      graph_6.orthogonal = 1;
      graph_6.ortho_angle = 45;
      graph_6.plot_border_visible = 1;
      graph_6.plot_border_style = 0;
      graph_6.plot_border_color = "#000000";
      graph_6.plot_border_width = 1;
      tab_6.push(graph_6);

      var label_82 = new CsiLabel(507, 241, 75, 27, "CALIDAD DE\r\nDATO");
      label_82.font = "bold 8pt Arial";
      label_82.font_color = "#008000";
      label_82.displayVertically = false;
      label_82.transparent = true;
      label_82.background_color = "#FFFFFF";
      label_82.textAlign = 1;
      label_82.border_style = 0;
      label_82.word_wrap = false;
      label_82.border_style = 0;
      tab_6.push(label_82);

      var label_83 = new CsiLabel(67, 265, 184, 25, "Fecha y hora");
      label_83.font = "bold 8pt Arial";
      label_83.font_color = "#000000";
      label_83.displayVertically = false;
      label_83.transparent = true;
      label_83.background_color = "#FFFFFF";
      label_83.textAlign = 0;
      label_83.border_style = 0;
      label_83.word_wrap = false;
      label_83.border_style = 0;
      tab_6.push(label_83);

      var label_84 = new CsiLabel(68, 341, 263, 25, "Nivel de Agua Desviaci\u00f3n Est\u00e1ndar");
      label_84.font = "bold 8pt Arial";
      label_84.font_color = "#000000";
      label_84.displayVertically = false;
      label_84.transparent = true;
      label_84.background_color = "#FFFFFF";
      label_84.textAlign = 0;
      label_84.border_style = 0;
      label_84.word_wrap = false;
      label_84.border_style = 0;
      tab_6.push(label_84);

      var label_85 = new CsiLabel(68, 356, 187, 25, "Voltaje de la Bater\u00eda Instant\u00e1nea");
      label_85.font = "bold 8pt Arial";
      label_85.font_color = "#000000";
      label_85.displayVertically = false;
      label_85.transparent = true;
      label_85.background_color = "#FFFFFF";
      label_85.textAlign = 0;
      label_85.border_style = 0;
      label_85.word_wrap = false;
      label_85.border_style = 0;
      tab_6.push(label_85);

      var numeric_75 = new CsiNumeric(388, 265, 115, 25, expressions[93]);
      numeric_75.font = "bold 8pt Arial";
      numeric_75.font_color = "#000000";
      numeric_75.displayVertically = false;
      numeric_75.transparent = true;
      numeric_75.background_color = "#FFFFFF";
      numeric_75.textAlign = 1;
      numeric_75.border_style = 0;
      numeric_75.precision = 0;
      numeric_75.units = " ";
      numeric_75.caption = "0.0 ";
      tab_6.push(numeric_75);

      var label_86 = new CsiLabel(807, 504, 150, 30, "Nivel de Agua (m)");
      label_86.font = "12pt Arial Rounded MT Bold";
      label_86.font_color = "#000000";
      label_86.displayVertically = false;
      label_86.transparent = false;
      label_86.background_color = "#FFFFFF";
      label_86.textAlign = 1;
      label_86.border_style = 0;
      label_86.word_wrap = false;
      label_86.border_style = 0;
      tab_6.push(label_86);

      var gauge_5 = new CsiGauge(757, 336, 250, 157);
      gauge_5.scale_max = 7;
      gauge_5.scale_min = 0;
      gauge_5.major_tick_count = 11;
      gauge_5.tick_label_precision = 1;
      gauge_5.font_color = "#000000";
      gauge_5.bg_outer_color = "#C0C0C0";
      gauge_5.the_font = "11pt Arial";
      gauge_5.draw_range = 320;
      gauge_5.start_angle = 145;
      gauge_5.transparent_rim = false;
      gauge_5.hub_size_percent = 0.08;
      gauge_5.logarithmic = false;
      var gauge_5_Pointer_5 = gauge_5.createPointer(expressions[92]);
      gauge_5_Pointer_5.length_percent = 1;
      gauge_5_Pointer_5.width_percent = 0.07;
      gauge_5_Pointer_5.margin = 0;
      gauge_5_Pointer_5.style = 0;
      gauge_5_Pointer_5.line_start = 8;
      gauge_5_Pointer_5.line_end = 6;
      gauge_5_Pointer_5.color = "#FF0000";
      gauge_5_Pointer_5.track = 0;
      gauge_5.border_style = 0;
      gauge_5.ends_margin = 0;
      gauge_5.show_scale_labels = true;
      gauge_5.auto_label = false;
      gauge_5.show_tick_axis = true;
      gauge_5.show_major_ticks = true;
      gauge_5.show_minor_ticks = true;
      gauge_5.minor_tick_count = 4;
      gauge_5.major_tick_length = 15;
      gauge_5.minor_tick_length = 5;
      gauge_5.tick_orientation = 1;
      gauge_5.major_tick_color = "#000000";
      gauge_5.minor_tick_color = "#000000";
      gauge_5.minor_tick_alignment = 1;
      gauge_5.show_tick_axis = true;
      gauge_5.tick_label_margin = 1;
      gauge_5.tick_margin = 0;
      gauge_5.show_hub = true;
      gauge_5.transparent = true;
      gauge_5.background_color = "#C0C0C0";
      gauge_5.hub_color = "#C0C0C0";
      gauge_5.hub_on_top = true;
      gauge_5.show_inner_arc = false;
      gauge_5.show_outer_arc = false;
      gauge_5.reverse_scale = false;
      gauge_5.rim_color = "#A9A9A9";
      gauge_5.bg_inner_color = "#FFFFFF";
      gauge_5.createColoredSection(6, 7, 'RGBA(255, 0, 0, 1)');
      gauge_5.createColoredSection(5, 6, 'RGBA(255, 255, 0, 1)');
      gauge_5.createColoredSection(0, 5, 'RGBA(0, 255, 0, 1)');
      tab_6.push(gauge_5);

      var alarmState_5 = new CsiImageAlarm(730, 390, 50, 50, 'image_4.gif', null);
      alarmState_5.set_identifier("74151323-8bc1-4bf4-bab0-212b138813fd");
      var alarmState_5_State_1 = alarmState_5.createImageAlarmState('image_5.gif', 'sound_1.wav', 'sound_1.mp3', 'sound_1.ogg');
      alarmState_5_State_1.audioInterval = 1200000;
      alarmState_5_State_1.stateName = "Warning";
      var alarmState_5_State_2 = alarmState_5.createImageAlarmState('image_6.gif', 'sound_2.wav', 'sound_2.mp3', 'sound_2.ogg');
      alarmState_5_State_2.audioInterval = 600000;
      alarmState_5_State_2.stateName = "Critical";
      tab_6.push(alarmState_5);

      graphicsManager.addTab(tab_6);


      graphicsManager.start();
   }
   else
   {
      $('#canvas_container').prepend('<div>This browser does not support the HTML 5 canvas.</br>Please install the latest version of your browser and try again.</div>');
   }
}

